<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Codeplay ComputeCpp: cl::sycl::atomic&lt; T, addressSpace &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Codeplay ComputeCpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structcl_1_1sycl_1_1atomic.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structcl_1_1sycl_1_1atomic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::atomic&lt; T, addressSpace &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Atomic class template.  
 <a href="structcl_1_1sycl_1_1atomic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="atomic_8h_source.html">atomic.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb88208eb8390745f67e95750ff38bed"><td class="memTemplParams" colspan="2">template&lt;typename pointerT &gt; </td></tr>
<tr class="memitem:afb88208eb8390745f67e95750ff38bed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#afb88208eb8390745f67e95750ff38bed">atomic</a> (<a class="el" href="classcl_1_1sycl_1_1multi__ptr.html">multi_ptr</a>&lt; pointerT, addressSpace &gt; ptr)</td></tr>
<tr class="memdesc:afb88208eb8390745f67e95750ff38bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of SYCL atomic which is associated with the pointer ptr, converted to a pointer of data type T.  <a href="#afb88208eb8390745f67e95750ff38bed">More...</a><br /></td></tr>
<tr class="separator:afb88208eb8390745f67e95750ff38bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc490630b1bb5c540664439931002243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#abc490630b1bb5c540664439931002243">store</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:abc490630b1bb5c540664439931002243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically store operand in m_data.  <a href="#abc490630b1bb5c540664439931002243">More...</a><br /></td></tr>
<tr class="separator:abc490630b1bb5c540664439931002243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012c1b20e85641a21b9a4bdcacde0441"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a012c1b20e85641a21b9a4bdcacde0441">load</a> (<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const </td></tr>
<tr class="memdesc:a012c1b20e85641a21b9a4bdcacde0441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically load from m_data.  <a href="#a012c1b20e85641a21b9a4bdcacde0441">More...</a><br /></td></tr>
<tr class="separator:a012c1b20e85641a21b9a4bdcacde0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b6081e0d53f77ad92a746013189934"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#ad1b6081e0d53f77ad92a746013189934">exchange</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:ad1b6081e0d53f77ad92a746013189934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically exchange operand with *m_data.  <a href="#ad1b6081e0d53f77ad92a746013189934">More...</a><br /></td></tr>
<tr class="separator:ad1b6081e0d53f77ad92a746013189934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2be4c1a034e0057e6849c147b0670c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl.html#a1d914fc15a40816fc6b797dd5e02c444">cl_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a9b2be4c1a034e0057e6849c147b0670c">compare_exchange_strong</a> (T &amp;expected, T desired, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> success=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> fail=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:a9b2be4c1a034e0057e6849c147b0670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compare and optionally exchange expected with *m_data.  <a href="#a9b2be4c1a034e0057e6849c147b0670c">More...</a><br /></td></tr>
<tr class="separator:a9b2be4c1a034e0057e6849c147b0670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971bcb519e822d108a905bd3ccd0d782"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a971bcb519e822d108a905bd3ccd0d782">fetch_add</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:a971bcb519e822d108a905bd3ccd0d782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add operand to *m_data.  <a href="#a971bcb519e822d108a905bd3ccd0d782">More...</a><br /></td></tr>
<tr class="separator:a971bcb519e822d108a905bd3ccd0d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e72f59e687715e333fa0040ae29fe6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#ae4e72f59e687715e333fa0040ae29fe6">fetch_sub</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:ae4e72f59e687715e333fa0040ae29fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtract operand from *m_data.  <a href="#ae4e72f59e687715e333fa0040ae29fe6">More...</a><br /></td></tr>
<tr class="separator:ae4e72f59e687715e333fa0040ae29fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8ed2cdf141be3362e5467c087b7ae1"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a0c8ed2cdf141be3362e5467c087b7ae1">fetch_and</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:a0c8ed2cdf141be3362e5467c087b7ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically bitwise-and operand with *m_data.  <a href="#a0c8ed2cdf141be3362e5467c087b7ae1">More...</a><br /></td></tr>
<tr class="separator:a0c8ed2cdf141be3362e5467c087b7ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d438f1b491d1ac0a5b563d3db03ea13"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a9d438f1b491d1ac0a5b563d3db03ea13">fetch_or</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:a9d438f1b491d1ac0a5b563d3db03ea13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically bitwise-or operand with *m_data.  <a href="#a9d438f1b491d1ac0a5b563d3db03ea13">More...</a><br /></td></tr>
<tr class="separator:a9d438f1b491d1ac0a5b563d3db03ea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f698f63bcb12981bed2a5d639965a0a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a4f698f63bcb12981bed2a5d639965a0a">fetch_xor</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:a4f698f63bcb12981bed2a5d639965a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically bitwise-XOR operand with *m_data.  <a href="#a4f698f63bcb12981bed2a5d639965a0a">More...</a><br /></td></tr>
<tr class="separator:a4f698f63bcb12981bed2a5d639965a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d4ceb2edb9da2ed6289c25f08d69ff"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#a90d4ceb2edb9da2ed6289c25f08d69ff">fetch_min</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:a90d4ceb2edb9da2ed6289c25f08d69ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compare operand to *m_data, storing the smaller of the two in *m_data.  <a href="#a90d4ceb2edb9da2ed6289c25f08d69ff">More...</a><br /></td></tr>
<tr class="separator:a90d4ceb2edb9da2ed6289c25f08d69ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad272c770ff91f550930d2daee540cc6a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1atomic.html#ad272c770ff91f550930d2daee540cc6a">fetch_max</a> (T operand, <a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a> mem_order=<a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a>) const noexcept</td></tr>
<tr class="memdesc:ad272c770ff91f550930d2daee540cc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compare operand to *m_data, storing the larger of the two in *m_data.  <a href="#ad272c770ff91f550930d2daee540cc6a">More...</a><br /></td></tr>
<tr class="separator:ad272c770ff91f550930d2daee540cc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, access::address_space addressSpace&gt;<br />
struct cl::sycl::atomic&lt; T, addressSpace &gt;</h3>

<p>Atomic class template. </p>
<p>Implementation of the SYCL atomic class according to 1.2 spec.</p>
<p>This template class specifies the interface and internal data of atomics as specified by SYCL. It offers several different atomic operations, including min/max which are not otherwise available in C++ 11 code. Most of the file is visible to the device compiler only; this is so that the runtime can call the appropriate atomic function based on the type of the elements. A portion is visible to both (class declaration and global functions) with a small section for the host-only implementation. The device compiler section has separate specializations for each pair of template parameters. They are organized primarily by type (cl_int, cl_uint etc.) and secondarily by address space (global then local). It is done like this because the SPIR function to be called is different based on the type and address space of the atomic.</p>
<p>(section 3.8). On host, calls C++ atomic functions on an std::atomic; on device uses SPIR-mangled OpenCL 1.2 functions to achieve same result. </p>

<p>Definition at line <a class="el" href="atomic_8h_source.html#l00079">79</a> of file <a class="el" href="atomic_8h_source.html">atomic.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb88208eb8390745f67e95750ff38bed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<div class="memtemplate">
template&lt;typename pointerT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::<a class="el" href="structcl_1_1sycl_1_1atomic.html">atomic</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1multi__ptr.html">multi_ptr</a>&lt; pointerT, addressSpace &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an instance of SYCL atomic which is associated with the pointer ptr, converted to a pointer of data type T. </p>
<p>Permitted data types for pointerT is any valid scalar data type which is the same size in bytes as T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pointerT</td><td>Underlying type of the pointer ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to be used in an atomic manner </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="atomic_8h_source.html#l00252">252</a> of file <a class="el" href="atomic_8h_source.html">atomic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9b2be4c1a034e0057e6849c147b0670c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl.html#a1d914fc15a40816fc6b797dd5e02c444">cl_bool</a> <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>fail</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compare and optionally exchange expected with *m_data. </p>
<p>Calls C++11 equivalent on host, has to be implemented "by hand" on device because OpenCL 1.2 and C++ 11 have different semantics for compare and exchange. If *m_data == expected, performs *m_data = desired and returns true. Otherwise, performs expected = *m_data and returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expected</td><td>The value to compare against *m_data. </td></tr>
    <tr><td class="paramname">desired</td><td>The value to store in *m_data on success. </td></tr>
    <tr><td class="paramname">success</td><td>the ordering to use when comparison succeeds. Can only be memory_order_relaxed. </td></tr>
    <tr><td class="paramname">fail</td><td>the ordering to use when comparison fails. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if comparison succeeds, false if it fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1b6081e0d53f77ad92a746013189934"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::exchange </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically exchange operand with *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to store in *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of *m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="a971bcb519e822d108a905bd3ccd0d782"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add operand to *m_data. </p>
<p>param operand the value to add to *m_data. param mem_order the ordering to use. Can only be memory_order_relaxed. return the old value of *m_data. </p>

</div>
</div>
<a class="anchor" id="a0c8ed2cdf141be3362e5467c087b7ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_and </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically bitwise-and operand with *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to and with *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="ad272c770ff91f550930d2daee540cc6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compare operand to *m_data, storing the larger of the two in *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to compare to *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d4ceb2edb9da2ed6289c25f08d69ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compare operand to *m_data, storing the smaller of the two in *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to compare to *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d438f1b491d1ac0a5b563d3db03ea13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_or </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically bitwise-or operand with *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to or with *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4e72f59e687715e333fa0040ae29fe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_sub </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtract operand from *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to subtract from *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f698f63bcb12981bed2a5d639965a0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::fetch_xor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically bitwise-XOR operand with *m_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to XOR with *m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="a012c1b20e85641a21b9a4bdcacde0441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically load from m_data. </p>
<p>Calls C++11 equivalent on host, on device it either calls atomic_add with operand = 0, discarding the result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value loaded from m_data. </dd></dl>

</div>
</div>
<a class="anchor" id="abc490630b1bb5c540664439931002243"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, access::address_space addressSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structcl_1_1sycl_1_1atomic.html">cl::sycl::atomic</a>&lt; T, addressSpace &gt;::store </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76">memory_order</a>&#160;</td>
          <td class="paramname"><em>mem_order</em> = <code><a class="el" href="namespacecl_1_1sycl.html#a2145358fe52a1f70ad8cb1ca7ce89a76a81f32be24a2a62fc472cc43edc97e65b">memory_order::relaxed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically store operand in m_data. </p>
<p>Calls C++11 equivalent on host, on device it calls exchange, discarding the result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>the value to store in m_data. </td></tr>
    <tr><td class="paramname">mem_order</td><td>the ordering to use. Can only be memory_order_relaxed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="atomic_8h_source.html">atomic.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="structcl_1_1sycl_1_1atomic.html">atomic</a></li>
    <li class="footer">Generated on Mon Sep 27 2021 12:13:48 for Codeplay ComputeCpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
