<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Codeplay ComputeCpp: cl::sycl::buffer&lt; T, dims, AllocatorT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Codeplay ComputeCpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcl_1_1sycl_1_1buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcl_1_1sycl_1_1buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::buffer&lt; T, dims, AllocatorT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>buffer is the public interface for the buffer object implementation.  
 <a href="classcl_1_1sycl_1_1buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8h_source.html">buffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cl::sycl::buffer&lt; T, dims, AllocatorT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_1_1sycl_1_1buffer.png" usemap="#cl::sycl::buffer_3C_20T_2C_20dims_2C_20AllocatorT_20_3E_map" alt=""/>
  <map id="cl::sycl::buffer_3C_20T_2C_20dims_2C_20AllocatorT_20_3E_map" name="cl::sycl::buffer&lt; T, dims, AllocatorT &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aff63282600bc1afae49f2353d6b30d3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#aff63282600bc1afae49f2353d6b30d3f">value_type</a> = T</td></tr>
<tr class="memdesc:aff63282600bc1afae49f2353d6b30d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the user, alias for type T.  <a href="#aff63282600bc1afae49f2353d6b30d3f">More...</a><br /></td></tr>
<tr class="separator:aff63282600bc1afae49f2353d6b30d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5697bcd4af8a4b2907cc170d94c84513"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a5697bcd4af8a4b2907cc170d94c84513">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a5697bcd4af8a4b2907cc170d94c84513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the user, alias for reference to type T.  <a href="#a5697bcd4af8a4b2907cc170d94c84513">More...</a><br /></td></tr>
<tr class="separator:a5697bcd4af8a4b2907cc170d94c84513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a23c7b10f75b2bbdb516015a32647"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a889a23c7b10f75b2bbdb516015a32647">const_reference</a> = const T &amp;</td></tr>
<tr class="memdesc:a889a23c7b10f75b2bbdb516015a32647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the user, alias for const reference to type T.  <a href="#a889a23c7b10f75b2bbdb516015a32647">More...</a><br /></td></tr>
<tr class="separator:a889a23c7b10f75b2bbdb516015a32647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23ea38743a345a8171ef1e071336d01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ad23ea38743a345a8171ef1e071336d01">allocator_type</a> = AllocatorT</td></tr>
<tr class="memdesc:ad23ea38743a345a8171ef1e071336d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the user, alias for the type of the allocator.  <a href="#ad23ea38743a345a8171ef1e071336d01">More...</a><br /></td></tr>
<tr class="separator:ad23ea38743a345a8171ef1e071336d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a557a3880433f70dd1ddaf7f8e3ce09a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a557a3880433f70dd1ddaf7f8e3ce09a4">buffer</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a557a3880433f70dd1ddaf7f8e3ce09a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer without a host pointer.  <a href="#a557a3880433f70dd1ddaf7f8e3ce09a4">More...</a><br /></td></tr>
<tr class="separator:a557a3880433f70dd1ddaf7f8e3ce09a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae075a8b2c2e2468f36279addfc130e48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ae075a8b2c2e2468f36279addfc130e48">buffer</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ae075a8b2c2e2468f36279addfc130e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer without a host pointer.  <a href="#ae075a8b2c2e2468f36279addfc130e48">More...</a><br /></td></tr>
<tr class="separator:ae075a8b2c2e2468f36279addfc130e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb035a0746c18df4ac01913f34f4b3d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#aeb035a0746c18df4ac01913f34f4b3d1">buffer</a> (T *hostPointer, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:aeb035a0746c18df4ac01913f34f4b3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer with a host pointer.  <a href="#aeb035a0746c18df4ac01913f34f4b3d1">More...</a><br /></td></tr>
<tr class="separator:aeb035a0746c18df4ac01913f34f4b3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1cff0603a6893aeb071af175a7a3ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#adb1cff0603a6893aeb071af175a7a3ea">buffer</a> (T *hostPointer, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:adb1cff0603a6893aeb071af175a7a3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer with a host pointer.  <a href="#adb1cff0603a6893aeb071af175a7a3ea">More...</a><br /></td></tr>
<tr class="separator:adb1cff0603a6893aeb071af175a7a3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c24f0d2eda54066f3ac58a2dbcc0a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ad8c24f0d2eda54066f3ac58a2dbcc0a5">buffer</a> (const T *hostPointer, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ad8c24f0d2eda54066f3ac58a2dbcc0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer with host pointer.  <a href="#ad8c24f0d2eda54066f3ac58a2dbcc0a5">More...</a><br /></td></tr>
<tr class="separator:ad8c24f0d2eda54066f3ac58a2dbcc0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c4abab4b15601d77fa05d3deeaeb44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a27c4abab4b15601d77fa05d3deeaeb44">buffer</a> (const T *hostPointer, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a27c4abab4b15601d77fa05d3deeaeb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer with host pointer.  <a href="#a27c4abab4b15601d77fa05d3deeaeb44">More...</a><br /></td></tr>
<tr class="separator:a27c4abab4b15601d77fa05d3deeaeb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad678176d14ee58dc47ebb11e9fa4ae54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ad678176d14ee58dc47ebb11e9fa4ae54">buffer</a> (const <a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; &amp;hostPointer, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ad678176d14ee58dc47ebb11e9fa4ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer with a host pointer.  <a href="#ad678176d14ee58dc47ebb11e9fa4ae54">More...</a><br /></td></tr>
<tr class="separator:ad678176d14ee58dc47ebb11e9fa4ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060da31f005db0c3bd37a7caae9db430"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a060da31f005db0c3bd37a7caae9db430">buffer</a> (const <a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; &amp;hostPointer, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa4b43b0aee35624cd95b910189b3dc231">r</a>, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a060da31f005db0c3bd37a7caae9db430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a buffer with a host pointer.  <a href="#a060da31f005db0c3bd37a7caae9db430">More...</a><br /></td></tr>
<tr class="separator:a060da31f005db0c3bd37a7caae9db430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc87d294ae15dbc0f419eb83b438991a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#acc87d294ae15dbc0f419eb83b438991a">buffer</a> (<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;b, const <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;base_index, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;sub_range)</td></tr>
<tr class="memdesc:acc87d294ae15dbc0f419eb83b438991a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer as a subset from an existing buffer.  <a href="#acc87d294ae15dbc0f419eb83b438991a">More...</a><br /></td></tr>
<tr class="separator:acc87d294ae15dbc0f419eb83b438991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d3b75a0d83fe7e861a7759f624898c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a11d3b75a0d83fe7e861a7759f624898c">COMPUTECPP_DEPRECATED_BY_SYCL_VER</a> (201703,&quot;Use the OpenCL interop constructor which takes <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa0cc175b9c0f1b6a831c399e269772661">a</a> SYCL <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> instead.&quot;) buffer(cl_mem mem_object</td></tr>
<tr class="memdesc:a11d3b75a0d83fe7e861a7759f624898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer from an OpenCL object.  <a href="#a11d3b75a0d83fe7e861a7759f624898c">More...</a><br /></td></tr>
<tr class="separator:a11d3b75a0d83fe7e861a7759f624898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82aef65518de4255bdfd1805aeaf12d"><td class="memTemplParams" colspan="2">template&lt;access::mode accessMode&gt; </td></tr>
<tr class="memitem:ad82aef65518de4255bdfd1805aeaf12d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ad82aef65518de4255bdfd1805aeaf12d">get_access</a> ()</td></tr>
<tr class="memdesc:ad82aef65518de4255bdfd1805aeaf12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accessor to the buffer, only used on the host side.  <a href="#ad82aef65518de4255bdfd1805aeaf12d">More...</a><br /></td></tr>
<tr class="separator:ad82aef65518de4255bdfd1805aeaf12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fccf6f8190cce186bea953afb45999f"><td class="memTemplParams" colspan="2">template&lt;access::mode accessMode, access::target accessTarget = access::target::global_buffer&gt; </td></tr>
<tr class="memitem:a5fccf6f8190cce186bea953afb45999f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, accessTarget &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a5fccf6f8190cce186bea953afb45999f">get_access</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;cgh)</td></tr>
<tr class="memdesc:a5fccf6f8190cce186bea953afb45999f"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function returns an accessor to the buffer in the given command_group scope.  <a href="#a5fccf6f8190cce186bea953afb45999f">More...</a><br /></td></tr>
<tr class="separator:a5fccf6f8190cce186bea953afb45999f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7519d63151cd4fa0705a3b8ea207e3"><td class="memTemplParams" colspan="2">template&lt;access::mode accessMode, access::target accessTarget = access::target::global_buffer&gt; </td></tr>
<tr class="memitem:afe7519d63151cd4fa0705a3b8ea207e3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#afe7519d63151cd4fa0705a3b8ea207e3">COMPUTECPP_DEPRECATED_BY_SYCL_VER</a> (201703,&quot;Use overload where the <a class="el" href="classcl_1_1sycl_1_1range.html">range</a> comes before the offset.&quot;) accessor&lt;T</td></tr>
<tr class="memdesc:afe7519d63151cd4fa0705a3b8ea207e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accessor to the buffer in the given command_group scope.  <a href="#afe7519d63151cd4fa0705a3b8ea207e3">More...</a><br /></td></tr>
<tr class="separator:afe7519d63151cd4fa0705a3b8ea207e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c9f3503947bf99ca0841e38d2ad288"><td class="memItemLeft" align="right" valign="top">accessTarget&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a15c9f3503947bf99ca0841e38d2ad288">get_access</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;cgh, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; offset, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>)</td></tr>
<tr class="separator:a15c9f3503947bf99ca0841e38d2ad288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3653bc6eb6ae97e72984d0043fbda45"><td class="memTemplParams" colspan="2">template&lt;access::mode accessMode, access::target accessTarget = access::target::global_buffer&gt; </td></tr>
<tr class="memitem:af3653bc6eb6ae97e72984d0043fbda45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, accessTarget &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#af3653bc6eb6ae97e72984d0043fbda45">get_access</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;cgh, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; offset={})</td></tr>
<tr class="memdesc:af3653bc6eb6ae97e72984d0043fbda45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accessor to the buffer in the given command group scope.  <a href="#af3653bc6eb6ae97e72984d0043fbda45">More...</a><br /></td></tr>
<tr class="separator:af3653bc6eb6ae97e72984d0043fbda45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9977b90f3590d292f0b8c76caa905896"><td class="memTemplParams" colspan="2">template&lt;access::mode accessMode&gt; </td></tr>
<tr class="memitem:a9977b90f3590d292f0b8c76caa905896"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a9977b90f3590d292f0b8c76caa905896">COMPUTECPP_DEPRECATED_BY_SYCL_VER</a> (201703,&quot;Use overload where the <a class="el" href="classcl_1_1sycl_1_1range.html">range</a> comes before the offset.&quot;) accessor&lt;T</td></tr>
<tr class="memdesc:a9977b90f3590d292f0b8c76caa905896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accessor to the buffer, only used on the host side.  <a href="#a9977b90f3590d292f0b8c76caa905896">More...</a><br /></td></tr>
<tr class="separator:a9977b90f3590d292f0b8c76caa905896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e85ae6a1a5a157c17a9931401b1928c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a5e85ae6a1a5a157c17a9931401b1928c">get_access</a> (<a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; offset, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>)</td></tr>
<tr class="separator:a5e85ae6a1a5a157c17a9931401b1928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545e6a0a65cbd5599520bfed2c03bd5f"><td class="memTemplParams" colspan="2">template&lt;access::mode accessMode&gt; </td></tr>
<tr class="memitem:a545e6a0a65cbd5599520bfed2c03bd5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a545e6a0a65cbd5599520bfed2c03bd5f">get_access</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; offset={})</td></tr>
<tr class="memdesc:a545e6a0a65cbd5599520bfed2c03bd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accessor to the buffer, only used on the host side.  <a href="#a545e6a0a65cbd5599520bfed2c03bd5f">More...</a><br /></td></tr>
<tr class="separator:a545e6a0a65cbd5599520bfed2c03bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528a6bef326d9cde72a4927d3a9b1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1range.html">cl::sycl::range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a3528a6bef326d9cde72a4927d3a9b1cb">get_range</a> () const </td></tr>
<tr class="memdesc:a3528a6bef326d9cde72a4927d3a9b1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of the buffer.  <a href="#a3528a6bef326d9cde72a4927d3a9b1cb">More...</a><br /></td></tr>
<tr class="separator:a3528a6bef326d9cde72a4927d3a9b1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558e0ce5148250bb68c733bcb9a2ea50"><td class="memTemplParams" colspan="2">template&lt;typename propertyT &gt; </td></tr>
<tr class="memitem:a558e0ce5148250bb68c733bcb9a2ea50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a558e0ce5148250bb68c733bcb9a2ea50">has_property</a> () const noexcept</td></tr>
<tr class="memdesc:a558e0ce5148250bb68c733bcb9a2ea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this SYCL buffer was constructed with the property specified by propertyT.  <a href="#a558e0ce5148250bb68c733bcb9a2ea50">More...</a><br /></td></tr>
<tr class="separator:a558e0ce5148250bb68c733bcb9a2ea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367bed9217d257ee500bb840ad334509"><td class="memTemplParams" colspan="2">template&lt;typename propertyT &gt; </td></tr>
<tr class="memitem:a367bed9217d257ee500bb840ad334509"><td class="memTemplItemLeft" align="right" valign="top">propertyT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a367bed9217d257ee500bb840ad334509">get_property</a> () const </td></tr>
<tr class="memdesc:a367bed9217d257ee500bb840ad334509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the property of type propertyT that this SYCL buffer was constructed with.  <a href="#a367bed9217d257ee500bb840ad334509">More...</a><br /></td></tr>
<tr class="separator:a367bed9217d257ee500bb840ad334509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca0b5063b15e9550ecf0ed8b6c80cf"><td class="memItemLeft" align="right" valign="top">AllocatorT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ae0ca0b5063b15e9550ecf0ed8b6c80cf">get_allocator</a> () const </td></tr>
<tr class="memdesc:ae0ca0b5063b15e9550ecf0ed8b6c80cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator provided to the buffer.  <a href="#ae0ca0b5063b15e9550ecf0ed8b6c80cf">More...</a><br /></td></tr>
<tr class="separator:ae0ca0b5063b15e9550ecf0ed8b6c80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374df4b7bf6a1ecdd78ae95b45abc0fd"><td class="memTemplParams" colspan="2">template&lt;typename ReinterpretT , int ReinterpretDim&gt; </td></tr>
<tr class="memitem:a374df4b7bf6a1ecdd78ae95b45abc0fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; ReinterpretT, ReinterpretDim, AllocatorT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a374df4b7bf6a1ecdd78ae95b45abc0fd">reinterpret</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; ReinterpretDim &gt; reinterpretRange) const </td></tr>
<tr class="memdesc:a374df4b7bf6a1ecdd78ae95b45abc0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a reinterpreted SYCL buffer.  <a href="#a374df4b7bf6a1ecdd78ae95b45abc0fd">More...</a><br /></td></tr>
<tr class="separator:a374df4b7bf6a1ecdd78ae95b45abc0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5377f65a05218d7abd4777e471da289c"><td class="memTemplParams" colspan="2">template&lt;typename ReinterpretT , int ReinterpretDim = dims&gt; </td></tr>
<tr class="memitem:a5377f65a05218d7abd4777e471da289c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; ReinterpretT, ReinterpretDim, AllocatorT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a5377f65a05218d7abd4777e471da289c">reinterpret</a> () const </td></tr>
<tr class="memdesc:a5377f65a05218d7abd4777e471da289c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a reinterpreted SYCL buffer.  <a href="#a5377f65a05218d7abd4777e471da289c">More...</a><br /></td></tr>
<tr class="separator:a5377f65a05218d7abd4777e471da289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abe778532470c9e9a220836abe344289e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#abe778532470c9e9a220836abe344289e">fromQueue</a></td></tr>
<tr class="separator:abe778532470c9e9a220836abe344289e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835a94da4bdc813299d6c4b5bff1e7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> <a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a835a94da4bdc813299d6c4b5bff1e7c0">available_event</a></td></tr>
<tr class="separator:a835a94da4bdc813299d6c4b5bff1e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f03d30350af3e1a21ffcb7e7dc8b2e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a></td></tr>
<tr class="separator:a1f03d30350af3e1a21ffcb7e7dc8b2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff07c34a6d34aa9129dbf515655de32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a></td></tr>
<tr class="separator:abff07c34a6d34aa9129dbf515655de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aff54d958126efdbfaf8ebe2faa50ab6d"><td class="memItemLeft" align="right" valign="top">static constexpr const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#aff54d958126efdbfaf8ebe2faa50ab6d">dimensions</a> = <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a></td></tr>
<tr class="memdesc:aff54d958126efdbfaf8ebe2faa50ab6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of buffer dimensions (Codeplay extension)  <a href="#aff54d958126efdbfaf8ebe2faa50ab6d">More...</a><br /></td></tr>
<tr class="separator:aff54d958126efdbfaf8ebe2faa50ab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int dims, typename AllocatorT&gt;<br />
class cl::sycl::buffer&lt; T, dims, AllocatorT &gt;</h3>

<p>buffer is the public interface for the buffer object implementation. </p>
<p>The template allows the creation of specific types and number of dimensions. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00050">50</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad23ea38743a345a8171ef1e071336d01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#ad23ea38743a345a8171ef1e071336d01">allocator_type</a> =  AllocatorT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for the user, alias for the type of the allocator. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00343">343</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a889a23c7b10f75b2bbdb516015a32647"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#a889a23c7b10f75b2bbdb516015a32647">const_reference</a> =  const T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for the user, alias for const reference to type T. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00340">340</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5697bcd4af8a4b2907cc170d94c84513"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#a5697bcd4af8a4b2907cc170d94c84513">reference</a> =  T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for the user, alias for reference to type T. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00337">337</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff63282600bc1afae49f2353d6b30d3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#aff63282600bc1afae49f2353d6b30d3f">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for the user, alias for type T. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00334">334</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a557a3880433f70dd1ddaf7f8e3ce09a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer without a host pointer. </p>
<p>The runtime will only use internally allocated memory and no copy in or out is defined. The given allocator is used to create internal storage in case the runtime requires it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00357">357</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae075a8b2c2e2468f36279addfc130e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer without a host pointer. </p>
<p>The runtime will only use internally allocated memory and no copy in or out is defined. The given allocator is used to create internal storage in case the runtime requires it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage in case the runtime requires it. </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00375">375</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb035a0746c18df4ac01913f34f4b3d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>hostPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer with a host pointer. </p>
<p>In this case there is a host pointer, potentially initialized, but the user has not given the runtime any ownership, therefore the deleter has to be null. A Copy in is performed if the pointer is not null. If it is null, the data is initialized (new) inside the runtime. A copy out to hostPointer is performed by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPointer</td><td>Pointer to host data </td></tr>
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00396">396</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="adb1cff0603a6893aeb071af175a7a3ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>hostPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer with a host pointer. </p>
<p>In this case there is a host pointer, potentially initialized, but the user has not given the runtime any ownership, therefore the deleter has to be null. A Copy in is performed if the pointer is not null. If it is null, the data is initialized (new) inside the runtime. A copy out to hostPointer is performed by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPointer</td><td>Pointer to host data </td></tr>
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage in case the runtime requires it. </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00419">419</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad8c24f0d2eda54066f3ac58a2dbcc0a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>hostPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer with host pointer. </p>
<p>The user has given a const pointer, but the buffer is not const, so the runtime copies the data into a temporary space created using the given allocator. If the given allocator is a null allocator, this fails. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPointer</td><td>Pointer to host data </td></tr>
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00438">438</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27c4abab4b15601d77fa05d3deeaeb44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>hostPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer with host pointer. </p>
<p>The user has given a const pointer, but the buffer is not const, so the runtime copies the data into a temporary space created using the given allocator. If the given allocator is a null allocator, this fails. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPointer</td><td>Pointer to host data </td></tr>
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00456">456</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad678176d14ee58dc47ebb11e9fa4ae54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>hostPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer with a host pointer. </p>
<p>The user has given a shared pointer, therefore the data is explicitly shared between the user and the runtime. If the hostPointer is null, no data is copied in, and data is initialized inside the runtime. Data is copied out if the reference count of the runtime is less than the reference count of the shared pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPointer</td><td>Shared pointer to host data </td></tr>
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00476">476</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a060da31f005db0c3bd37a7caae9db430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>hostPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a buffer with a host pointer. </p>
<p>The user has given a shared pointer, therefore the data is explicitly shared between the user and the runtime. If the hostPointer is null, no data is copied in, and data is initialized inside the runtime. Data is copied out if the reference count of the runtime is less than the reference count of the shared pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPointer</td><td>Shared pointer to host data </td></tr>
    <tr><td class="paramname">r</td><td>Range of the buffer </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of buffer properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00495">495</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc87d294ae15dbc0f419eb83b438991a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a buffer as a subset from an existing buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Existing buffer that will act as the parent </td></tr>
    <tr><td class="paramname">base_index</td><td>Offset of the original data to where the sub-buffer data starts </td></tr>
    <tr><td class="paramname">sub_range</td><td>Range of the original data that will be used in the sub-buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00512">512</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a11d3b75a0d83fe7e861a7759f624898c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::COMPUTECPP_DEPRECATED_BY_SYCL_VER </td>
          <td>(</td>
          <td class="paramtype">201703&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Use the OpenCL interop constructor which takes <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3dfa0cc175b9c0f1b6a831c399e269772661">a</a> SYCL <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> instead.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a buffer from an OpenCL object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_object</td><td>the user-provided OpenCL object that will be used by the buffer </td></tr>
    <tr><td class="paramname">fromQueue</td><td>the queue holding the context associated with the mem_object object </td></tr>
    <tr><td class="paramname">available_event</td><td>if provided signals that the cl_mem object has been created and is ready to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe7519d63151cd4fa0705a3b8ea207e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;access::mode accessMode, access::target accessTarget = access::target::global_buffer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::COMPUTECPP_DEPRECATED_BY_SYCL_VER </td>
          <td>(</td>
          <td class="paramtype">201703&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Use overload where the <a class="el" href="classcl_1_1sycl_1_1range.html">range</a> comes before the offset.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accessor to the buffer in the given command_group scope. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accessMode</td><td>All <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450" title="Enum class for specifying the access mode for the accessor. ">access::mode</a> values are accepted </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Defaults to global_buffer, can accept global_buffer or constant_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgh</td><td>Reference to the command group scope where the accessor is requested. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset that the accessor will be able to update from. </td></tr>
    <tr><td class="paramname">range</td><td>the range in which the accessor will be updating the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device accessor </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Need to reverse the order of the access offset and range, see 4.7.2.1 Buffer Interface in SYCL 1.2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a9977b90f3590d292f0b8c76caa905896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;access::mode accessMode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::COMPUTECPP_DEPRECATED_BY_SYCL_VER </td>
          <td>(</td>
          <td class="paramtype">201703&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Use overload where the <a class="el" href="classcl_1_1sycl_1_1range.html">range</a> comes before the offset.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accessor to the buffer, only used on the host side. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accessMode</td><td>All <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450" title="Enum class for specifying the access mode for the accessor. ">access::mode</a> values are accepted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset that the accessor will be able to update from. </td></tr>
    <tr><td class="paramname">range</td><td>The range in which the accessor will be updating the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Host accessor </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Need to reverse the order of the access offset and range, see 4.7.2.1 Buffer Interface in SYCL 1.2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ad82aef65518de4255bdfd1805aeaf12d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;access::mode accessMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accessor to the buffer, only used on the host side. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accessMode</td><td>All <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450" title="Enum class for specifying the access mode for the accessor. ">access::mode</a> values are accepted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Host accessor </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00659">659</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5fccf6f8190cce186bea953afb45999f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;access::mode accessMode, access::target accessTarget = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, accessTarget&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>cgh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function returns an accessor to the buffer in the given command_group scope. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accessMode</td><td>all <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450" title="Enum class for specifying the access mode for the accessor. ">access::mode</a> values are accepted </td></tr>
    <tr><td class="paramname">accessTarget</td><td>defaults to global_buffer, can accept global_buffer or constant_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgh</td><td>Reference to the command group scope where the accessor is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device accessor </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00686">686</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a15c9f3503947bf99ca0841e38d2ad288"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessTarget <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>cgh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00709">709</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3653bc6eb6ae97e72984d0043fbda45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;access::mode accessMode, access::target accessTarget = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, accessTarget&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>cgh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accessor to the buffer in the given command group scope. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accessMode</td><td>All <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450" title="Enum class for specifying the access mode for the accessor. ">access::mode</a> values are accepted </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Defaults to global_buffer, can accept global_buffer or constant_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgh</td><td>Reference to the command group scope where the accessor is requested </td></tr>
    <tr><td class="paramname">range</td><td>The range in which the accessor will be updating the data </td></tr>
    <tr><td class="paramname">offset</td><td>The offset that the accessor will be able to update from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device accessor </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00728">728</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e85ae6a1a5a157c17a9931401b1928c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a> <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00747">747</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a545e6a0a65cbd5599520bfed2c03bd5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;access::mode accessMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, <a class="el" href="classcl_1_1sycl_1_1buffer.html#abff07c34a6d34aa9129dbf515655de32">accessMode</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a> &gt;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accessor to the buffer, only used on the host side. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accessMode</td><td>All <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450" title="Enum class for specifying the access mode for the accessor. ">access::mode</a> values are accepted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range in which the accessor will be updating the data </td></tr>
    <tr><td class="paramname">offset</td><td>The offset that the accessor will be able to update from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Host accessor </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00760">760</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0ca0b5063b15e9550ecf0ed8b6c80cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AllocatorT <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator provided to the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Allocator that was provided to the buffer </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00808">808</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a367bed9217d257ee500bb840ad334509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;typename propertyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">propertyT <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_property </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the property of type propertyT that this SYCL buffer was constructed with. </p>
<p>Throws an error if buffer was not constructed with the property. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propertyT</td><td>Property to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the property </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00800">800</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3528a6bef326d9cde72a4927d3a9b1cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1range.html">cl::sycl::range</a>&lt;<a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::get_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the range of the buffer. </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00777">777</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a558e0ce5148250bb68c733bcb9a2ea50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;typename propertyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::has_property </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this SYCL buffer was constructed with the property specified by propertyT. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propertyT</td><td>Property to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if buffer constructed with the property </dd></dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00788">788</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a374df4b7bf6a1ecdd78ae95b45abc0fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;typename ReinterpretT , int ReinterpretDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt;ReinterpretT, ReinterpretDim, AllocatorT&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::reinterpret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; ReinterpretDim &gt;&#160;</td>
          <td class="paramname"><em>reinterpretRange</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a reinterpreted SYCL buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReinterpretT</td><td>New underlying type </td></tr>
    <tr><td class="paramname">ReinterpretDim</td><td>New buffer dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reinterpretRange</td><td>New buffer range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reinterpreted buffer with the requested parameters </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcl_1_1sycl_1_1invalid__object__error.html" title="Represents an error regarding any memory object being used by a kernel. ">invalid_object_error</a></td><td>if the size of the reinterpreted buffer and the size of the original buffer do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00821">821</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5377f65a05218d7abd4777e471da289c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<div class="memtemplate">
template&lt;typename ReinterpretT , int ReinterpretDim = dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt;ReinterpretT, ReinterpretDim, AllocatorT&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::reinterpret </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a reinterpreted SYCL buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReinterpretT</td><td>New underlying type </td></tr>
    <tr><td class="paramname">ReinterpretDim</td><td>New buffer dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reinterpreted buffer with the requested parameters </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcl_1_1sycl_1_1invalid__object__error.html" title="Represents an error regarding any memory object being used by a kernel. ">invalid_object_error</a></td><td>if the size of the reinterpreted buffer and the size of the original buffer do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00836">836</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abff07c34a6d34aa9129dbf515655de32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::accessMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00709">709</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a835a94da4bdc813299d6c4b5bff1e7c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::available_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00529">529</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff54d958126efdbfaf8ebe2faa50ab6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::dimensions = <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of buffer dimensions (Codeplay extension) </p>

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00346">346</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f03d30350af3e1a21ffcb7e7dc8b2e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, dims, AllocatorT &gt;::dims</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00709">709</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe778532470c9e9a220836abe344289e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int dims, typename AllocatorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a>&amp; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, <a class="el" href="classcl_1_1sycl_1_1buffer.html#a1f03d30350af3e1a21ffcb7e7dc8b2e2">dims</a>, AllocatorT &gt;::fromQueue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8h_source.html#l00528">528</a> of file <a class="el" href="buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="buffer_8h_source.html">buffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a></li>
    <li class="footer">Generated on Mon Sep 27 2021 12:13:48 for Codeplay ComputeCpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
