<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Codeplay ComputeCpp: cl::sycl::handler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Codeplay ComputeCpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcl_1_1sycl_1_1handler.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcl_1_1sycl_1_1handler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::handler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A handler gives user access to command group scope functionality, such as API calls.  
 <a href="classcl_1_1sycl_1_1handler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="apis_8h_source.html">apis.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad13964683fae164ccba5eff3eccb557d"><td class="memItemLeft" align="right" valign="top">COMPUTECPP_TEST_VIRTUAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad13964683fae164ccba5eff3eccb557d">~handler</a> ()</td></tr>
<tr class="memdesc:ad13964683fae164ccba5eff3eccb557d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the handler, implementation on the cpp file so the default_deleter can see the implementation of the internal transaction object.  <a href="#ad13964683fae164ccba5eff3eccb557d">More...</a><br /></td></tr>
<tr class="separator:ad13964683fae164ccba5eff3eccb557d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">set_arg</a> (int param_num, T &amp;&amp;param)</td></tr>
<tr class="memdesc:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an argument when using interop kernels.  <a href="#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">More...</a><br /></td></tr>
<tr class="separator:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfc0809b14b8953c842f6114e013e58"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7dfc0809b14b8953c842f6114e013e58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a7dfc0809b14b8953c842f6114e013e58">set_args</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7dfc0809b14b8953c842f6114e013e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the given kernel args arguments for an OpenCL kernel, as if <a class="el" href="classcl_1_1sycl_1_1handler.html#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8" title="Sets an argument when using interop kernels. ">set_arg()</a> was used with each of them in the same order and increasing index always starting at 0.  <a href="#a7dfc0809b14b8953c842f6114e013e58">More...</a><br /></td></tr>
<tr class="separator:a7dfc0809b14b8953c842f6114e013e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753a7db9214d40fb8d43ac6c8b6833e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a753a7db9214d40fb8d43ac6c8b6833e2">single_task</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a753a7db9214d40fb8d43ac6c8b6833e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution.  <a href="#a753a7db9214d40fb8d43ac6c8b6833e2">More...</a><br /></td></tr>
<tr class="separator:a753a7db9214d40fb8d43ac6c8b6833e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91585b4494de2792a5dce6bfcd416bf9"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </td></tr>
<tr class="memitem:a91585b4494de2792a5dce6bfcd416bf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a91585b4494de2792a5dce6bfcd416bf9">single_task</a> (const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a91585b4494de2792a5dce6bfcd416bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution.  <a href="#a91585b4494de2792a5dce6bfcd416bf9">More...</a><br /></td></tr>
<tr class="separator:a91585b4494de2792a5dce6bfcd416bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d716116114414cd509a93ccd8dda33"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </td></tr>
<tr class="memitem:a07d716116114414cd509a93ccd8dda33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a07d716116114414cd509a93ccd8dda33">single_task</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a07d716116114414cd509a93ccd8dda33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution.  <a href="#a07d716116114414cd509a93ccd8dda33">More...</a><br /></td></tr>
<tr class="separator:a07d716116114414cd509a93ccd8dda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547a65572de8083252b465ac1074dc43"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:a547a65572de8083252b465ac1074dc43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a547a65572de8083252b465ac1074dc43">parallel_for</a> (const <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;ndRange, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a547a65572de8083252b465ac1074dc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange.  <a href="#a547a65572de8083252b465ac1074dc43">More...</a><br /></td></tr>
<tr class="separator:a547a65572de8083252b465ac1074dc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccd2c8e4deeb2edf901710d711b256b"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:a4ccd2c8e4deeb2edf901710d711b256b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a4ccd2c8e4deeb2edf901710d711b256b">parallel_for</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a4ccd2c8e4deeb2edf901710d711b256b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a4ccd2c8e4deeb2edf901710d711b256b">More...</a><br /></td></tr>
<tr class="separator:a4ccd2c8e4deeb2edf901710d711b256b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a4579e9fef96e51ab64ac1e5d9dc4d9b7">parallel_for</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; offset, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a4579e9fef96e51ab64ac1e5d9dc4d9b7">More...</a><br /></td></tr>
<tr class="separator:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69072e1239801448dadf86e1b8542fe"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ac69072e1239801448dadf86e1b8542fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac69072e1239801448dadf86e1b8542fe">parallel_for</a> (const <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;ndRange, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ac69072e1239801448dadf86e1b8542fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange.  <a href="#ac69072e1239801448dadf86e1b8542fe">More...</a><br /></td></tr>
<tr class="separator:ac69072e1239801448dadf86e1b8542fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae0e010b69b66eb87a78d0f0291e6f87a">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;ndRange, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange.  <a href="#ae0e010b69b66eb87a78d0f0291e6f87a">More...</a><br /></td></tr>
<tr class="separator:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0914ce8c9f19a41918ab711d838b9d07"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a0914ce8c9f19a41918ab711d838b9d07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a0914ce8c9f19a41918ab711d838b9d07">parallel_for</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a0914ce8c9f19a41918ab711d838b9d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a0914ce8c9f19a41918ab711d838b9d07">More...</a><br /></td></tr>
<tr class="separator:a0914ce8c9f19a41918ab711d838b9d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba5230da79a8c4e2fec90ed366c885"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </td></tr>
<tr class="memitem:a58ba5230da79a8c4e2fec90ed366c885"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a58ba5230da79a8c4e2fec90ed366c885">parallel_for</a> (const size_t <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a58ba5230da79a8c4e2fec90ed366c885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a58ba5230da79a8c4e2fec90ed366c885">More...</a><br /></td></tr>
<tr class="separator:a58ba5230da79a8c4e2fec90ed366c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec471f48e98c26efe4de1c80069a82ac"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:aec471f48e98c26efe4de1c80069a82ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aec471f48e98c26efe4de1c80069a82ac">parallel_for</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp;offset, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:aec471f48e98c26efe4de1c80069a82ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#aec471f48e98c26efe4de1c80069a82ac">More...</a><br /></td></tr>
<tr class="separator:aec471f48e98c26efe4de1c80069a82ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad026053d5411280844d6d8664abe9268"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ad026053d5411280844d6d8664abe9268"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad026053d5411280844d6d8664abe9268">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ad026053d5411280844d6d8664abe9268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#ad026053d5411280844d6d8664abe9268">More...</a><br /></td></tr>
<tr class="separator:ad026053d5411280844d6d8664abe9268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4304deb0235543437d2026a9c4451929"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a4304deb0235543437d2026a9c4451929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a4304deb0235543437d2026a9c4451929">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp;offset, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a4304deb0235543437d2026a9c4451929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a4304deb0235543437d2026a9c4451929">More...</a><br /></td></tr>
<tr class="separator:a4304deb0235543437d2026a9c4451929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77f0bc273b16ca90baeca132ffe2538"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:ab77f0bc273b16ca90baeca132ffe2538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ab77f0bc273b16ca90baeca132ffe2538">parallel_for_work_group</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;numGroups, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:ab77f0bc273b16ca90baeca132ffe2538"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups.  <a href="#ab77f0bc273b16ca90baeca132ffe2538">More...</a><br /></td></tr>
<tr class="separator:ab77f0bc273b16ca90baeca132ffe2538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635eddb1e72722967c0a40b2f723b3d2"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a635eddb1e72722967c0a40b2f723b3d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a635eddb1e72722967c0a40b2f723b3d2">parallel_for_work_group</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a635eddb1e72722967c0a40b2f723b3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a635eddb1e72722967c0a40b2f723b3d2">More...</a><br /></td></tr>
<tr class="separator:a635eddb1e72722967c0a40b2f723b3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ab7af811ef14f9e15c957f3abbfb8dc44">parallel_for_work_group</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for_work_group will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>.  <a href="#ab7af811ef14f9e15c957f3abbfb8dc44">More...</a><br /></td></tr>
<tr class="separator:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5c5be38037f90b4d00c93ad32874d7"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a8a5c5be38037f90b4d00c93ad32874d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a8a5c5be38037f90b4d00c93ad32874d7">parallel_for_work_group</a> (const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;numGroups, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;groupSize, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a8a5c5be38037f90b4d00c93ad32874d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize.  <a href="#a8a5c5be38037f90b4d00c93ad32874d7">More...</a><br /></td></tr>
<tr class="separator:a8a5c5be38037f90b4d00c93ad32874d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c4e92995e59422df1e2c8447bdba4f"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a59c4e92995e59422df1e2c8447bdba4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a59c4e92995e59422df1e2c8447bdba4f">parallel_for_work_group</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;numGroups, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;groupSize, const functorT &amp;<a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a59c4e92995e59422df1e2c8447bdba4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize.  <a href="#a59c4e92995e59422df1e2c8447bdba4f">More...</a><br /></td></tr>
<tr class="separator:a59c4e92995e59422df1e2c8447bdba4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c912d6178b4f7a9e627d6b7a519d1d9"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget&gt; </td></tr>
<tr class="memitem:a2c912d6178b4f7a9e627d6b7a519d1d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9">require</a> (const <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="el" href="namespacecl_1_1sycl.html#a0b53769ff68f9a0afeb5c5f2342dcff4">kTarget</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a> &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a2c912d6178b4f7a9e627d6b7a519d1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that registers a placeholder accessor with the handler.  <a href="#a2c912d6178b4f7a9e627d6b7a519d1d9">More...</a><br /></td></tr>
<tr class="separator:a2c912d6178b4f7a9e627d6b7a519d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a5868d87238f4f7dff34d0ba108400"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::mode kMode, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:ac2a5868d87238f4f7dff34d0ba108400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac2a5868d87238f4f7dff34d0ba108400">register_for_dma</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7acb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a>, isPlaceholder &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, size_t stride)</td></tr>
<tr class="memdesc:ac2a5868d87238f4f7dff34d0ba108400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a global memory accessor for DMA transfer.  <a href="#ac2a5868d87238f4f7dff34d0ba108400">More...</a><br /></td></tr>
<tr class="separator:ac2a5868d87238f4f7dff34d0ba108400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aa2a6c7d8ae30ec56d014fe79700f8"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:ae0aa2a6c7d8ae30ec56d014fe79700f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae0aa2a6c7d8ae30ec56d014fe79700f8">register_for_dma</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450aecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7acb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a>, isPlaceholder &gt; &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, size_t stride)</td></tr>
<tr class="memdesc:ae0aa2a6c7d8ae30ec56d014fe79700f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a constant memory accessor for DMA transfer.  <a href="#ae0aa2a6c7d8ae30ec56d014fe79700f8">More...</a><br /></td></tr>
<tr class="separator:ae0aa2a6c7d8ae30ec56d014fe79700f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7687f385467b6f51eac0a53f3da2d3d1"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget&gt; </td></tr>
<tr class="memitem:a7687f385467b6f51eac0a53f3da2d3d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a7687f385467b6f51eac0a53f3da2d3d1">COMPUTECPP_DEPRECATED_API</a> (&quot;Deprecated Codeplay extension function: &quot;&quot;Bind the null <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a> first, then call <a class="el" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9">require</a>()&quot;) void <a class="el" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9">require</a>(<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; elemT</td></tr>
<tr class="memdesc:a7687f385467b6f51eac0a53f3da2d3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that registers a placeholder accessor with the handler and the associated storage.  <a href="#a7687f385467b6f51eac0a53f3da2d3d1">More...</a><br /></td></tr>
<tr class="separator:a7687f385467b6f51eac0a53f3da2d3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabced7254343b7da6d249db0e31f8954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aabced7254343b7da6d249db0e31f8954">experimental_depends_on</a> (<a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a> e)</td></tr>
<tr class="memdesc:aabced7254343b7da6d249db0e31f8954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a single event that this handler should wait for before running.  <a href="#aabced7254343b7da6d249db0e31f8954">More...</a><br /></td></tr>
<tr class="separator:aabced7254343b7da6d249db0e31f8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614cb2116ec4e92ca77d9b69b7a2f8ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a614cb2116ec4e92ca77d9b69b7a2f8ef">experimental_depends_on</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a614cb2116ec4e92ca77d9b69b7a2f8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of events that this handler should wait for before running.  <a href="#a614cb2116ec4e92ca77d9b69b7a2f8ef">More...</a><br /></td></tr>
<tr class="separator:a614cb2116ec4e92ca77d9b69b7a2f8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174a643a561ee432d5d41c691c8a716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a6174a643a561ee432d5d41c691c8a716">depends_on</a> (<a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a> e)</td></tr>
<tr class="memdesc:a6174a643a561ee432d5d41c691c8a716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a single event that this handler should wait for before running.  <a href="#a6174a643a561ee432d5d41c691c8a716">More...</a><br /></td></tr>
<tr class="separator:a6174a643a561ee432d5d41c691c8a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c99bd3bc5b5e9764979695bb45c967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a10c99bd3bc5b5e9764979695bb45c967">depends_on</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a10c99bd3bc5b5e9764979695bb45c967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of events that this handler should wait for before running.  <a href="#a10c99bd3bc5b5e9764979695bb45c967">More...</a><br /></td></tr>
<tr class="separator:a10c99bd3bc5b5e9764979695bb45c967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6357dc65b57f9b2909dd119b245477"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp;detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:a8f6357dc65b57f9b2909dd119b245477"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a8f6357dc65b57f9b2909dd119b245477">copy</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, <a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt; hostPtr)</td></tr>
<tr class="memdesc:a8f6357dc65b57f9b2909dd119b245477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from the device accessor to the host pointer.  <a href="#a8f6357dc65b57f9b2909dd119b245477">More...</a><br /></td></tr>
<tr class="separator:a8f6357dc65b57f9b2909dd119b245477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe461fb62b7d40ca1aa56c72eecb7746"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp;detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:afe461fb62b7d40ca1aa56c72eecb7746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#afe461fb62b7d40ca1aa56c72eecb7746">copy</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt; hostPtr, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:afe461fb62b7d40ca1aa56c72eecb7746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from the host pointer to the device accessor.  <a href="#afe461fb62b7d40ca1aa56c72eecb7746">More...</a><br /></td></tr>
<tr class="separator:afe461fb62b7d40ca1aa56c72eecb7746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f2fcef342337b5d5c84ae903cf062f"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp;detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:ac7f2fcef342337b5d5c84ae903cf062f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac7f2fcef342337b5d5c84ae903cf062f">copy</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, THostPtr *hostPtr)</td></tr>
<tr class="memdesc:ac7f2fcef342337b5d5c84ae903cf062f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from the device accessor to the host pointer.  <a href="#ac7f2fcef342337b5d5c84ae903cf062f">More...</a><br /></td></tr>
<tr class="separator:ac7f2fcef342337b5d5c84ae903cf062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp;detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a0ec69c38f3c4cd77095c62adff0dc4b7">copy</a> (const THostPtr *hostPtr, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from the host pointer to the device accessor.  <a href="#a0ec69c38f3c4cd77095c62adff0dc4b7">More...</a><br /></td></tr>
<tr class="separator:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50777df7564aa98bc62b1432416b4c3f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int dimsOrig, int dimsDest, access::mode accModeOrig, access::mode accModeDest, access::target accTargetOrig, access::target accTargetDest, access::placeholder isPlaceholderOrig, access::placeholder isPlaceholderDest, COMPUTECPP_ENABLE_IF(T,((detail::can_copy_types&lt; T, U &gt;::value)&amp;&amp;(detail::is_read_mode&lt; accModeOrig &gt;::value)&amp;&amp;(detail::is_write_mode&lt; accModeDest &gt;::value))) &gt; </td></tr>
<tr class="memitem:a50777df7564aa98bc62b1432416b4c3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a50777df7564aa98bc62b1432416b4c3f">copy</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dimsOrig, accModeOrig, accTargetOrig, isPlaceholderOrig &gt; originAcc, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; U, dimsDest, accModeDest, accTargetDest, isPlaceholderDest &gt; destinationAcc)</td></tr>
<tr class="memdesc:a50777df7564aa98bc62b1432416b4c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data associated with the origin accessor to the data associated with the destination accessor.  <a href="#a50777df7564aa98bc62b1432416b4c3f">More...</a><br /></td></tr>
<tr class="separator:a50777df7564aa98bc62b1432416b4c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad360f52d93770802e350f10754f7ed6d"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename T , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; T, TAcc &gt;::value &amp;&amp;detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:ad360f52d93770802e350f10754f7ed6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad360f52d93770802e350f10754f7ed6d">fill</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, T val)</td></tr>
<tr class="memdesc:ad360f52d93770802e350f10754f7ed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the data associated with the accessor using the scalar value.  <a href="#ad360f52d93770802e350f10754f7ed6d">More...</a><br /></td></tr>
<tr class="separator:ad360f52d93770802e350f10754f7ed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7095e10bde4deca0f823ce471b734c42"><td class="memTemplParams" colspan="2">template&lt;typename T , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:a7095e10bde4deca0f823ce471b734c42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a7095e10bde4deca0f823ce471b734c42">update_host</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a7095e10bde4deca0f823ce471b734c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the device data with the current host accessor.  <a href="#a7095e10bde4deca0f823ce471b734c42">More...</a><br /></td></tr>
<tr class="separator:a7095e10bde4deca0f823ce471b734c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f34754b90172152e6e68a8b76c0446"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96f34754b90172152e6e68a8b76c0446"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a96f34754b90172152e6e68a8b76c0446">fill</a> (void *ptr, const T &amp;pattern, size_t count)</td></tr>
<tr class="memdesc:a96f34754b90172152e6e68a8b76c0446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by <code>ptr</code>.  <a href="#a96f34754b90172152e6e68a8b76c0446">More...</a><br /></td></tr>
<tr class="separator:a96f34754b90172152e6e68a8b76c0446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2bc1950d746b68e457cc63c2998055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#adc2bc1950d746b68e457cc63c2998055">memcpy</a> (void *dest, const void *src, size_t size)</td></tr>
<tr class="memdesc:adc2bc1950d746b68e457cc63c2998055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>count</code> bytes from <code>src</code> to .  <a href="#adc2bc1950d746b68e457cc63c2998055">More...</a><br /></td></tr>
<tr class="separator:adc2bc1950d746b68e457cc63c2998055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61a453802ed627abe983fcd7b9024fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af61a453802ed627abe983fcd7b9024fd">experimental_prefetch</a> (const void *ptr, size_t size)</td></tr>
<tr class="memdesc:af61a453802ed627abe983fcd7b9024fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hints to the SYCL runtime that the data is available earlier than when the USM model would require it.  <a href="#af61a453802ed627abe983fcd7b9024fd">More...</a><br /></td></tr>
<tr class="separator:af61a453802ed627abe983fcd7b9024fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a4a6023c01cb90f7f1357c8b66000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad67a4a6023c01cb90f7f1357c8b66000">prefetch</a> (const void *ptr, size_t size)</td></tr>
<tr class="memdesc:ad67a4a6023c01cb90f7f1357c8b66000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hints to the SYCL runtime that the data is available earlier than when the USM model would require it.  <a href="#ad67a4a6023c01cb90f7f1357c8b66000">More...</a><br /></td></tr>
<tr class="separator:ad67a4a6023c01cb90f7f1357c8b66000"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab4bdf5d8c1017daf847d2113c11242f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ab4bdf5d8c1017daf847d2113c11242f3">bufObj</a></td></tr>
<tr class="separator:ab4bdf5d8c1017daf847d2113c11242f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaa7a26269cdb5e27ea8f221462580e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a> const <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="el" href="namespacecl_1_1sycl.html#a0b53769ff68f9a0afeb5c5f2342dcff4">kTarget</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a></td></tr>
<tr class="separator:aacaa7a26269cdb5e27ea8f221462580e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af5e3ae7393de2d7c830d48170ee0c989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af5e3ae7393de2d7c830d48170ee0c989">update_device_data</a> (const accessor_base &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, <a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; hostPtr, <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">cl::sycl::access::mode</a> accessMode, bool userProvidedPtr)</td></tr>
<tr class="memdesc:af5e3ae7393de2d7c830d48170ee0c989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates device data by copying to/from the device.  <a href="#af5e3ae7393de2d7c830d48170ee0c989">More...</a><br /></td></tr>
<tr class="separator:af5e3ae7393de2d7c830d48170ee0c989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa01f0e8ea455cbaa5517dd1e9a33b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a6aa01f0e8ea455cbaa5517dd1e9a33b8">copy_in_device</a> (const accessor_base &amp;originAcc, const accessor_base &amp;destinationAcc)</td></tr>
<tr class="memdesc:a6aa01f0e8ea455cbaa5517dd1e9a33b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data associated with the origin accessor to the data associated with the destination accessor.  <a href="#a6aa01f0e8ea455cbaa5517dd1e9a33b8">More...</a><br /></td></tr>
<tr class="separator:a6aa01f0e8ea455cbaa5517dd1e9a33b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d7565b85886156bf0a9e2b775472fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae6d7565b85886156bf0a9e2b775472fb">fill</a> (const accessor_base &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, const void *patternData, const size_t patternSize)</td></tr>
<tr class="memdesc:ae6d7565b85886156bf0a9e2b775472fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range of the accessor with value of hostScalarPtr[0]}.  <a href="#ae6d7565b85886156bf0a9e2b775472fb">More...</a><br /></td></tr>
<tr class="separator:ae6d7565b85886156bf0a9e2b775472fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3387bd5b8faaba3ed169d9fb45b8952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af3387bd5b8faaba3ed169d9fb45b8952">fill</a> (void *ptr, const void *patternData, size_t patternSize, size_t size)</td></tr>
<tr class="memdesc:af3387bd5b8faaba3ed169d9fb45b8952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by <code>ptr</code>.  <a href="#af3387bd5b8faaba3ed169d9fb45b8952">More...</a><br /></td></tr>
<tr class="separator:af3387bd5b8faaba3ed169d9fb45b8952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d31acb51ab89306691a73d9c188b21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a2d31acb51ab89306691a73d9c188b21c">interop_task_impl</a> (const detail::interop_task_ptr &amp;hostTaskCallable)</td></tr>
<tr class="memdesc:a2d31acb51ab89306691a73d9c188b21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a host task with an interop_handle object.  <a href="#a2d31acb51ab89306691a73d9c188b21c">More...</a><br /></td></tr>
<tr class="separator:a2d31acb51ab89306691a73d9c188b21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f11cc2e4d07fdcd46f39263c86dc3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af6f11cc2e4d07fdcd46f39263c86dc3a">handler</a> (const dqueue_shptr &amp;q, const dqueue_shptr &amp;fallbackQueue=nullptr)</td></tr>
<tr class="memdesc:af6f11cc2e4d07fdcd46f39263c86dc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a handler for an specific queue.  <a href="#af6f11cc2e4d07fdcd46f39263c86dc3a">More...</a><br /></td></tr>
<tr class="separator:af6f11cc2e4d07fdcd46f39263c86dc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e33e8d5fe3d09cb629330744d0840e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1context.html">context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a52e33e8d5fe3d09cb629330744d0840e">get_context</a> () const </td></tr>
<tr class="memdesc:a52e33e8d5fe3d09cb629330744d0840e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current context for the command group.  <a href="#a52e33e8d5fe3d09cb629330744d0840e">More...</a><br /></td></tr>
<tr class="separator:a52e33e8d5fe3d09cb629330744d0840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6af1f8883ca42b9d4f376fac5f5f4d"><td class="memItemLeft" align="right" valign="top">ddevice_wkptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aaa6af1f8883ca42b9d4f376fac5f5f4d">get_device_weak</a> () const </td></tr>
<tr class="memdesc:aaa6af1f8883ca42b9d4f376fac5f5f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current device for the command group.  <a href="#aaa6af1f8883ca42b9d4f376fac5f5f4d">More...</a><br /></td></tr>
<tr class="separator:aaa6af1f8883ca42b9d4f376fac5f5f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bf60ec03546b51fe5e7c7dc60c57ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a37bf60ec03546b51fe5e7c7dc60c57ab">execute_kernel_single_task_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::single_task_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand)</td></tr>
<tr class="memdesc:a37bf60ec03546b51fe5e7c7dc60c57ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the internal structures to execute the kernel.  <a href="#a37bf60ec03546b51fe5e7c7dc60c57ab">More...</a><br /></td></tr>
<tr class="separator:a37bf60ec03546b51fe5e7c7dc60c57ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4624999c921f57cde7c599752cddc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad4624999c921f57cde7c599752cddc69">execute_kernel_parallel_for_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::parallel_for_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand, int dimensions)</td></tr>
<tr class="separator:ad4624999c921f57cde7c599752cddc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a007e26d5c1b02d185e98e8df8b205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af0a007e26d5c1b02d185e98e8df8b205">execute_kernel_parallel_for_id_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::parallel_for_id_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand, int dimensions)</td></tr>
<tr class="separator:af0a007e26d5c1b02d185e98e8df8b205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6603f931613f0d1f07bce1e11082786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af6603f931613f0d1f07bce1e11082786">execute_kernel_parallel_for_work_group_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::parallel_for_work_group_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand, int dimensions)</td></tr>
<tr class="separator:af6603f931613f0d1f07bce1e11082786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1595e93690c230e23da413f3d999ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a6b1595e93690c230e23da413f3d999ba">process_functor_arguments_impl</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, detail::binary_address functorBuffer, const detail::functor_arg_descriptor &amp;argDesc, detail::enqueue_device_kernel_command *currentCommand)</td></tr>
<tr class="memdesc:a6b1595e93690c230e23da413f3d999ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parameters from a functor and sets them as OpenCL arguments.  <a href="#a6b1595e93690c230e23da413f3d999ba">More...</a><br /></td></tr>
<tr class="separator:a6b1595e93690c230e23da413f3d999ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79909103961de6237c32643e43f57d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a79909103961de6237c32643e43f57d13">require</a> (const accessor_base &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a79909103961de6237c32643e43f57d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that registers a placeholder accessor with the handler.  <a href="#a79909103961de6237c32643e43f57d13">More...</a><br /></td></tr>
<tr class="separator:a79909103961de6237c32643e43f57d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481be0c41842998c3593da40ef349df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a481be0c41842998c3593da40ef349df3">require</a> (const accessor_base &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, dmem_shptr memObj, <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">access::mode</a> mode, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7">access::target</a> target)</td></tr>
<tr class="memdesc:a481be0c41842998c3593da40ef349df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that registers a placeholder accessor with the handler.  <a href="#a481be0c41842998c3593da40ef349df3">More...</a><br /></td></tr>
<tr class="separator:a481be0c41842998c3593da40ef349df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3358a20e49c3510e7ec3b4e8728f483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac3358a20e49c3510e7ec3b4e8728f483">register_for_dma</a> (accessor_base &amp;<a class="el" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, size_t strideBytes)</td></tr>
<tr class="memdesc:ac3358a20e49c3510e7ec3b4e8728f483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an accessor for DMA transfer.  <a href="#ac3358a20e49c3510e7ec3b4e8728f483">More...</a><br /></td></tr>
<tr class="separator:ac3358a20e49c3510e7ec3b4e8728f483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d6db9cc631ff57564bc590a817804"><td class="memItemLeft" align="right" valign="top">detail::enqueue_device_kernel_command *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a352d6db9cc631ff57564bc590a817804">create_kernel_command_group</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel)</td></tr>
<tr class="memdesc:a352d6db9cc631ff57564bc590a817804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a kernel command group Internal implementation.  <a href="#a352d6db9cc631ff57564bc590a817804">More...</a><br /></td></tr>
<tr class="separator:a352d6db9cc631ff57564bc590a817804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fc701fbd276e05ed83e48883542119"><td class="memItemLeft" align="right" valign="top">detail::index_array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a51fc701fbd276e05ed83e48883542119">get_optimal_workgroup_size</a> (const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel)</td></tr>
<tr class="memdesc:a51fc701fbd276e05ed83e48883542119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the optimal workgroup size for the current device and the given kernel.  <a href="#a51fc701fbd276e05ed83e48883542119">More...</a><br /></td></tr>
<tr class="separator:a51fc701fbd276e05ed83e48883542119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a65cd7a5b02ea526bb946eff87188afa1"><td class="memItemLeft" align="right" valign="top">dtrans_uptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a65cd7a5b02ea526bb946eff87188afa1">m_trans</a></td></tr>
<tr class="memdesc:a65cd7a5b02ea526bb946eff87188afa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal transaction associated with the handler.  <a href="#a65cd7a5b02ea526bb946eff87188afa1">More...</a><br /></td></tr>
<tr class="separator:a65cd7a5b02ea526bb946eff87188afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53746faca0e6189185ff0218bbda5f22"><td class="memItemLeft" align="right" valign="top">dqueue_shptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a53746faca0e6189185ff0218bbda5f22">m_queue</a></td></tr>
<tr class="memdesc:a53746faca0e6189185ff0218bbda5f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue to which this handler was submitted to.  <a href="#a53746faca0e6189185ff0218bbda5f22">More...</a><br /></td></tr>
<tr class="separator:a53746faca0e6189185ff0218bbda5f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ae9b682242271c828237b136d2646"><td class="memItemLeft" align="right" valign="top">dqueue_shptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aca8ae9b682242271c828237b136d2646">m_fallbackQueue</a></td></tr>
<tr class="memdesc:aca8ae9b682242271c828237b136d2646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the fallback queue (if any)  <a href="#aca8ae9b682242271c828237b136d2646">More...</a><br /></td></tr>
<tr class="separator:aca8ae9b682242271c828237b136d2646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6d146a3f005c5a27e653a5dab16550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl.html#a0a3b58674c77d248758b6bee05800ac5">vector_class</a>&lt; add_param_func_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a3d6d146a3f005c5a27e653a5dab16550">m_paramVec</a></td></tr>
<tr class="separator:a3d6d146a3f005c5a27e653a5dab16550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bffc7ce382906014d6cfaafb7c75e9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac7bffc7ce382906014d6cfaafb7c75e9">m_numKernels</a></td></tr>
<tr class="memdesc:ac7bffc7ce382906014d6cfaafb7c75e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of kernels in the command group.  <a href="#ac7bffc7ce382906014d6cfaafb7c75e9">More...</a><br /></td></tr>
<tr class="separator:ac7bffc7ce382906014d6cfaafb7c75e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A handler gives user access to command group scope functionality, such as API calls. </p>
<p>This simplifies the interface, as the command group class is not required anymore and the scope is explicit for accessors and API entries.</p>
<p>It is also used by accessors to get the current command group scope. Handlers can only be constructed from within queues. For the time being, the deprecated command group function also can create handlers.</p>
<p>The templated-side of the API entries is defined here. Some API entries are explicitly deleted to shield users from weird template errors caused by enable_if macros. In particular, if there is a pointer to a kernel instead of a kernel, the template deduction fails and causes a massive template error. However, using the deleted API entry the user sees an explicit error because they are using a non-valid interface. </p>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00122">122</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad13964683fae164ccba5eff3eccb557d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">COMPUTECPP_TEST_VIRTUAL cl::sycl::handler::~handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor of the handler, implementation on the cpp file so the default_deleter can see the implementation of the internal transaction object. </p>

</div>
</div>
<a class="anchor" id="af6f11cc2e4d07fdcd46f39263c86dc3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::handler::handler </td>
          <td>(</td>
          <td class="paramtype">const dqueue_shptr &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dqueue_shptr &amp;&#160;</td>
          <td class="paramname"><em>fallbackQueue</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a handler for an specific queue. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7687f385467b6f51eac0a53f3da2d3d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::handler::COMPUTECPP_DEPRECATED_API </td>
          <td>(</td>
          <td class="paramtype">&quot;Deprecated Codeplay extension function: &quot;&quot;Bind the null <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">then call <a class="el" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9">require</a>()&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that registers a placeholder accessor with the handler and the associated storage. </p>
<p>Defined in Codeplay Extension CP004. Will fail if accessor already associated with storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer object </td></tr>
    <tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Bind the null accessor first, then call <a class="el" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9" title="Function that registers a placeholder accessor with the handler. ">require()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f6357dc65b57f9b2909dd119b245477"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp;detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt;&#160;</td>
          <td class="paramname"><em>hostPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from the device accessor to the host pointer. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the accessor and the host pointer must match</p><ul>
<li>Accessor type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
    <tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
    <tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes read access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
    <tr><td class="paramname">hostPtr</td><td>Host pointer that will be updated </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01027">1027</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe461fb62b7d40ca1aa56c72eecb7746"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp;detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt;&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from the host pointer to the device accessor. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the host pointer and the accessor must match</p><ul>
<li>Host pointer type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
    <tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
    <tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes write access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Host pointer that points to the new data </td></tr>
    <tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01060">1060</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f2fcef342337b5d5c84ae903cf062f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp;detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THostPtr *&#160;</td>
          <td class="paramname"><em>hostPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from the device accessor to the host pointer. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the accessor and the host pointer must match</p><ul>
<li>Accessor type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
    <tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
    <tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes read access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
    <tr><td class="paramname">hostPtr</td><td>Host pointer that will be updated </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01095">1095</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ec69c38f3c4cd77095c62adff0dc4b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp;detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const THostPtr *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from the host pointer to the device accessor. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the host pointer and the accessor must match</p><ul>
<li>Host pointer type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
    <tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
    <tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes write access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Host pointer that points to the new data </td></tr>
    <tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01129">1129</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a50777df7564aa98bc62b1432416b4c3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int dimsOrig, int dimsDest, access::mode accModeOrig, access::mode accModeDest, access::target accTargetOrig, access::target accTargetDest, access::placeholder isPlaceholderOrig, access::placeholder isPlaceholderDest, COMPUTECPP_ENABLE_IF(T,((detail::can_copy_types&lt; T, U &gt;::value)&amp;&amp;(detail::is_read_mode&lt; accModeOrig &gt;::value)&amp;&amp;(detail::is_write_mode&lt; accModeDest &gt;::value))) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dimsOrig, accModeOrig, accTargetOrig, isPlaceholderOrig &gt;&#160;</td>
          <td class="paramname"><em>originAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; U, dimsDest, accModeDest, accTargetDest, isPlaceholderDest &gt;&#160;</td>
          <td class="paramname"><em>destinationAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data associated with the origin accessor to the data associated with the destination accessor. </p>
<p>There are a few restrictions on the accessors:</p><ul>
<li>The underlying type and number of dimensions must match<ul>
<li>Origin type can be const</li>
</ul>
</li>
<li>The origin accessor access mode must include read access</li>
<li>The destination accessor access mode must include write access</li>
<li>The size of the destination accessor data must be enough to hold the data from the origin accessor <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Underlying type of the data associated with the origin accessor </td></tr>
    <tr><td class="paramname">U</td><td>Underlying type of the data associated with the destination accessors </td></tr>
    <tr><td class="paramname">dimsOrig</td><td>Number of dimensions of the origin accessor </td></tr>
    <tr><td class="paramname">dimsDest</td><td>Number of dimensions of the destination accessor </td></tr>
    <tr><td class="paramname">accModeOrig</td><td>Access mode of the origin accessor </td></tr>
    <tr><td class="paramname">accModeDest</td><td>Access mode of the destination accessor </td></tr>
    <tr><td class="paramname">accTargetOrig</td><td>Access target of the origin accessor </td></tr>
    <tr><td class="paramname">accTargetDest</td><td>Access target of the destination accessor </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the origin accessor is a placeholder </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the destination accessor is a placeholder </td></tr>
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Checks that the accessor types conform to the restrictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originAcc</td><td>Accessor with the data that will be copied from </td></tr>
    <tr><td class="paramname">destinationAcc</td><td>Accessor with the data that will be copied to </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01175">1175</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6aa01f0e8ea455cbaa5517dd1e9a33b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy_in_device </td>
          <td>(</td>
          <td class="paramtype">const accessor_base &amp;&#160;</td>
          <td class="paramname"><em>originAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const accessor_base &amp;&#160;</td>
          <td class="paramname"><em>destinationAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data associated with the origin accessor to the data associated with the destination accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originAcc</td><td>Accessor with the data that will be copied from </td></tr>
    <tr><td class="paramname">destinationAcc</td><td>Accessor with the data that will be copied to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a352d6db9cc631ff57564bc590a817804"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::enqueue_device_kernel_command* cl::sycl::handler::create_kernel_command_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>syclKernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a kernel command group Internal implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created command </dd></dl>

</div>
</div>
<a class="anchor" id="a6174a643a561ee432d5d41c691c8a716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::depends_on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a single event that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The event that the handler should wait for before running. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00990">990</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a10c99bd3bc5b5e9764979695bb45c967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::depends_on </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a set of events that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of events. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00995">995</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="af0a007e26d5c1b02d185e98e8df8b205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::execute_kernel_parallel_for_id_ptr </td>
          <td>(</td>
          <td class="paramtype">const detail::nd_range_base &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::parallel_for_id_ptr &amp;&#160;</td>
          <td class="paramname"><em>funcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::enqueue_device_kernel_command *&#160;</td>
          <td class="paramname"><em>currentCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4624999c921f57cde7c599752cddc69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::execute_kernel_parallel_for_ptr </td>
          <td>(</td>
          <td class="paramtype">const detail::nd_range_base &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::parallel_for_ptr &amp;&#160;</td>
          <td class="paramname"><em>funcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::enqueue_device_kernel_command *&#160;</td>
          <td class="paramname"><em>currentCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6603f931613f0d1f07bce1e11082786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::execute_kernel_parallel_for_work_group_ptr </td>
          <td>(</td>
          <td class="paramtype">const detail::nd_range_base &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::parallel_for_work_group_ptr &amp;&#160;</td>
          <td class="paramname"><em>funcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::enqueue_device_kernel_command *&#160;</td>
          <td class="paramname"><em>currentCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37bf60ec03546b51fe5e7c7dc60c57ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::execute_kernel_single_task_ptr </td>
          <td>(</td>
          <td class="paramtype">const detail::nd_range_base &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::single_task_ptr &amp;&#160;</td>
          <td class="paramname"><em>funcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::enqueue_device_kernel_command *&#160;</td>
          <td class="paramname"><em>currentCommand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the internal structures to execute the kernel. </p>
<p>This function is explicitly instantiated on the cpp file for those FunctorPtr types supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nd_range_base</td><td>The given nd range </td></tr>
    <tr><td class="paramname">syclKernel</td><td>The SYCL device kernel </td></tr>
    <tr><td class="paramname">FunctorPtr</td><td>The std::function pointer to the user functor </td></tr>
    <tr><td class="paramname">currentCommand</td><td>The command currently being executing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabced7254343b7da6d249db0e31f8954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::experimental_depends_on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a single event that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The event that the handler should wait for before running. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a614cb2116ec4e92ca77d9b69b7a2f8ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::experimental_depends_on </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of events that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af61a453802ed627abe983fcd7b9024fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::experimental_prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hints to the SYCL runtime that the data is available earlier than when the USM model would require it. </p>
<p>Can only be overlapped with kernel execution when Concurrent or System USM is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the memory to be prefetched to the device </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes requested to be prefetched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad360f52d93770802e350f10754f7ed6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename T , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; T, TAcc &gt;::value &amp;&amp;detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the data associated with the accessor using the scalar value. </p>
<p>Special case of copy from host to device where the origin is a scalar value that will be replicated across the range of the accessor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
    <tr><td class="paramname">T</td><td>Underlying type of the host scalar </td></tr>
    <tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
    <tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
    <tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes read access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor with the data that will be filled </td></tr>
    <tr><td class="paramname">val</td><td>Scalar used to fill the device data with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01203">1203</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a96f34754b90172152e6e68a8b76c0446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the memory pointed by <code>ptr</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer object to fill. </td></tr>
    <tr><td class="paramname">pattern</td><td>The pattern to fill each element of <code>ptr</code> </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements of type T to fill. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01232">1232</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae6d7565b85886156bf0a9e2b775472fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::fill </td>
          <td>(</td>
          <td class="paramtype">const accessor_base &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>patternData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>patternSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the range of the accessor with value of hostScalarPtr[0]}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor with the data that will be filled </td></tr>
    <tr><td class="paramname">patternData</td><td>Host data used to fill the device data with </td></tr>
    <tr><td class="paramname">patternSize</td><td>Size of the host data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3387bd5b8faaba3ed169d9fb45b8952"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>patternData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>patternSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the memory pointed by <code>ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer object to fill. </td></tr>
    <tr><td class="paramname">patternData</td><td>Pointer to the memory that contains the pattern to use when filling <code>ptr</code>. </td></tr>
    <tr><td class="paramname">patternSize</td><td>The size in bytes of the pattern. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes of <code>ptr</code> to fill with <code>patternData</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52e33e8d5fe3d09cb629330744d0840e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1context.html">context</a> cl::sycl::handler::get_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current context for the command group. </p>

</div>
</div>
<a class="anchor" id="aaa6af1f8883ca42b9d4f376fac5f5f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ddevice_wkptr cl::sycl::handler::get_device_weak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current device for the command group. </p>

</div>
</div>
<a class="anchor" id="a51fc701fbd276e05ed83e48883542119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::index_array cl::sycl::handler::get_optimal_workgroup_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>syclKernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the optimal workgroup size for the current device and the given kernel. </p>
<p>Internal implementation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>Kernel to which we need to compute the workgroup size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d31acb51ab89306691a73d9c188b21c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::interop_task_impl </td>
          <td>(</td>
          <td class="paramtype">const detail::interop_task_ptr &amp;&#160;</td>
          <td class="paramname"><em>hostTaskCallable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules a host task with an interop_handle object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostTaskCallable</td><td>Callable object that will be executed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc2bc1950d746b68e457cc63c2998055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>count</code> bytes from <code>src</code> to . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the memory location to copy to. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the memory location to copy from. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a547a65572de8083252b465ac1074dc43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndRange</td><td>Dimensions of the global and local work groups </td></tr>
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00372">372</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4ccd2c8e4deeb2edf901710d711b256b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00387">387</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4579e9fef96e51ab64ac1e5d9dc4d9b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the data being executed </td></tr>
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00404">404</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac69072e1239801448dadf86e1b8542fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndRange</td><td>Dimensions of the global and local work groups </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00484">484</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0e010b69b66eb87a78d0f0291e6f87a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
    <tr><td class="paramname">ndRange</td><td>Dimensions of the global and local work groups </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00506">506</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0914ce8c9f19a41918ab711d838b9d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00613">613</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58ba5230da79a8c4e2fec90ed366c885"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Size of the global work group </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00631">631</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec471f48e98c26efe4de1c80069a82ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the data being executed </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00652">652</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad026053d5411280844d6d8664abe9268"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
    <tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00673">673</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4304deb0235543437d2026a9c4451929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
    <tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the data being executed </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00696">696</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab77f0bc273b16ca90baeca132ffe2538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>numGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroups</td><td>Dimensions of the global and local work groups </td></tr>
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00715">715</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a635eddb1e72722967c0a40b2f723b3d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
    <tr><td class="paramname">range</td><td>Dimensions of the global work groups </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00833">833</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7af811ef14f9e15c957f3abbfb8dc44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for_work_group will enqueue the kernel <a class="el" href="namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Dimensions of the global and local work groups </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00854">854</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a5c5be38037f90b4d00c93ad32874d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>numGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>groupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
    <tr><td class="paramname">numGroups</td><td>dimensions of the work groups being launched </td></tr>
    <tr><td class="paramname">groupSize</td><td>each work group will launch work-items of dimension of groupSize </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00877">877</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a59c4e92995e59422df1e2c8447bdba4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>numGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>groupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
    <tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
    <tr><td class="paramname">numGroups</td><td>dimensions of the work groups being launched </td></tr>
    <tr><td class="paramname">groupSize</td><td>each work group will launch work-items of dimension of groupSize </td></tr>
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00902">902</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad67a4a6023c01cb90f7f1357c8b66000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hints to the SYCL runtime that the data is available earlier than when the USM model would require it. </p>
<p>Can only be overlapped with kernel execution when Concurrent or System USM is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the memory to be prefetched to the device </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes requested to be prefetched </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01274">1274</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6b1595e93690c230e23da413f3d999ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::process_functor_arguments_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::binary_address&#160;</td>
          <td class="paramname"><em>functorBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::functor_arg_descriptor &amp;&#160;</td>
          <td class="paramname"><em>argDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::enqueue_device_kernel_command *&#160;</td>
          <td class="paramname"><em>currentCommand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parameters from a functor and sets them as OpenCL arguments. </p>
<p>Internal implementation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>Kernel to which the functor is associated </td></tr>
    <tr><td class="paramname">functorBuffer</td><td>Functor buffer casted down to a binary array </td></tr>
    <tr><td class="paramname">SI</td><td>Kernel struct iterator </td></tr>
    <tr><td class="paramname">SE</td><td>Kernel struct iterator </td></tr>
    <tr><td class="paramname">OI</td><td>Kernel struct iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2a5868d87238f4f7dff34d0ba108400"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::mode kMode, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::register_for_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7acb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a>, isPlaceholder &gt; &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a global memory accessor for DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to use in a DMA transfer </td></tr>
    <tr><td class="paramname">stride</td><td>DMA transfer stride, in number of elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00935">935</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0aa2a6c7d8ae30ec56d014fe79700f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::register_for_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450aecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7acb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a>, isPlaceholder &gt; &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a constant memory accessor for DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to use in a DMA transfer </td></tr>
    <tr><td class="paramname">stride</td><td>DMA transfer stride, in number of elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00948">948</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac3358a20e49c3510e7ec3b4e8728f483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::register_for_dma </td>
          <td>(</td>
          <td class="paramtype">accessor_base &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>strideBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an accessor for DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to use in a DMA transfer </td></tr>
    <tr><td class="paramname">stride</td><td>DMA transfer stride, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c912d6178b4f7a9e627d6b7a519d1d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::require </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="el" href="namespacecl_1_1sycl.html#a0b53769ff68f9a0afeb5c5f2342dcff4">kTarget</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that registers a placeholder accessor with the handler. </p>
<p>Defined in Codeplay Extension CP004. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00924">924</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79909103961de6237c32643e43f57d13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::require </td>
          <td>(</td>
          <td class="paramtype">const accessor_base &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function that registers a placeholder accessor with the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481be0c41842998c3593da40ef349df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::require </td>
          <td>(</td>
          <td class="paramtype">const accessor_base &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dmem_shptr&#160;</td>
          <td class="paramname"><em>memObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">access::mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7">access::target</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function that registers a placeholder accessor with the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Bind the null accessor first, then call <a class="el" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9" title="Function that registers a placeholder accessor with the handler. ">require()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an argument when using interop kernels. </p>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00261">261</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7dfc0809b14b8953c842f6114e013e58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::set_args </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all the given kernel args arguments for an OpenCL kernel, as if <a class="el" href="classcl_1_1sycl_1_1handler.html#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8" title="Sets an argument when using interop kernels. ">set_arg()</a> was used with each of them in the same order and increasing index always starting at 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>Types of the parameters passed to the OpenCL kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters passed to the OpenCL kernel </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00280">280</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a753a7db9214d40fb8d43ac6c8b6833e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution. </p>
<p>This function takes in a precompiled kernel syclKernel previously created using build_with_kernel_type or compile_with_kernel_type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91585b4494de2792a5dce6bfcd416bf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::single_task </td>
          <td>(</td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00335">335</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a07d716116114414cd509a93ccd8dda33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>syclKernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const functorT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution. </p>
<p>This function takes in a precompiled kernel syclKernel previously created using build_with_kernel_type or compile_with_kernel_type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l00353">353</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5e3ae7393de2d7c830d48170ee0c989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::update_device_data </td>
          <td>(</td>
          <td class="paramtype">const accessor_base &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">cl::sycl::access::mode</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>userProvidedPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates device data by copying to/from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
    <tr><td class="paramname">hostPtr</td><td>Pointer that points to data on the host </td></tr>
    <tr><td class="paramname">accessMode</td><td>Operation indicator (read -&gt; copy_from_device, write -&gt; copy_to_device) </td></tr>
    <tr><td class="paramname">userProvidedPtr</td><td>Indicated whether the host pointer was provided by the user or whether to use the internal one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7095e10bde4deca0f823ce471b734c42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::update_host </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dims, accessMode, accessTarget, isPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the device data with the current host accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AccessorT</td><td>accessor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01219">1219</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aacaa7a26269cdb5e27ea8f221462580e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a> const <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;elemT, <a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>, <a class="el" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="el" href="namespacecl_1_1sycl.html#a0b53769ff68f9a0afeb5c5f2342dcff4">kTarget</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a>&gt;&amp; cl::sycl::handler::acc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">    this-&gt;<a class="code" href="classcl_1_1sycl_1_1handler.html#a2c912d6178b4f7a9e627d6b7a519d1d9">require</a>(static_cast&lt;const accessor_base&amp;&gt;(<a class="code" href="classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>), <a class="code" href="classcl_1_1sycl_1_1handler.html#ab4bdf5d8c1017daf847d2113c11242f3">bufObj</a>.get_impl(),</div><div class="line">                  <a class="code" href="namespacecl_1_1sycl.html#a8e0ac3ee309ca11111cfe5f073ada8c1">kMode</a>, <a class="code" href="namespacecl_1_1sycl.html#a0b53769ff68f9a0afeb5c5f2342dcff4">kTarget</a>)</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="apis_8h_source.html#l00971">971</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4bdf5d8c1017daf847d2113c11242f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl.html#a3f8af2d88cd5cbd85ba1496c3da01a48">kDims</a>&amp; cl::sycl::handler::bufObj</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="apis_8h_source.html#l00969">969</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca8ae9b682242271c828237b136d2646"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dqueue_shptr cl::sycl::handler::m_fallbackQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the fallback queue (if any) </p>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01447">1447</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac7bffc7ce382906014d6cfaafb7c75e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned cl::sycl::handler::m_numKernels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of kernels in the command group. </p>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01457">1457</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d6d146a3f005c5a27e653a5dab16550"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl.html#a0a3b58674c77d248758b6bee05800ac5">vector_class</a>&lt;add_param_func_t&gt; cl::sycl::handler::m_paramVec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="apis_8h_source.html#l01453">1453</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53746faca0e6189185ff0218bbda5f22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dqueue_shptr cl::sycl::handler::m_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue to which this handler was submitted to. </p>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01443">1443</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<a class="anchor" id="a65cd7a5b02ea526bb946eff87188afa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dtrans_uptr cl::sycl::handler::m_trans</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal transaction associated with the handler. </p>

<p>Definition at line <a class="el" href="apis_8h_source.html#l01439">1439</a> of file <a class="el" href="apis_8h_source.html">apis.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="apis_8h_source.html">apis.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a></li>
    <li class="footer">Generated on Mon Sep 27 2021 12:13:49 for Codeplay ComputeCpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
