/******************************************************************************

    Copyright (C) 2002-2016 Codeplay Software Limited
    All Rights Reserved.

    Codeplay's ComputeCpp

*******************************************************************************/

/*!
  @file abacus_relational

  @brief Abacus relational built-ins.
*/

#ifndef __ABACUS_ABACUS_RELATIONAL__
#define __ABACUS_ABACUS_RELATIONAL__

#ifndef __ABACUS_ABACUS_CONFIG__
#include <abacus/abacus_config>
#endif

////////////////////////////////////////////////////////////////////////////////
/// @defgroup abacus_relational abacus_relational
/// @{

/// @brief Compare of x == y.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int ABACUS_EXPORT_API __abacus_isequal(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isequal(abacus_float x, abacus_float y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int ABACUS_EXPORT_API __abacus_isnotequal(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isnotequal(abacus_float x, abacus_float y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int ABACUS_EXPORT_API __abacus_isgreater(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isgreater(abacus_float x, abacus_float y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isgreaterequal(abacus_float x, abacus_float y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int ABACUS_EXPORT_API __abacus_isless(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isless(abacus_float x, abacus_float y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int ABACUS_EXPORT_API __abacus_islessequal(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API islessequal(abacus_float x, abacus_float y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int ABACUS_EXPORT_API __abacus_islessgreater(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API islessgreater(abacus_float x, abacus_float y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int ABACUS_EXPORT_API __abacus_isfinite(abacus_float x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isfinite(abacus_float x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int ABACUS_EXPORT_API __abacus_isinf(abacus_float x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isinf(abacus_float x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int ABACUS_EXPORT_API __abacus_isnan(abacus_float x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isnan(abacus_float x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int ABACUS_EXPORT_API __abacus_isnormal(abacus_float x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isnormal(abacus_float x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int ABACUS_EXPORT_API __abacus_isordered(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isordered(abacus_float x, abacus_float y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int ABACUS_EXPORT_API __abacus_isunordered(abacus_float x, abacus_float y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_float.
/// @param[in] y A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API isunordered(abacus_float x, abacus_float y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int ABACUS_EXPORT_API __abacus_signbit(abacus_float x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_float.
/// @return      A abacus_float.
inline abacus_int ABACUS_API signbit(abacus_float x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float.
/// @param[in] b A abacus_float.
/// @param[in] c A abacus_float.
/// @return      A abacus_int.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float ABACUS_EXPORT_API __abacus_select(abacus_float a, abacus_float b, abacus_int c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float.
/// @param[in] b A abacus_float.
/// @param[in] c A abacus_int.
/// @return      A abacus_float.
inline abacus_float ABACUS_API select(abacus_float a, abacus_float b, abacus_int c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float.
/// @param[in] b A abacus_float.
/// @param[in] c A abacus_float.
/// @return      A abacus_uint.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float ABACUS_EXPORT_API __abacus_select(abacus_float a, abacus_float b, abacus_uint c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float.
/// @param[in] b A abacus_float.
/// @param[in] c A abacus_uint.
/// @return      A abacus_float.
inline abacus_float ABACUS_API select(abacus_float a, abacus_float b, abacus_uint c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_float.
/// @param[in] b A abacus_float.
/// @param[in] c A abacus_float.
/// @return      A abacus_float.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_float ABACUS_EXPORT_API __abacus_bitselect(abacus_float a, abacus_float b, abacus_float c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_float.
/// @param[in] b A abacus_float.
/// @param[in] c A abacus_float.
/// @return      A abacus_float.
inline abacus_float ABACUS_API bitselect(abacus_float a, abacus_float b, abacus_float c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int2 ABACUS_EXPORT_API __abacus_isequal(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isequal(abacus_float2 x, abacus_float2 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int2 ABACUS_EXPORT_API __abacus_isnotequal(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isnotequal(abacus_float2 x, abacus_float2 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int2 ABACUS_EXPORT_API __abacus_isgreater(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isgreater(abacus_float2 x, abacus_float2 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int2 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isgreaterequal(abacus_float2 x, abacus_float2 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int2 ABACUS_EXPORT_API __abacus_isless(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isless(abacus_float2 x, abacus_float2 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int2 ABACUS_EXPORT_API __abacus_islessequal(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API islessequal(abacus_float2 x, abacus_float2 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int2 ABACUS_EXPORT_API __abacus_islessgreater(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API islessgreater(abacus_float2 x, abacus_float2 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int2 ABACUS_EXPORT_API __abacus_isfinite(abacus_float2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isfinite(abacus_float2 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int2 ABACUS_EXPORT_API __abacus_isinf(abacus_float2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isinf(abacus_float2 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int2 ABACUS_EXPORT_API __abacus_isnan(abacus_float2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isnan(abacus_float2 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int2 ABACUS_EXPORT_API __abacus_isnormal(abacus_float2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isnormal(abacus_float2 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int2 ABACUS_EXPORT_API __abacus_isordered(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isordered(abacus_float2 x, abacus_float2 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int2 ABACUS_EXPORT_API __abacus_isunordered(abacus_float2 x, abacus_float2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_float2.
/// @param[in] y A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API isunordered(abacus_float2 x, abacus_float2 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int2 ABACUS_EXPORT_API __abacus_signbit(abacus_float2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_float2.
/// @return      A abacus_float2.
inline abacus_int2 ABACUS_API signbit(abacus_float2 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float2.
/// @param[in] b A abacus_float2.
/// @param[in] c A abacus_float2.
/// @return      A abacus_int2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float2 ABACUS_EXPORT_API __abacus_select(abacus_float2 a, abacus_float2 b, abacus_int2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float2.
/// @param[in] b A abacus_float2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_float2.
inline abacus_float2 ABACUS_API select(abacus_float2 a, abacus_float2 b, abacus_int2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float2.
/// @param[in] b A abacus_float2.
/// @param[in] c A abacus_float2.
/// @return      A abacus_uint2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float2 ABACUS_EXPORT_API __abacus_select(abacus_float2 a, abacus_float2 b, abacus_uint2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float2.
/// @param[in] b A abacus_float2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_float2.
inline abacus_float2 ABACUS_API select(abacus_float2 a, abacus_float2 b, abacus_uint2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_float2.
/// @param[in] b A abacus_float2.
/// @param[in] c A abacus_float2.
/// @return      A abacus_float2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_float2 ABACUS_EXPORT_API __abacus_bitselect(abacus_float2 a, abacus_float2 b, abacus_float2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_float2.
/// @param[in] b A abacus_float2.
/// @param[in] c A abacus_float2.
/// @return      A abacus_float2.
inline abacus_float2 ABACUS_API bitselect(abacus_float2 a, abacus_float2 b, abacus_float2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int3 ABACUS_EXPORT_API __abacus_isequal(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isequal(abacus_float3 x, abacus_float3 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int3 ABACUS_EXPORT_API __abacus_isnotequal(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isnotequal(abacus_float3 x, abacus_float3 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int3 ABACUS_EXPORT_API __abacus_isgreater(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isgreater(abacus_float3 x, abacus_float3 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int3 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isgreaterequal(abacus_float3 x, abacus_float3 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int3 ABACUS_EXPORT_API __abacus_isless(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isless(abacus_float3 x, abacus_float3 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int3 ABACUS_EXPORT_API __abacus_islessequal(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API islessequal(abacus_float3 x, abacus_float3 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int3 ABACUS_EXPORT_API __abacus_islessgreater(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API islessgreater(abacus_float3 x, abacus_float3 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int3 ABACUS_EXPORT_API __abacus_isfinite(abacus_float3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isfinite(abacus_float3 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int3 ABACUS_EXPORT_API __abacus_isinf(abacus_float3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isinf(abacus_float3 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int3 ABACUS_EXPORT_API __abacus_isnan(abacus_float3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isnan(abacus_float3 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int3 ABACUS_EXPORT_API __abacus_isnormal(abacus_float3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isnormal(abacus_float3 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int3 ABACUS_EXPORT_API __abacus_isordered(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isordered(abacus_float3 x, abacus_float3 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int3 ABACUS_EXPORT_API __abacus_isunordered(abacus_float3 x, abacus_float3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_float3.
/// @param[in] y A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API isunordered(abacus_float3 x, abacus_float3 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int3 ABACUS_EXPORT_API __abacus_signbit(abacus_float3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_float3.
/// @return      A abacus_float3.
inline abacus_int3 ABACUS_API signbit(abacus_float3 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float3.
/// @param[in] b A abacus_float3.
/// @param[in] c A abacus_float3.
/// @return      A abacus_int3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float3 ABACUS_EXPORT_API __abacus_select(abacus_float3 a, abacus_float3 b, abacus_int3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float3.
/// @param[in] b A abacus_float3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_float3.
inline abacus_float3 ABACUS_API select(abacus_float3 a, abacus_float3 b, abacus_int3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float3.
/// @param[in] b A abacus_float3.
/// @param[in] c A abacus_float3.
/// @return      A abacus_uint3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float3 ABACUS_EXPORT_API __abacus_select(abacus_float3 a, abacus_float3 b, abacus_uint3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float3.
/// @param[in] b A abacus_float3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_float3.
inline abacus_float3 ABACUS_API select(abacus_float3 a, abacus_float3 b, abacus_uint3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_float3.
/// @param[in] b A abacus_float3.
/// @param[in] c A abacus_float3.
/// @return      A abacus_float3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_float3 ABACUS_EXPORT_API __abacus_bitselect(abacus_float3 a, abacus_float3 b, abacus_float3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_float3.
/// @param[in] b A abacus_float3.
/// @param[in] c A abacus_float3.
/// @return      A abacus_float3.
inline abacus_float3 ABACUS_API bitselect(abacus_float3 a, abacus_float3 b, abacus_float3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int4 ABACUS_EXPORT_API __abacus_isequal(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isequal(abacus_float4 x, abacus_float4 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int4 ABACUS_EXPORT_API __abacus_isnotequal(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isnotequal(abacus_float4 x, abacus_float4 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int4 ABACUS_EXPORT_API __abacus_isgreater(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isgreater(abacus_float4 x, abacus_float4 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int4 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isgreaterequal(abacus_float4 x, abacus_float4 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int4 ABACUS_EXPORT_API __abacus_isless(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isless(abacus_float4 x, abacus_float4 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int4 ABACUS_EXPORT_API __abacus_islessequal(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API islessequal(abacus_float4 x, abacus_float4 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int4 ABACUS_EXPORT_API __abacus_islessgreater(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API islessgreater(abacus_float4 x, abacus_float4 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int4 ABACUS_EXPORT_API __abacus_isfinite(abacus_float4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isfinite(abacus_float4 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int4 ABACUS_EXPORT_API __abacus_isinf(abacus_float4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isinf(abacus_float4 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int4 ABACUS_EXPORT_API __abacus_isnan(abacus_float4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isnan(abacus_float4 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int4 ABACUS_EXPORT_API __abacus_isnormal(abacus_float4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isnormal(abacus_float4 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int4 ABACUS_EXPORT_API __abacus_isordered(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isordered(abacus_float4 x, abacus_float4 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int4 ABACUS_EXPORT_API __abacus_isunordered(abacus_float4 x, abacus_float4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_float4.
/// @param[in] y A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API isunordered(abacus_float4 x, abacus_float4 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int4 ABACUS_EXPORT_API __abacus_signbit(abacus_float4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_float4.
/// @return      A abacus_float4.
inline abacus_int4 ABACUS_API signbit(abacus_float4 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float4.
/// @param[in] b A abacus_float4.
/// @param[in] c A abacus_float4.
/// @return      A abacus_int4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float4 ABACUS_EXPORT_API __abacus_select(abacus_float4 a, abacus_float4 b, abacus_int4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float4.
/// @param[in] b A abacus_float4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_float4.
inline abacus_float4 ABACUS_API select(abacus_float4 a, abacus_float4 b, abacus_int4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float4.
/// @param[in] b A abacus_float4.
/// @param[in] c A abacus_float4.
/// @return      A abacus_uint4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float4 ABACUS_EXPORT_API __abacus_select(abacus_float4 a, abacus_float4 b, abacus_uint4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float4.
/// @param[in] b A abacus_float4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_float4.
inline abacus_float4 ABACUS_API select(abacus_float4 a, abacus_float4 b, abacus_uint4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_float4.
/// @param[in] b A abacus_float4.
/// @param[in] c A abacus_float4.
/// @return      A abacus_float4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_float4 ABACUS_EXPORT_API __abacus_bitselect(abacus_float4 a, abacus_float4 b, abacus_float4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_float4.
/// @param[in] b A abacus_float4.
/// @param[in] c A abacus_float4.
/// @return      A abacus_float4.
inline abacus_float4 ABACUS_API bitselect(abacus_float4 a, abacus_float4 b, abacus_float4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int8 ABACUS_EXPORT_API __abacus_isequal(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isequal(abacus_float8 x, abacus_float8 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int8 ABACUS_EXPORT_API __abacus_isnotequal(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isnotequal(abacus_float8 x, abacus_float8 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int8 ABACUS_EXPORT_API __abacus_isgreater(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isgreater(abacus_float8 x, abacus_float8 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int8 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isgreaterequal(abacus_float8 x, abacus_float8 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int8 ABACUS_EXPORT_API __abacus_isless(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isless(abacus_float8 x, abacus_float8 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int8 ABACUS_EXPORT_API __abacus_islessequal(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API islessequal(abacus_float8 x, abacus_float8 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int8 ABACUS_EXPORT_API __abacus_islessgreater(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API islessgreater(abacus_float8 x, abacus_float8 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int8 ABACUS_EXPORT_API __abacus_isfinite(abacus_float8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isfinite(abacus_float8 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int8 ABACUS_EXPORT_API __abacus_isinf(abacus_float8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isinf(abacus_float8 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int8 ABACUS_EXPORT_API __abacus_isnan(abacus_float8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isnan(abacus_float8 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int8 ABACUS_EXPORT_API __abacus_isnormal(abacus_float8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isnormal(abacus_float8 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int8 ABACUS_EXPORT_API __abacus_isordered(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isordered(abacus_float8 x, abacus_float8 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int8 ABACUS_EXPORT_API __abacus_isunordered(abacus_float8 x, abacus_float8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_float8.
/// @param[in] y A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API isunordered(abacus_float8 x, abacus_float8 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int8 ABACUS_EXPORT_API __abacus_signbit(abacus_float8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_float8.
/// @return      A abacus_float8.
inline abacus_int8 ABACUS_API signbit(abacus_float8 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float8.
/// @param[in] b A abacus_float8.
/// @param[in] c A abacus_float8.
/// @return      A abacus_int8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float8 ABACUS_EXPORT_API __abacus_select(abacus_float8 a, abacus_float8 b, abacus_int8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float8.
/// @param[in] b A abacus_float8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_float8.
inline abacus_float8 ABACUS_API select(abacus_float8 a, abacus_float8 b, abacus_int8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float8.
/// @param[in] b A abacus_float8.
/// @param[in] c A abacus_float8.
/// @return      A abacus_uint8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float8 ABACUS_EXPORT_API __abacus_select(abacus_float8 a, abacus_float8 b, abacus_uint8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float8.
/// @param[in] b A abacus_float8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_float8.
inline abacus_float8 ABACUS_API select(abacus_float8 a, abacus_float8 b, abacus_uint8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_float8.
/// @param[in] b A abacus_float8.
/// @param[in] c A abacus_float8.
/// @return      A abacus_float8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_float8 ABACUS_EXPORT_API __abacus_bitselect(abacus_float8 a, abacus_float8 b, abacus_float8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_float8.
/// @param[in] b A abacus_float8.
/// @param[in] c A abacus_float8.
/// @return      A abacus_float8.
inline abacus_float8 ABACUS_API bitselect(abacus_float8 a, abacus_float8 b, abacus_float8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int16 ABACUS_EXPORT_API __abacus_isequal(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isequal(abacus_float16 x, abacus_float16 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int16 ABACUS_EXPORT_API __abacus_isnotequal(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isnotequal(abacus_float16 x, abacus_float16 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int16 ABACUS_EXPORT_API __abacus_isgreater(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isgreater(abacus_float16 x, abacus_float16 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int16 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isgreaterequal(abacus_float16 x, abacus_float16 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int16 ABACUS_EXPORT_API __abacus_isless(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isless(abacus_float16 x, abacus_float16 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int16 ABACUS_EXPORT_API __abacus_islessequal(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API islessequal(abacus_float16 x, abacus_float16 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int16 ABACUS_EXPORT_API __abacus_islessgreater(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API islessgreater(abacus_float16 x, abacus_float16 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int16 ABACUS_EXPORT_API __abacus_isfinite(abacus_float16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isfinite(abacus_float16 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int16 ABACUS_EXPORT_API __abacus_isinf(abacus_float16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isinf(abacus_float16 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int16 ABACUS_EXPORT_API __abacus_isnan(abacus_float16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isnan(abacus_float16 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int16 ABACUS_EXPORT_API __abacus_isnormal(abacus_float16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isnormal(abacus_float16 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int16 ABACUS_EXPORT_API __abacus_isordered(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isordered(abacus_float16 x, abacus_float16 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int16 ABACUS_EXPORT_API __abacus_isunordered(abacus_float16 x, abacus_float16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_float16.
/// @param[in] y A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API isunordered(abacus_float16 x, abacus_float16 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int16 ABACUS_EXPORT_API __abacus_signbit(abacus_float16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_float16.
/// @return      A abacus_float16.
inline abacus_int16 ABACUS_API signbit(abacus_float16 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float16.
/// @param[in] b A abacus_float16.
/// @param[in] c A abacus_float16.
/// @return      A abacus_int16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float16 ABACUS_EXPORT_API __abacus_select(abacus_float16 a, abacus_float16 b, abacus_int16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float16.
/// @param[in] b A abacus_float16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_float16.
inline abacus_float16 ABACUS_API select(abacus_float16 a, abacus_float16 b, abacus_int16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_float16.
/// @param[in] b A abacus_float16.
/// @param[in] c A abacus_float16.
/// @return      A abacus_uint16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_float16 ABACUS_EXPORT_API __abacus_select(abacus_float16 a, abacus_float16 b, abacus_uint16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_float16.
/// @param[in] b A abacus_float16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_float16.
inline abacus_float16 ABACUS_API select(abacus_float16 a, abacus_float16 b, abacus_uint16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_float16.
/// @param[in] b A abacus_float16.
/// @param[in] c A abacus_float16.
/// @return      A abacus_float16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_float16 ABACUS_EXPORT_API __abacus_bitselect(abacus_float16 a, abacus_float16 b, abacus_float16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_float16.
/// @param[in] b A abacus_float16.
/// @param[in] c A abacus_float16.
/// @return      A abacus_float16.
inline abacus_float16 ABACUS_API bitselect(abacus_float16 a, abacus_float16 b, abacus_float16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_int ABACUS_EXPORT_API __abacus_isequal(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isequal(abacus_double x, abacus_double y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_int ABACUS_EXPORT_API __abacus_isnotequal(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isnotequal(abacus_double x, abacus_double y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_int ABACUS_EXPORT_API __abacus_isgreater(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isgreater(abacus_double x, abacus_double y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_int ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isgreaterequal(abacus_double x, abacus_double y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_int ABACUS_EXPORT_API __abacus_isless(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isless(abacus_double x, abacus_double y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_int ABACUS_EXPORT_API __abacus_islessequal(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API islessequal(abacus_double x, abacus_double y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_int ABACUS_EXPORT_API __abacus_islessgreater(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API islessgreater(abacus_double x, abacus_double y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_int ABACUS_EXPORT_API __abacus_isfinite(abacus_double x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isfinite(abacus_double x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_int ABACUS_EXPORT_API __abacus_isinf(abacus_double x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isinf(abacus_double x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_int ABACUS_EXPORT_API __abacus_isnan(abacus_double x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isnan(abacus_double x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_int ABACUS_EXPORT_API __abacus_isnormal(abacus_double x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isnormal(abacus_double x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_int ABACUS_EXPORT_API __abacus_isordered(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isordered(abacus_double x, abacus_double y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_int ABACUS_EXPORT_API __abacus_isunordered(abacus_double x, abacus_double y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_double.
/// @param[in] y A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API isunordered(abacus_double x, abacus_double y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_int ABACUS_EXPORT_API __abacus_signbit(abacus_double x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_double.
/// @return      A abacus_double.
inline abacus_int ABACUS_API signbit(abacus_double x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double.
/// @param[in] b A abacus_double.
/// @param[in] c A abacus_double.
/// @return      A abacus_int.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double ABACUS_EXPORT_API __abacus_select(abacus_double a, abacus_double b, abacus_long c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double.
/// @param[in] b A abacus_double.
/// @param[in] c A abacus_int.
/// @return      A abacus_double.
inline abacus_double ABACUS_API select(abacus_double a, abacus_double b, abacus_long c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double.
/// @param[in] b A abacus_double.
/// @param[in] c A abacus_double.
/// @return      A abacus_uint.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double ABACUS_EXPORT_API __abacus_select(abacus_double a, abacus_double b, abacus_ulong c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double.
/// @param[in] b A abacus_double.
/// @param[in] c A abacus_uint.
/// @return      A abacus_double.
inline abacus_double ABACUS_API select(abacus_double a, abacus_double b, abacus_ulong c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_double.
/// @param[in] b A abacus_double.
/// @param[in] c A abacus_double.
/// @return      A abacus_double.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_double ABACUS_EXPORT_API __abacus_bitselect(abacus_double a, abacus_double b, abacus_double c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_double.
/// @param[in] b A abacus_double.
/// @param[in] c A abacus_double.
/// @return      A abacus_double.
inline abacus_double ABACUS_API bitselect(abacus_double a, abacus_double b, abacus_double c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_long2 ABACUS_EXPORT_API __abacus_isequal(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isequal(abacus_double2 x, abacus_double2 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_long2 ABACUS_EXPORT_API __abacus_isnotequal(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isnotequal(abacus_double2 x, abacus_double2 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_long2 ABACUS_EXPORT_API __abacus_isgreater(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isgreater(abacus_double2 x, abacus_double2 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_long2 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isgreaterequal(abacus_double2 x, abacus_double2 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_long2 ABACUS_EXPORT_API __abacus_isless(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isless(abacus_double2 x, abacus_double2 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_long2 ABACUS_EXPORT_API __abacus_islessequal(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API islessequal(abacus_double2 x, abacus_double2 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_long2 ABACUS_EXPORT_API __abacus_islessgreater(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API islessgreater(abacus_double2 x, abacus_double2 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_long2 ABACUS_EXPORT_API __abacus_isfinite(abacus_double2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isfinite(abacus_double2 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_long2 ABACUS_EXPORT_API __abacus_isinf(abacus_double2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isinf(abacus_double2 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_long2 ABACUS_EXPORT_API __abacus_isnan(abacus_double2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isnan(abacus_double2 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_long2 ABACUS_EXPORT_API __abacus_isnormal(abacus_double2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isnormal(abacus_double2 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_long2 ABACUS_EXPORT_API __abacus_isordered(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isordered(abacus_double2 x, abacus_double2 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_long2 ABACUS_EXPORT_API __abacus_isunordered(abacus_double2 x, abacus_double2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_double2.
/// @param[in] y A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API isunordered(abacus_double2 x, abacus_double2 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_long2 ABACUS_EXPORT_API __abacus_signbit(abacus_double2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_double2.
/// @return      A abacus_double2.
inline abacus_long2 ABACUS_API signbit(abacus_double2 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double2.
/// @param[in] b A abacus_double2.
/// @param[in] c A abacus_double2.
/// @return      A abacus_long2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double2 ABACUS_EXPORT_API __abacus_select(abacus_double2 a, abacus_double2 b, abacus_long2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double2.
/// @param[in] b A abacus_double2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_double2.
inline abacus_double2 ABACUS_API select(abacus_double2 a, abacus_double2 b, abacus_long2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double2.
/// @param[in] b A abacus_double2.
/// @param[in] c A abacus_double2.
/// @return      A abacus_ulong2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double2 ABACUS_EXPORT_API __abacus_select(abacus_double2 a, abacus_double2 b, abacus_ulong2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double2.
/// @param[in] b A abacus_double2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_double2.
inline abacus_double2 ABACUS_API select(abacus_double2 a, abacus_double2 b, abacus_ulong2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_double2.
/// @param[in] b A abacus_double2.
/// @param[in] c A abacus_double2.
/// @return      A abacus_double2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_double2 ABACUS_EXPORT_API __abacus_bitselect(abacus_double2 a, abacus_double2 b, abacus_double2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_double2.
/// @param[in] b A abacus_double2.
/// @param[in] c A abacus_double2.
/// @return      A abacus_double2.
inline abacus_double2 ABACUS_API bitselect(abacus_double2 a, abacus_double2 b, abacus_double2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_long3 ABACUS_EXPORT_API __abacus_isequal(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isequal(abacus_double3 x, abacus_double3 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_long3 ABACUS_EXPORT_API __abacus_isnotequal(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isnotequal(abacus_double3 x, abacus_double3 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_long3 ABACUS_EXPORT_API __abacus_isgreater(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isgreater(abacus_double3 x, abacus_double3 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_long3 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isgreaterequal(abacus_double3 x, abacus_double3 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_long3 ABACUS_EXPORT_API __abacus_isless(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isless(abacus_double3 x, abacus_double3 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_long3 ABACUS_EXPORT_API __abacus_islessequal(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API islessequal(abacus_double3 x, abacus_double3 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_long3 ABACUS_EXPORT_API __abacus_islessgreater(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API islessgreater(abacus_double3 x, abacus_double3 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_long3 ABACUS_EXPORT_API __abacus_isfinite(abacus_double3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isfinite(abacus_double3 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_long3 ABACUS_EXPORT_API __abacus_isinf(abacus_double3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isinf(abacus_double3 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_long3 ABACUS_EXPORT_API __abacus_isnan(abacus_double3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isnan(abacus_double3 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_long3 ABACUS_EXPORT_API __abacus_isnormal(abacus_double3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isnormal(abacus_double3 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_long3 ABACUS_EXPORT_API __abacus_isordered(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isordered(abacus_double3 x, abacus_double3 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_long3 ABACUS_EXPORT_API __abacus_isunordered(abacus_double3 x, abacus_double3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_double3.
/// @param[in] y A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API isunordered(abacus_double3 x, abacus_double3 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_long3 ABACUS_EXPORT_API __abacus_signbit(abacus_double3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_double3.
/// @return      A abacus_double3.
inline abacus_long3 ABACUS_API signbit(abacus_double3 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double3.
/// @param[in] b A abacus_double3.
/// @param[in] c A abacus_double3.
/// @return      A abacus_long3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double3 ABACUS_EXPORT_API __abacus_select(abacus_double3 a, abacus_double3 b, abacus_long3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double3.
/// @param[in] b A abacus_double3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_double3.
inline abacus_double3 ABACUS_API select(abacus_double3 a, abacus_double3 b, abacus_long3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double3.
/// @param[in] b A abacus_double3.
/// @param[in] c A abacus_double3.
/// @return      A abacus_ulong3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double3 ABACUS_EXPORT_API __abacus_select(abacus_double3 a, abacus_double3 b, abacus_ulong3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double3.
/// @param[in] b A abacus_double3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_double3.
inline abacus_double3 ABACUS_API select(abacus_double3 a, abacus_double3 b, abacus_ulong3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_double3.
/// @param[in] b A abacus_double3.
/// @param[in] c A abacus_double3.
/// @return      A abacus_double3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_double3 ABACUS_EXPORT_API __abacus_bitselect(abacus_double3 a, abacus_double3 b, abacus_double3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_double3.
/// @param[in] b A abacus_double3.
/// @param[in] c A abacus_double3.
/// @return      A abacus_double3.
inline abacus_double3 ABACUS_API bitselect(abacus_double3 a, abacus_double3 b, abacus_double3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_long4 ABACUS_EXPORT_API __abacus_isequal(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isequal(abacus_double4 x, abacus_double4 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_long4 ABACUS_EXPORT_API __abacus_isnotequal(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isnotequal(abacus_double4 x, abacus_double4 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_long4 ABACUS_EXPORT_API __abacus_isgreater(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isgreater(abacus_double4 x, abacus_double4 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_long4 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isgreaterequal(abacus_double4 x, abacus_double4 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_long4 ABACUS_EXPORT_API __abacus_isless(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isless(abacus_double4 x, abacus_double4 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_long4 ABACUS_EXPORT_API __abacus_islessequal(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API islessequal(abacus_double4 x, abacus_double4 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_long4 ABACUS_EXPORT_API __abacus_islessgreater(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API islessgreater(abacus_double4 x, abacus_double4 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_long4 ABACUS_EXPORT_API __abacus_isfinite(abacus_double4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isfinite(abacus_double4 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_long4 ABACUS_EXPORT_API __abacus_isinf(abacus_double4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isinf(abacus_double4 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_long4 ABACUS_EXPORT_API __abacus_isnan(abacus_double4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isnan(abacus_double4 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_long4 ABACUS_EXPORT_API __abacus_isnormal(abacus_double4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isnormal(abacus_double4 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_long4 ABACUS_EXPORT_API __abacus_isordered(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isordered(abacus_double4 x, abacus_double4 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_long4 ABACUS_EXPORT_API __abacus_isunordered(abacus_double4 x, abacus_double4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_double4.
/// @param[in] y A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API isunordered(abacus_double4 x, abacus_double4 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_long4 ABACUS_EXPORT_API __abacus_signbit(abacus_double4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_double4.
/// @return      A abacus_double4.
inline abacus_long4 ABACUS_API signbit(abacus_double4 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double4.
/// @param[in] b A abacus_double4.
/// @param[in] c A abacus_double4.
/// @return      A abacus_long4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double4 ABACUS_EXPORT_API __abacus_select(abacus_double4 a, abacus_double4 b, abacus_long4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double4.
/// @param[in] b A abacus_double4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_double4.
inline abacus_double4 ABACUS_API select(abacus_double4 a, abacus_double4 b, abacus_long4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double4.
/// @param[in] b A abacus_double4.
/// @param[in] c A abacus_double4.
/// @return      A abacus_ulong4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double4 ABACUS_EXPORT_API __abacus_select(abacus_double4 a, abacus_double4 b, abacus_ulong4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double4.
/// @param[in] b A abacus_double4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_double4.
inline abacus_double4 ABACUS_API select(abacus_double4 a, abacus_double4 b, abacus_ulong4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_double4.
/// @param[in] b A abacus_double4.
/// @param[in] c A abacus_double4.
/// @return      A abacus_double4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_double4 ABACUS_EXPORT_API __abacus_bitselect(abacus_double4 a, abacus_double4 b, abacus_double4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_double4.
/// @param[in] b A abacus_double4.
/// @param[in] c A abacus_double4.
/// @return      A abacus_double4.
inline abacus_double4 ABACUS_API bitselect(abacus_double4 a, abacus_double4 b, abacus_double4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_long8 ABACUS_EXPORT_API __abacus_isequal(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isequal(abacus_double8 x, abacus_double8 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_long8 ABACUS_EXPORT_API __abacus_isnotequal(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isnotequal(abacus_double8 x, abacus_double8 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_long8 ABACUS_EXPORT_API __abacus_isgreater(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isgreater(abacus_double8 x, abacus_double8 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_long8 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isgreaterequal(abacus_double8 x, abacus_double8 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_long8 ABACUS_EXPORT_API __abacus_isless(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isless(abacus_double8 x, abacus_double8 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_long8 ABACUS_EXPORT_API __abacus_islessequal(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API islessequal(abacus_double8 x, abacus_double8 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_long8 ABACUS_EXPORT_API __abacus_islessgreater(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API islessgreater(abacus_double8 x, abacus_double8 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_long8 ABACUS_EXPORT_API __abacus_isfinite(abacus_double8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isfinite(abacus_double8 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_long8 ABACUS_EXPORT_API __abacus_isinf(abacus_double8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isinf(abacus_double8 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_long8 ABACUS_EXPORT_API __abacus_isnan(abacus_double8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isnan(abacus_double8 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_long8 ABACUS_EXPORT_API __abacus_isnormal(abacus_double8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isnormal(abacus_double8 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_long8 ABACUS_EXPORT_API __abacus_isordered(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isordered(abacus_double8 x, abacus_double8 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_long8 ABACUS_EXPORT_API __abacus_isunordered(abacus_double8 x, abacus_double8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_double8.
/// @param[in] y A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API isunordered(abacus_double8 x, abacus_double8 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_long8 ABACUS_EXPORT_API __abacus_signbit(abacus_double8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_double8.
/// @return      A abacus_double8.
inline abacus_long8 ABACUS_API signbit(abacus_double8 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double8.
/// @param[in] b A abacus_double8.
/// @param[in] c A abacus_double8.
/// @return      A abacus_long8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double8 ABACUS_EXPORT_API __abacus_select(abacus_double8 a, abacus_double8 b, abacus_long8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double8.
/// @param[in] b A abacus_double8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_double8.
inline abacus_double8 ABACUS_API select(abacus_double8 a, abacus_double8 b, abacus_long8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double8.
/// @param[in] b A abacus_double8.
/// @param[in] c A abacus_double8.
/// @return      A abacus_ulong8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double8 ABACUS_EXPORT_API __abacus_select(abacus_double8 a, abacus_double8 b, abacus_ulong8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double8.
/// @param[in] b A abacus_double8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_double8.
inline abacus_double8 ABACUS_API select(abacus_double8 a, abacus_double8 b, abacus_ulong8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_double8.
/// @param[in] b A abacus_double8.
/// @param[in] c A abacus_double8.
/// @return      A abacus_double8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_double8 ABACUS_EXPORT_API __abacus_bitselect(abacus_double8 a, abacus_double8 b, abacus_double8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_double8.
/// @param[in] b A abacus_double8.
/// @param[in] c A abacus_double8.
/// @return      A abacus_double8.
inline abacus_double8 ABACUS_API bitselect(abacus_double8 a, abacus_double8 b, abacus_double8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Compare of x == y.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_long16 ABACUS_EXPORT_API __abacus_isequal(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isequal(abacus_double16 x, abacus_double16 y) {
  return __abacus_isequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_long16 ABACUS_EXPORT_API __abacus_isnotequal(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isnotequal(abacus_double16 x, abacus_double16 y) {
  return __abacus_isnotequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_long16 ABACUS_EXPORT_API __abacus_isgreater(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isgreater(abacus_double16 x, abacus_double16 y) {
  return __abacus_isgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_long16 ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isgreaterequal(abacus_double16 x, abacus_double16 y) {
  return __abacus_isgreaterequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_long16 ABACUS_EXPORT_API __abacus_isless(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isless(abacus_double16 x, abacus_double16 y) {
  return __abacus_isless(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_long16 ABACUS_EXPORT_API __abacus_islessequal(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API islessequal(abacus_double16 x, abacus_double16 y) {
  return __abacus_islessequal(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_long16 ABACUS_EXPORT_API __abacus_islessgreater(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API islessgreater(abacus_double16 x, abacus_double16 y) {
  return __abacus_islessgreater(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_long16 ABACUS_EXPORT_API __abacus_isfinite(abacus_double16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isfinite(abacus_double16 x) {
  return __abacus_isfinite(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_long16 ABACUS_EXPORT_API __abacus_isinf(abacus_double16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isinf(abacus_double16 x) {
  return __abacus_isinf(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_long16 ABACUS_EXPORT_API __abacus_isnan(abacus_double16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isnan(abacus_double16 x) {
  return __abacus_isnan(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_long16 ABACUS_EXPORT_API __abacus_isnormal(abacus_double16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isnormal(abacus_double16 x) {
  return __abacus_isnormal(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_long16 ABACUS_EXPORT_API __abacus_isordered(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isordered(abacus_double16 x, abacus_double16 y) {
  return __abacus_isordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_long16 ABACUS_EXPORT_API __abacus_isunordered(abacus_double16 x, abacus_double16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_double16.
/// @param[in] y A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API isunordered(abacus_double16 x, abacus_double16 y) {
  return __abacus_isunordered(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_long16 ABACUS_EXPORT_API __abacus_signbit(abacus_double16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_double16.
/// @return      A abacus_double16.
inline abacus_long16 ABACUS_API signbit(abacus_double16 x) {
  return __abacus_signbit(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double16.
/// @param[in] b A abacus_double16.
/// @param[in] c A abacus_double16.
/// @return      A abacus_long16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double16 ABACUS_EXPORT_API __abacus_select(abacus_double16 a, abacus_double16 b, abacus_long16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double16.
/// @param[in] b A abacus_double16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_double16.
inline abacus_double16 ABACUS_API select(abacus_double16 a, abacus_double16 b, abacus_long16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_double16.
/// @param[in] b A abacus_double16.
/// @param[in] c A abacus_double16.
/// @return      A abacus_ulong16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_double16 ABACUS_EXPORT_API __abacus_select(abacus_double16 a, abacus_double16 b, abacus_ulong16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_double16.
/// @param[in] b A abacus_double16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_double16.
inline abacus_double16 ABACUS_API select(abacus_double16 a, abacus_double16 b, abacus_ulong16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_double16.
/// @param[in] b A abacus_double16.
/// @param[in] c A abacus_double16.
/// @return      A abacus_double16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_double16 ABACUS_EXPORT_API __abacus_bitselect(abacus_double16 a, abacus_double16 b, abacus_double16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_double16.
/// @param[in] b A abacus_double16.
/// @param[in] c A abacus_double16.
/// @return      A abacus_double16.
inline abacus_double16 ABACUS_API bitselect(abacus_double16 a, abacus_double16 b, abacus_double16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char.
/// @param[in] b A abacus_char.
/// @param[in] c A abacus_char.
/// @return      A abacus_char.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char ABACUS_EXPORT_API __abacus_select(abacus_char a, abacus_char b, abacus_char c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char.
/// @param[in] b A abacus_char.
/// @param[in] c A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API select(abacus_char a, abacus_char b, abacus_char c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char.
/// @param[in] b A abacus_char.
/// @param[in] c A abacus_uchar.
/// @return      A abacus_char.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char ABACUS_EXPORT_API __abacus_select(abacus_char a, abacus_char b, abacus_uchar c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char.
/// @param[in] b A abacus_char.
/// @param[in] c A abacus_uchar.
/// @return      A abacus_char.
inline abacus_char ABACUS_API select(abacus_char a, abacus_char b, abacus_uchar c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar.
/// @param[in] b A abacus_uchar.
/// @param[in] c A abacus_char.
/// @return      A abacus_uchar.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar ABACUS_EXPORT_API __abacus_select(abacus_uchar a, abacus_uchar b, abacus_char c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar.
/// @param[in] b A abacus_uchar.
/// @param[in] c A abacus_char.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API select(abacus_uchar a, abacus_uchar b, abacus_char c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar.
/// @param[in] b A abacus_uchar.
/// @param[in] c A abacus_uchar.
/// @return      A abacus_uchar.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar ABACUS_EXPORT_API __abacus_select(abacus_uchar a, abacus_uchar b, abacus_uchar c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar.
/// @param[in] b A abacus_uchar.
/// @param[in] c A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API select(abacus_uchar a, abacus_uchar b, abacus_uchar c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_char.
/// @param[in] b A abacus_char.
/// @param[in] c A abacus_char.
/// @return      A abacus_char.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_char ABACUS_EXPORT_API __abacus_bitselect(abacus_char a, abacus_char b, abacus_char c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_char.
/// @param[in] b A abacus_char.
/// @param[in] c A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API bitselect(abacus_char a, abacus_char b, abacus_char c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uchar.
/// @param[in] b A abacus_uchar.
/// @param[in] c A abacus_uchar.
/// @return      A abacus_uchar.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uchar ABACUS_EXPORT_API __abacus_bitselect(abacus_uchar a, abacus_uchar b, abacus_uchar c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uchar.
/// @param[in] b A abacus_uchar.
/// @param[in] c A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API bitselect(abacus_uchar a, abacus_uchar b, abacus_uchar c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_char.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_char x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_char.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_char x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_char.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_char x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_char.
/// @return      A abacus_char.
inline abacus_int ABACUS_API all(abacus_char x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char2.
/// @param[in] b A abacus_char2.
/// @param[in] c A abacus_char2.
/// @return      A abacus_char2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char2 ABACUS_EXPORT_API __abacus_select(abacus_char2 a, abacus_char2 b, abacus_char2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char2.
/// @param[in] b A abacus_char2.
/// @param[in] c A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API select(abacus_char2 a, abacus_char2 b, abacus_char2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char2.
/// @param[in] b A abacus_char2.
/// @param[in] c A abacus_uchar2.
/// @return      A abacus_char2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char2 ABACUS_EXPORT_API __abacus_select(abacus_char2 a, abacus_char2 b, abacus_uchar2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char2.
/// @param[in] b A abacus_char2.
/// @param[in] c A abacus_uchar2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API select(abacus_char2 a, abacus_char2 b, abacus_uchar2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar2.
/// @param[in] b A abacus_uchar2.
/// @param[in] c A abacus_char2.
/// @return      A abacus_uchar2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_select(abacus_uchar2 a, abacus_uchar2 b, abacus_char2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar2.
/// @param[in] b A abacus_uchar2.
/// @param[in] c A abacus_char2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API select(abacus_uchar2 a, abacus_uchar2 b, abacus_char2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar2.
/// @param[in] b A abacus_uchar2.
/// @param[in] c A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_select(abacus_uchar2 a, abacus_uchar2 b, abacus_uchar2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar2.
/// @param[in] b A abacus_uchar2.
/// @param[in] c A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API select(abacus_uchar2 a, abacus_uchar2 b, abacus_uchar2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_char2.
/// @param[in] b A abacus_char2.
/// @param[in] c A abacus_char2.
/// @return      A abacus_char2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_char2 ABACUS_EXPORT_API __abacus_bitselect(abacus_char2 a, abacus_char2 b, abacus_char2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_char2.
/// @param[in] b A abacus_char2.
/// @param[in] c A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API bitselect(abacus_char2 a, abacus_char2 b, abacus_char2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uchar2.
/// @param[in] b A abacus_uchar2.
/// @param[in] c A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_bitselect(abacus_uchar2 a, abacus_uchar2 b, abacus_uchar2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uchar2.
/// @param[in] b A abacus_uchar2.
/// @param[in] c A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API bitselect(abacus_uchar2 a, abacus_uchar2 b, abacus_uchar2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_char2.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_char2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_char2.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_char2 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_char2.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_char2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_char2.
/// @return      A abacus_char2.
inline abacus_int ABACUS_API all(abacus_char2 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char3.
/// @param[in] b A abacus_char3.
/// @param[in] c A abacus_char3.
/// @return      A abacus_char3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char3 ABACUS_EXPORT_API __abacus_select(abacus_char3 a, abacus_char3 b, abacus_char3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char3.
/// @param[in] b A abacus_char3.
/// @param[in] c A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API select(abacus_char3 a, abacus_char3 b, abacus_char3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char3.
/// @param[in] b A abacus_char3.
/// @param[in] c A abacus_uchar3.
/// @return      A abacus_char3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char3 ABACUS_EXPORT_API __abacus_select(abacus_char3 a, abacus_char3 b, abacus_uchar3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char3.
/// @param[in] b A abacus_char3.
/// @param[in] c A abacus_uchar3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API select(abacus_char3 a, abacus_char3 b, abacus_uchar3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar3.
/// @param[in] b A abacus_uchar3.
/// @param[in] c A abacus_char3.
/// @return      A abacus_uchar3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_select(abacus_uchar3 a, abacus_uchar3 b, abacus_char3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar3.
/// @param[in] b A abacus_uchar3.
/// @param[in] c A abacus_char3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API select(abacus_uchar3 a, abacus_uchar3 b, abacus_char3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar3.
/// @param[in] b A abacus_uchar3.
/// @param[in] c A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_select(abacus_uchar3 a, abacus_uchar3 b, abacus_uchar3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar3.
/// @param[in] b A abacus_uchar3.
/// @param[in] c A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API select(abacus_uchar3 a, abacus_uchar3 b, abacus_uchar3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_char3.
/// @param[in] b A abacus_char3.
/// @param[in] c A abacus_char3.
/// @return      A abacus_char3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_char3 ABACUS_EXPORT_API __abacus_bitselect(abacus_char3 a, abacus_char3 b, abacus_char3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_char3.
/// @param[in] b A abacus_char3.
/// @param[in] c A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API bitselect(abacus_char3 a, abacus_char3 b, abacus_char3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uchar3.
/// @param[in] b A abacus_uchar3.
/// @param[in] c A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_bitselect(abacus_uchar3 a, abacus_uchar3 b, abacus_uchar3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uchar3.
/// @param[in] b A abacus_uchar3.
/// @param[in] c A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API bitselect(abacus_uchar3 a, abacus_uchar3 b, abacus_uchar3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_char3.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_char3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_char3.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_char3 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_char3.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_char3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_char3.
/// @return      A abacus_char3.
inline abacus_int ABACUS_API all(abacus_char3 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char4.
/// @param[in] b A abacus_char4.
/// @param[in] c A abacus_char4.
/// @return      A abacus_char4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char4 ABACUS_EXPORT_API __abacus_select(abacus_char4 a, abacus_char4 b, abacus_char4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char4.
/// @param[in] b A abacus_char4.
/// @param[in] c A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API select(abacus_char4 a, abacus_char4 b, abacus_char4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char4.
/// @param[in] b A abacus_char4.
/// @param[in] c A abacus_uchar4.
/// @return      A abacus_char4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char4 ABACUS_EXPORT_API __abacus_select(abacus_char4 a, abacus_char4 b, abacus_uchar4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char4.
/// @param[in] b A abacus_char4.
/// @param[in] c A abacus_uchar4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API select(abacus_char4 a, abacus_char4 b, abacus_uchar4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar4.
/// @param[in] b A abacus_uchar4.
/// @param[in] c A abacus_char4.
/// @return      A abacus_uchar4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_select(abacus_uchar4 a, abacus_uchar4 b, abacus_char4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar4.
/// @param[in] b A abacus_uchar4.
/// @param[in] c A abacus_char4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API select(abacus_uchar4 a, abacus_uchar4 b, abacus_char4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar4.
/// @param[in] b A abacus_uchar4.
/// @param[in] c A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_select(abacus_uchar4 a, abacus_uchar4 b, abacus_uchar4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar4.
/// @param[in] b A abacus_uchar4.
/// @param[in] c A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API select(abacus_uchar4 a, abacus_uchar4 b, abacus_uchar4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_char4.
/// @param[in] b A abacus_char4.
/// @param[in] c A abacus_char4.
/// @return      A abacus_char4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_char4 ABACUS_EXPORT_API __abacus_bitselect(abacus_char4 a, abacus_char4 b, abacus_char4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_char4.
/// @param[in] b A abacus_char4.
/// @param[in] c A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API bitselect(abacus_char4 a, abacus_char4 b, abacus_char4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uchar4.
/// @param[in] b A abacus_uchar4.
/// @param[in] c A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_bitselect(abacus_uchar4 a, abacus_uchar4 b, abacus_uchar4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uchar4.
/// @param[in] b A abacus_uchar4.
/// @param[in] c A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API bitselect(abacus_uchar4 a, abacus_uchar4 b, abacus_uchar4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_char4.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_char4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_char4.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_char4 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_char4.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_char4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_char4.
/// @return      A abacus_char4.
inline abacus_int ABACUS_API all(abacus_char4 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char8.
/// @param[in] b A abacus_char8.
/// @param[in] c A abacus_char8.
/// @return      A abacus_char8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char8 ABACUS_EXPORT_API __abacus_select(abacus_char8 a, abacus_char8 b, abacus_char8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char8.
/// @param[in] b A abacus_char8.
/// @param[in] c A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API select(abacus_char8 a, abacus_char8 b, abacus_char8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char8.
/// @param[in] b A abacus_char8.
/// @param[in] c A abacus_uchar8.
/// @return      A abacus_char8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char8 ABACUS_EXPORT_API __abacus_select(abacus_char8 a, abacus_char8 b, abacus_uchar8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char8.
/// @param[in] b A abacus_char8.
/// @param[in] c A abacus_uchar8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API select(abacus_char8 a, abacus_char8 b, abacus_uchar8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar8.
/// @param[in] b A abacus_uchar8.
/// @param[in] c A abacus_char8.
/// @return      A abacus_uchar8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_select(abacus_uchar8 a, abacus_uchar8 b, abacus_char8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar8.
/// @param[in] b A abacus_uchar8.
/// @param[in] c A abacus_char8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API select(abacus_uchar8 a, abacus_uchar8 b, abacus_char8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar8.
/// @param[in] b A abacus_uchar8.
/// @param[in] c A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_select(abacus_uchar8 a, abacus_uchar8 b, abacus_uchar8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar8.
/// @param[in] b A abacus_uchar8.
/// @param[in] c A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API select(abacus_uchar8 a, abacus_uchar8 b, abacus_uchar8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_char8.
/// @param[in] b A abacus_char8.
/// @param[in] c A abacus_char8.
/// @return      A abacus_char8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_char8 ABACUS_EXPORT_API __abacus_bitselect(abacus_char8 a, abacus_char8 b, abacus_char8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_char8.
/// @param[in] b A abacus_char8.
/// @param[in] c A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API bitselect(abacus_char8 a, abacus_char8 b, abacus_char8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uchar8.
/// @param[in] b A abacus_uchar8.
/// @param[in] c A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_bitselect(abacus_uchar8 a, abacus_uchar8 b, abacus_uchar8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uchar8.
/// @param[in] b A abacus_uchar8.
/// @param[in] c A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API bitselect(abacus_uchar8 a, abacus_uchar8 b, abacus_uchar8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_char8.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_char8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_char8.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_char8 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_char8.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_char8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_char8.
/// @return      A abacus_char8.
inline abacus_int ABACUS_API all(abacus_char8 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char16.
/// @param[in] b A abacus_char16.
/// @param[in] c A abacus_char16.
/// @return      A abacus_char16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char16 ABACUS_EXPORT_API __abacus_select(abacus_char16 a, abacus_char16 b, abacus_char16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char16.
/// @param[in] b A abacus_char16.
/// @param[in] c A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API select(abacus_char16 a, abacus_char16 b, abacus_char16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_char16.
/// @param[in] b A abacus_char16.
/// @param[in] c A abacus_uchar16.
/// @return      A abacus_char16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_char16 ABACUS_EXPORT_API __abacus_select(abacus_char16 a, abacus_char16 b, abacus_uchar16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_char16.
/// @param[in] b A abacus_char16.
/// @param[in] c A abacus_uchar16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API select(abacus_char16 a, abacus_char16 b, abacus_uchar16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar16.
/// @param[in] b A abacus_uchar16.
/// @param[in] c A abacus_char16.
/// @return      A abacus_uchar16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_select(abacus_uchar16 a, abacus_uchar16 b, abacus_char16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar16.
/// @param[in] b A abacus_uchar16.
/// @param[in] c A abacus_char16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API select(abacus_uchar16 a, abacus_uchar16 b, abacus_char16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uchar16.
/// @param[in] b A abacus_uchar16.
/// @param[in] c A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_select(abacus_uchar16 a, abacus_uchar16 b, abacus_uchar16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uchar16.
/// @param[in] b A abacus_uchar16.
/// @param[in] c A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API select(abacus_uchar16 a, abacus_uchar16 b, abacus_uchar16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_char16.
/// @param[in] b A abacus_char16.
/// @param[in] c A abacus_char16.
/// @return      A abacus_char16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_char16 ABACUS_EXPORT_API __abacus_bitselect(abacus_char16 a, abacus_char16 b, abacus_char16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_char16.
/// @param[in] b A abacus_char16.
/// @param[in] c A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API bitselect(abacus_char16 a, abacus_char16 b, abacus_char16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uchar16.
/// @param[in] b A abacus_uchar16.
/// @param[in] c A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_bitselect(abacus_uchar16 a, abacus_uchar16 b, abacus_uchar16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uchar16.
/// @param[in] b A abacus_uchar16.
/// @param[in] c A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API bitselect(abacus_uchar16 a, abacus_uchar16 b, abacus_uchar16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_char16.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_char16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_char16.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_char16 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_char16.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_char16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_char16.
/// @return      A abacus_char16.
inline abacus_int ABACUS_API all(abacus_char16 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short.
/// @param[in] b A abacus_short.
/// @param[in] c A abacus_short.
/// @return      A abacus_short.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short ABACUS_EXPORT_API __abacus_select(abacus_short a, abacus_short b, abacus_short c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short.
/// @param[in] b A abacus_short.
/// @param[in] c A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API select(abacus_short a, abacus_short b, abacus_short c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short.
/// @param[in] b A abacus_short.
/// @param[in] c A abacus_ushort.
/// @return      A abacus_short.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short ABACUS_EXPORT_API __abacus_select(abacus_short a, abacus_short b, abacus_ushort c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short.
/// @param[in] b A abacus_short.
/// @param[in] c A abacus_ushort.
/// @return      A abacus_short.
inline abacus_short ABACUS_API select(abacus_short a, abacus_short b, abacus_ushort c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort.
/// @param[in] b A abacus_ushort.
/// @param[in] c A abacus_short.
/// @return      A abacus_ushort.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort ABACUS_EXPORT_API __abacus_select(abacus_ushort a, abacus_ushort b, abacus_short c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort.
/// @param[in] b A abacus_ushort.
/// @param[in] c A abacus_short.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API select(abacus_ushort a, abacus_ushort b, abacus_short c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort.
/// @param[in] b A abacus_ushort.
/// @param[in] c A abacus_ushort.
/// @return      A abacus_ushort.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort ABACUS_EXPORT_API __abacus_select(abacus_ushort a, abacus_ushort b, abacus_ushort c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort.
/// @param[in] b A abacus_ushort.
/// @param[in] c A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API select(abacus_ushort a, abacus_ushort b, abacus_ushort c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_short.
/// @param[in] b A abacus_short.
/// @param[in] c A abacus_short.
/// @return      A abacus_short.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_short ABACUS_EXPORT_API __abacus_bitselect(abacus_short a, abacus_short b, abacus_short c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_short.
/// @param[in] b A abacus_short.
/// @param[in] c A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API bitselect(abacus_short a, abacus_short b, abacus_short c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ushort.
/// @param[in] b A abacus_ushort.
/// @param[in] c A abacus_ushort.
/// @return      A abacus_ushort.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ushort ABACUS_EXPORT_API __abacus_bitselect(abacus_ushort a, abacus_ushort b, abacus_ushort c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ushort.
/// @param[in] b A abacus_ushort.
/// @param[in] c A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API bitselect(abacus_ushort a, abacus_ushort b, abacus_ushort c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_short.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_short x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_short.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_short x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_short.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_short x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_short.
/// @return      A abacus_short.
inline abacus_int ABACUS_API all(abacus_short x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short2.
/// @param[in] b A abacus_short2.
/// @param[in] c A abacus_short2.
/// @return      A abacus_short2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short2 ABACUS_EXPORT_API __abacus_select(abacus_short2 a, abacus_short2 b, abacus_short2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short2.
/// @param[in] b A abacus_short2.
/// @param[in] c A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API select(abacus_short2 a, abacus_short2 b, abacus_short2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short2.
/// @param[in] b A abacus_short2.
/// @param[in] c A abacus_ushort2.
/// @return      A abacus_short2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short2 ABACUS_EXPORT_API __abacus_select(abacus_short2 a, abacus_short2 b, abacus_ushort2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short2.
/// @param[in] b A abacus_short2.
/// @param[in] c A abacus_ushort2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API select(abacus_short2 a, abacus_short2 b, abacus_ushort2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort2.
/// @param[in] b A abacus_ushort2.
/// @param[in] c A abacus_short2.
/// @return      A abacus_ushort2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_select(abacus_ushort2 a, abacus_ushort2 b, abacus_short2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort2.
/// @param[in] b A abacus_ushort2.
/// @param[in] c A abacus_short2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API select(abacus_ushort2 a, abacus_ushort2 b, abacus_short2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort2.
/// @param[in] b A abacus_ushort2.
/// @param[in] c A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_select(abacus_ushort2 a, abacus_ushort2 b, abacus_ushort2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort2.
/// @param[in] b A abacus_ushort2.
/// @param[in] c A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API select(abacus_ushort2 a, abacus_ushort2 b, abacus_ushort2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_short2.
/// @param[in] b A abacus_short2.
/// @param[in] c A abacus_short2.
/// @return      A abacus_short2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_short2 ABACUS_EXPORT_API __abacus_bitselect(abacus_short2 a, abacus_short2 b, abacus_short2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_short2.
/// @param[in] b A abacus_short2.
/// @param[in] c A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API bitselect(abacus_short2 a, abacus_short2 b, abacus_short2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ushort2.
/// @param[in] b A abacus_ushort2.
/// @param[in] c A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_bitselect(abacus_ushort2 a, abacus_ushort2 b, abacus_ushort2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ushort2.
/// @param[in] b A abacus_ushort2.
/// @param[in] c A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API bitselect(abacus_ushort2 a, abacus_ushort2 b, abacus_ushort2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_short2.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_short2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_short2.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_short2 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_short2.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_short2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_short2.
/// @return      A abacus_short2.
inline abacus_int ABACUS_API all(abacus_short2 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short3.
/// @param[in] b A abacus_short3.
/// @param[in] c A abacus_short3.
/// @return      A abacus_short3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short3 ABACUS_EXPORT_API __abacus_select(abacus_short3 a, abacus_short3 b, abacus_short3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short3.
/// @param[in] b A abacus_short3.
/// @param[in] c A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API select(abacus_short3 a, abacus_short3 b, abacus_short3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short3.
/// @param[in] b A abacus_short3.
/// @param[in] c A abacus_ushort3.
/// @return      A abacus_short3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short3 ABACUS_EXPORT_API __abacus_select(abacus_short3 a, abacus_short3 b, abacus_ushort3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short3.
/// @param[in] b A abacus_short3.
/// @param[in] c A abacus_ushort3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API select(abacus_short3 a, abacus_short3 b, abacus_ushort3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort3.
/// @param[in] b A abacus_ushort3.
/// @param[in] c A abacus_short3.
/// @return      A abacus_ushort3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_select(abacus_ushort3 a, abacus_ushort3 b, abacus_short3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort3.
/// @param[in] b A abacus_ushort3.
/// @param[in] c A abacus_short3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API select(abacus_ushort3 a, abacus_ushort3 b, abacus_short3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort3.
/// @param[in] b A abacus_ushort3.
/// @param[in] c A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_select(abacus_ushort3 a, abacus_ushort3 b, abacus_ushort3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort3.
/// @param[in] b A abacus_ushort3.
/// @param[in] c A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API select(abacus_ushort3 a, abacus_ushort3 b, abacus_ushort3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_short3.
/// @param[in] b A abacus_short3.
/// @param[in] c A abacus_short3.
/// @return      A abacus_short3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_short3 ABACUS_EXPORT_API __abacus_bitselect(abacus_short3 a, abacus_short3 b, abacus_short3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_short3.
/// @param[in] b A abacus_short3.
/// @param[in] c A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API bitselect(abacus_short3 a, abacus_short3 b, abacus_short3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ushort3.
/// @param[in] b A abacus_ushort3.
/// @param[in] c A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_bitselect(abacus_ushort3 a, abacus_ushort3 b, abacus_ushort3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ushort3.
/// @param[in] b A abacus_ushort3.
/// @param[in] c A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API bitselect(abacus_ushort3 a, abacus_ushort3 b, abacus_ushort3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_short3.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_short3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_short3.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_short3 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_short3.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_short3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_short3.
/// @return      A abacus_short3.
inline abacus_int ABACUS_API all(abacus_short3 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short4.
/// @param[in] b A abacus_short4.
/// @param[in] c A abacus_short4.
/// @return      A abacus_short4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short4 ABACUS_EXPORT_API __abacus_select(abacus_short4 a, abacus_short4 b, abacus_short4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short4.
/// @param[in] b A abacus_short4.
/// @param[in] c A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API select(abacus_short4 a, abacus_short4 b, abacus_short4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short4.
/// @param[in] b A abacus_short4.
/// @param[in] c A abacus_ushort4.
/// @return      A abacus_short4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short4 ABACUS_EXPORT_API __abacus_select(abacus_short4 a, abacus_short4 b, abacus_ushort4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short4.
/// @param[in] b A abacus_short4.
/// @param[in] c A abacus_ushort4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API select(abacus_short4 a, abacus_short4 b, abacus_ushort4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort4.
/// @param[in] b A abacus_ushort4.
/// @param[in] c A abacus_short4.
/// @return      A abacus_ushort4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_select(abacus_ushort4 a, abacus_ushort4 b, abacus_short4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort4.
/// @param[in] b A abacus_ushort4.
/// @param[in] c A abacus_short4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API select(abacus_ushort4 a, abacus_ushort4 b, abacus_short4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort4.
/// @param[in] b A abacus_ushort4.
/// @param[in] c A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_select(abacus_ushort4 a, abacus_ushort4 b, abacus_ushort4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort4.
/// @param[in] b A abacus_ushort4.
/// @param[in] c A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API select(abacus_ushort4 a, abacus_ushort4 b, abacus_ushort4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_short4.
/// @param[in] b A abacus_short4.
/// @param[in] c A abacus_short4.
/// @return      A abacus_short4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_short4 ABACUS_EXPORT_API __abacus_bitselect(abacus_short4 a, abacus_short4 b, abacus_short4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_short4.
/// @param[in] b A abacus_short4.
/// @param[in] c A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API bitselect(abacus_short4 a, abacus_short4 b, abacus_short4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ushort4.
/// @param[in] b A abacus_ushort4.
/// @param[in] c A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_bitselect(abacus_ushort4 a, abacus_ushort4 b, abacus_ushort4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ushort4.
/// @param[in] b A abacus_ushort4.
/// @param[in] c A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API bitselect(abacus_ushort4 a, abacus_ushort4 b, abacus_ushort4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_short4.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_short4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_short4.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_short4 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_short4.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_short4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_short4.
/// @return      A abacus_short4.
inline abacus_int ABACUS_API all(abacus_short4 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short8.
/// @param[in] b A abacus_short8.
/// @param[in] c A abacus_short8.
/// @return      A abacus_short8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short8 ABACUS_EXPORT_API __abacus_select(abacus_short8 a, abacus_short8 b, abacus_short8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short8.
/// @param[in] b A abacus_short8.
/// @param[in] c A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API select(abacus_short8 a, abacus_short8 b, abacus_short8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short8.
/// @param[in] b A abacus_short8.
/// @param[in] c A abacus_ushort8.
/// @return      A abacus_short8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short8 ABACUS_EXPORT_API __abacus_select(abacus_short8 a, abacus_short8 b, abacus_ushort8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short8.
/// @param[in] b A abacus_short8.
/// @param[in] c A abacus_ushort8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API select(abacus_short8 a, abacus_short8 b, abacus_ushort8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort8.
/// @param[in] b A abacus_ushort8.
/// @param[in] c A abacus_short8.
/// @return      A abacus_ushort8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_select(abacus_ushort8 a, abacus_ushort8 b, abacus_short8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort8.
/// @param[in] b A abacus_ushort8.
/// @param[in] c A abacus_short8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API select(abacus_ushort8 a, abacus_ushort8 b, abacus_short8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort8.
/// @param[in] b A abacus_ushort8.
/// @param[in] c A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_select(abacus_ushort8 a, abacus_ushort8 b, abacus_ushort8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort8.
/// @param[in] b A abacus_ushort8.
/// @param[in] c A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API select(abacus_ushort8 a, abacus_ushort8 b, abacus_ushort8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_short8.
/// @param[in] b A abacus_short8.
/// @param[in] c A abacus_short8.
/// @return      A abacus_short8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_short8 ABACUS_EXPORT_API __abacus_bitselect(abacus_short8 a, abacus_short8 b, abacus_short8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_short8.
/// @param[in] b A abacus_short8.
/// @param[in] c A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API bitselect(abacus_short8 a, abacus_short8 b, abacus_short8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ushort8.
/// @param[in] b A abacus_ushort8.
/// @param[in] c A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_bitselect(abacus_ushort8 a, abacus_ushort8 b, abacus_ushort8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ushort8.
/// @param[in] b A abacus_ushort8.
/// @param[in] c A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API bitselect(abacus_ushort8 a, abacus_ushort8 b, abacus_ushort8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_short8.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_short8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_short8.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_short8 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_short8.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_short8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_short8.
/// @return      A abacus_short8.
inline abacus_int ABACUS_API all(abacus_short8 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short16.
/// @param[in] b A abacus_short16.
/// @param[in] c A abacus_short16.
/// @return      A abacus_short16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short16 ABACUS_EXPORT_API __abacus_select(abacus_short16 a, abacus_short16 b, abacus_short16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short16.
/// @param[in] b A abacus_short16.
/// @param[in] c A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API select(abacus_short16 a, abacus_short16 b, abacus_short16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_short16.
/// @param[in] b A abacus_short16.
/// @param[in] c A abacus_ushort16.
/// @return      A abacus_short16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_short16 ABACUS_EXPORT_API __abacus_select(abacus_short16 a, abacus_short16 b, abacus_ushort16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_short16.
/// @param[in] b A abacus_short16.
/// @param[in] c A abacus_ushort16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API select(abacus_short16 a, abacus_short16 b, abacus_ushort16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort16.
/// @param[in] b A abacus_ushort16.
/// @param[in] c A abacus_short16.
/// @return      A abacus_ushort16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_select(abacus_ushort16 a, abacus_ushort16 b, abacus_short16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort16.
/// @param[in] b A abacus_ushort16.
/// @param[in] c A abacus_short16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API select(abacus_ushort16 a, abacus_ushort16 b, abacus_short16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ushort16.
/// @param[in] b A abacus_ushort16.
/// @param[in] c A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_select(abacus_ushort16 a, abacus_ushort16 b, abacus_ushort16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ushort16.
/// @param[in] b A abacus_ushort16.
/// @param[in] c A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API select(abacus_ushort16 a, abacus_ushort16 b, abacus_ushort16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_short16.
/// @param[in] b A abacus_short16.
/// @param[in] c A abacus_short16.
/// @return      A abacus_short16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_short16 ABACUS_EXPORT_API __abacus_bitselect(abacus_short16 a, abacus_short16 b, abacus_short16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_short16.
/// @param[in] b A abacus_short16.
/// @param[in] c A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API bitselect(abacus_short16 a, abacus_short16 b, abacus_short16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ushort16.
/// @param[in] b A abacus_ushort16.
/// @param[in] c A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_bitselect(abacus_ushort16 a, abacus_ushort16 b, abacus_ushort16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ushort16.
/// @param[in] b A abacus_ushort16.
/// @param[in] c A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API bitselect(abacus_ushort16 a, abacus_ushort16 b, abacus_ushort16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_short16.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_short16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_short16.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_short16 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_short16.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_short16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_short16.
/// @return      A abacus_short16.
inline abacus_int ABACUS_API all(abacus_short16 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int.
/// @param[in] b A abacus_int.
/// @param[in] c A abacus_int.
/// @return      A abacus_int.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int ABACUS_EXPORT_API __abacus_select(abacus_int a, abacus_int b, abacus_int c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int.
/// @param[in] b A abacus_int.
/// @param[in] c A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API select(abacus_int a, abacus_int b, abacus_int c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int.
/// @param[in] b A abacus_int.
/// @param[in] c A abacus_uint.
/// @return      A abacus_int.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int ABACUS_EXPORT_API __abacus_select(abacus_int a, abacus_int b, abacus_uint c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int.
/// @param[in] b A abacus_int.
/// @param[in] c A abacus_uint.
/// @return      A abacus_int.
inline abacus_int ABACUS_API select(abacus_int a, abacus_int b, abacus_uint c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint.
/// @param[in] b A abacus_uint.
/// @param[in] c A abacus_int.
/// @return      A abacus_uint.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint ABACUS_EXPORT_API __abacus_select(abacus_uint a, abacus_uint b, abacus_int c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint.
/// @param[in] b A abacus_uint.
/// @param[in] c A abacus_int.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API select(abacus_uint a, abacus_uint b, abacus_int c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint.
/// @param[in] b A abacus_uint.
/// @param[in] c A abacus_uint.
/// @return      A abacus_uint.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint ABACUS_EXPORT_API __abacus_select(abacus_uint a, abacus_uint b, abacus_uint c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint.
/// @param[in] b A abacus_uint.
/// @param[in] c A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API select(abacus_uint a, abacus_uint b, abacus_uint c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_int.
/// @param[in] b A abacus_int.
/// @param[in] c A abacus_int.
/// @return      A abacus_int.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_int ABACUS_EXPORT_API __abacus_bitselect(abacus_int a, abacus_int b, abacus_int c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_int.
/// @param[in] b A abacus_int.
/// @param[in] c A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API bitselect(abacus_int a, abacus_int b, abacus_int c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uint.
/// @param[in] b A abacus_uint.
/// @param[in] c A abacus_uint.
/// @return      A abacus_uint.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uint ABACUS_EXPORT_API __abacus_bitselect(abacus_uint a, abacus_uint b, abacus_uint c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uint.
/// @param[in] b A abacus_uint.
/// @param[in] c A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API bitselect(abacus_uint a, abacus_uint b, abacus_uint c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_int x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_int x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_int x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API all(abacus_int x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int2.
/// @param[in] b A abacus_int2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_int2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int2 ABACUS_EXPORT_API __abacus_select(abacus_int2 a, abacus_int2 b, abacus_int2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int2.
/// @param[in] b A abacus_int2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API select(abacus_int2 a, abacus_int2 b, abacus_int2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int2.
/// @param[in] b A abacus_int2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_int2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int2 ABACUS_EXPORT_API __abacus_select(abacus_int2 a, abacus_int2 b, abacus_uint2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int2.
/// @param[in] b A abacus_int2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API select(abacus_int2 a, abacus_int2 b, abacus_uint2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint2.
/// @param[in] b A abacus_uint2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_uint2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint2 ABACUS_EXPORT_API __abacus_select(abacus_uint2 a, abacus_uint2 b, abacus_int2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint2.
/// @param[in] b A abacus_uint2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API select(abacus_uint2 a, abacus_uint2 b, abacus_int2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint2.
/// @param[in] b A abacus_uint2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_uint2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint2 ABACUS_EXPORT_API __abacus_select(abacus_uint2 a, abacus_uint2 b, abacus_uint2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint2.
/// @param[in] b A abacus_uint2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API select(abacus_uint2 a, abacus_uint2 b, abacus_uint2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_int2.
/// @param[in] b A abacus_int2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_int2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_int2 ABACUS_EXPORT_API __abacus_bitselect(abacus_int2 a, abacus_int2 b, abacus_int2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_int2.
/// @param[in] b A abacus_int2.
/// @param[in] c A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API bitselect(abacus_int2 a, abacus_int2 b, abacus_int2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uint2.
/// @param[in] b A abacus_uint2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_uint2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uint2 ABACUS_EXPORT_API __abacus_bitselect(abacus_uint2 a, abacus_uint2 b, abacus_uint2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uint2.
/// @param[in] b A abacus_uint2.
/// @param[in] c A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API bitselect(abacus_uint2 a, abacus_uint2 b, abacus_uint2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_int2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_int2 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_int2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int ABACUS_API all(abacus_int2 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int3.
/// @param[in] b A abacus_int3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_int3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int3 ABACUS_EXPORT_API __abacus_select(abacus_int3 a, abacus_int3 b, abacus_int3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int3.
/// @param[in] b A abacus_int3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API select(abacus_int3 a, abacus_int3 b, abacus_int3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int3.
/// @param[in] b A abacus_int3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_int3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int3 ABACUS_EXPORT_API __abacus_select(abacus_int3 a, abacus_int3 b, abacus_uint3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int3.
/// @param[in] b A abacus_int3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API select(abacus_int3 a, abacus_int3 b, abacus_uint3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint3.
/// @param[in] b A abacus_uint3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_uint3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint3 ABACUS_EXPORT_API __abacus_select(abacus_uint3 a, abacus_uint3 b, abacus_int3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint3.
/// @param[in] b A abacus_uint3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API select(abacus_uint3 a, abacus_uint3 b, abacus_int3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint3.
/// @param[in] b A abacus_uint3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_uint3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint3 ABACUS_EXPORT_API __abacus_select(abacus_uint3 a, abacus_uint3 b, abacus_uint3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint3.
/// @param[in] b A abacus_uint3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API select(abacus_uint3 a, abacus_uint3 b, abacus_uint3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_int3.
/// @param[in] b A abacus_int3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_int3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_int3 ABACUS_EXPORT_API __abacus_bitselect(abacus_int3 a, abacus_int3 b, abacus_int3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_int3.
/// @param[in] b A abacus_int3.
/// @param[in] c A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API bitselect(abacus_int3 a, abacus_int3 b, abacus_int3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uint3.
/// @param[in] b A abacus_uint3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_uint3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uint3 ABACUS_EXPORT_API __abacus_bitselect(abacus_uint3 a, abacus_uint3 b, abacus_uint3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uint3.
/// @param[in] b A abacus_uint3.
/// @param[in] c A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API bitselect(abacus_uint3 a, abacus_uint3 b, abacus_uint3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_int3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_int3 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_int3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int ABACUS_API all(abacus_int3 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int4.
/// @param[in] b A abacus_int4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_int4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int4 ABACUS_EXPORT_API __abacus_select(abacus_int4 a, abacus_int4 b, abacus_int4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int4.
/// @param[in] b A abacus_int4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API select(abacus_int4 a, abacus_int4 b, abacus_int4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int4.
/// @param[in] b A abacus_int4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_int4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int4 ABACUS_EXPORT_API __abacus_select(abacus_int4 a, abacus_int4 b, abacus_uint4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int4.
/// @param[in] b A abacus_int4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API select(abacus_int4 a, abacus_int4 b, abacus_uint4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint4.
/// @param[in] b A abacus_uint4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_uint4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint4 ABACUS_EXPORT_API __abacus_select(abacus_uint4 a, abacus_uint4 b, abacus_int4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint4.
/// @param[in] b A abacus_uint4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API select(abacus_uint4 a, abacus_uint4 b, abacus_int4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint4.
/// @param[in] b A abacus_uint4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_uint4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint4 ABACUS_EXPORT_API __abacus_select(abacus_uint4 a, abacus_uint4 b, abacus_uint4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint4.
/// @param[in] b A abacus_uint4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API select(abacus_uint4 a, abacus_uint4 b, abacus_uint4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_int4.
/// @param[in] b A abacus_int4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_int4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_int4 ABACUS_EXPORT_API __abacus_bitselect(abacus_int4 a, abacus_int4 b, abacus_int4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_int4.
/// @param[in] b A abacus_int4.
/// @param[in] c A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API bitselect(abacus_int4 a, abacus_int4 b, abacus_int4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uint4.
/// @param[in] b A abacus_uint4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_uint4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uint4 ABACUS_EXPORT_API __abacus_bitselect(abacus_uint4 a, abacus_uint4 b, abacus_uint4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uint4.
/// @param[in] b A abacus_uint4.
/// @param[in] c A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API bitselect(abacus_uint4 a, abacus_uint4 b, abacus_uint4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_int4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_int4 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_int4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int ABACUS_API all(abacus_int4 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int8.
/// @param[in] b A abacus_int8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_int8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int8 ABACUS_EXPORT_API __abacus_select(abacus_int8 a, abacus_int8 b, abacus_int8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int8.
/// @param[in] b A abacus_int8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API select(abacus_int8 a, abacus_int8 b, abacus_int8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int8.
/// @param[in] b A abacus_int8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_int8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int8 ABACUS_EXPORT_API __abacus_select(abacus_int8 a, abacus_int8 b, abacus_uint8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int8.
/// @param[in] b A abacus_int8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API select(abacus_int8 a, abacus_int8 b, abacus_uint8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint8.
/// @param[in] b A abacus_uint8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_uint8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint8 ABACUS_EXPORT_API __abacus_select(abacus_uint8 a, abacus_uint8 b, abacus_int8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint8.
/// @param[in] b A abacus_uint8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API select(abacus_uint8 a, abacus_uint8 b, abacus_int8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint8.
/// @param[in] b A abacus_uint8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_uint8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint8 ABACUS_EXPORT_API __abacus_select(abacus_uint8 a, abacus_uint8 b, abacus_uint8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint8.
/// @param[in] b A abacus_uint8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API select(abacus_uint8 a, abacus_uint8 b, abacus_uint8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_int8.
/// @param[in] b A abacus_int8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_int8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_int8 ABACUS_EXPORT_API __abacus_bitselect(abacus_int8 a, abacus_int8 b, abacus_int8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_int8.
/// @param[in] b A abacus_int8.
/// @param[in] c A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API bitselect(abacus_int8 a, abacus_int8 b, abacus_int8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uint8.
/// @param[in] b A abacus_uint8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_uint8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uint8 ABACUS_EXPORT_API __abacus_bitselect(abacus_uint8 a, abacus_uint8 b, abacus_uint8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uint8.
/// @param[in] b A abacus_uint8.
/// @param[in] c A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API bitselect(abacus_uint8 a, abacus_uint8 b, abacus_uint8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_int8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_int8 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_int8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int ABACUS_API all(abacus_int8 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int16.
/// @param[in] b A abacus_int16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_int16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int16 ABACUS_EXPORT_API __abacus_select(abacus_int16 a, abacus_int16 b, abacus_int16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int16.
/// @param[in] b A abacus_int16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API select(abacus_int16 a, abacus_int16 b, abacus_int16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_int16.
/// @param[in] b A abacus_int16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_int16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_int16 ABACUS_EXPORT_API __abacus_select(abacus_int16 a, abacus_int16 b, abacus_uint16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_int16.
/// @param[in] b A abacus_int16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API select(abacus_int16 a, abacus_int16 b, abacus_uint16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint16.
/// @param[in] b A abacus_uint16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_uint16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint16 ABACUS_EXPORT_API __abacus_select(abacus_uint16 a, abacus_uint16 b, abacus_int16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint16.
/// @param[in] b A abacus_uint16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API select(abacus_uint16 a, abacus_uint16 b, abacus_int16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_uint16.
/// @param[in] b A abacus_uint16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_uint16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_uint16 ABACUS_EXPORT_API __abacus_select(abacus_uint16 a, abacus_uint16 b, abacus_uint16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_uint16.
/// @param[in] b A abacus_uint16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API select(abacus_uint16 a, abacus_uint16 b, abacus_uint16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_int16.
/// @param[in] b A abacus_int16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_int16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_int16 ABACUS_EXPORT_API __abacus_bitselect(abacus_int16 a, abacus_int16 b, abacus_int16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_int16.
/// @param[in] b A abacus_int16.
/// @param[in] c A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API bitselect(abacus_int16 a, abacus_int16 b, abacus_int16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_uint16.
/// @param[in] b A abacus_uint16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_uint16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_uint16 ABACUS_EXPORT_API __abacus_bitselect(abacus_uint16 a, abacus_uint16 b, abacus_uint16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_uint16.
/// @param[in] b A abacus_uint16.
/// @param[in] c A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API bitselect(abacus_uint16 a, abacus_uint16 b, abacus_uint16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_int16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_int16 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_int16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int ABACUS_API all(abacus_int16 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long.
/// @param[in] b A abacus_long.
/// @param[in] c A abacus_long.
/// @return      A abacus_long.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long ABACUS_EXPORT_API __abacus_select(abacus_long a, abacus_long b, abacus_long c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long.
/// @param[in] b A abacus_long.
/// @param[in] c A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API select(abacus_long a, abacus_long b, abacus_long c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long.
/// @param[in] b A abacus_long.
/// @param[in] c A abacus_ulong.
/// @return      A abacus_long.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long ABACUS_EXPORT_API __abacus_select(abacus_long a, abacus_long b, abacus_ulong c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long.
/// @param[in] b A abacus_long.
/// @param[in] c A abacus_ulong.
/// @return      A abacus_long.
inline abacus_long ABACUS_API select(abacus_long a, abacus_long b, abacus_ulong c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong.
/// @param[in] b A abacus_ulong.
/// @param[in] c A abacus_long.
/// @return      A abacus_ulong.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong ABACUS_EXPORT_API __abacus_select(abacus_ulong a, abacus_ulong b, abacus_long c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong.
/// @param[in] b A abacus_ulong.
/// @param[in] c A abacus_long.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API select(abacus_ulong a, abacus_ulong b, abacus_long c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong.
/// @param[in] b A abacus_ulong.
/// @param[in] c A abacus_ulong.
/// @return      A abacus_ulong.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong ABACUS_EXPORT_API __abacus_select(abacus_ulong a, abacus_ulong b, abacus_ulong c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong.
/// @param[in] b A abacus_ulong.
/// @param[in] c A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API select(abacus_ulong a, abacus_ulong b, abacus_ulong c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_long.
/// @param[in] b A abacus_long.
/// @param[in] c A abacus_long.
/// @return      A abacus_long.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_long ABACUS_EXPORT_API __abacus_bitselect(abacus_long a, abacus_long b, abacus_long c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_long.
/// @param[in] b A abacus_long.
/// @param[in] c A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API bitselect(abacus_long a, abacus_long b, abacus_long c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ulong.
/// @param[in] b A abacus_ulong.
/// @param[in] c A abacus_ulong.
/// @return      A abacus_ulong.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ulong ABACUS_EXPORT_API __abacus_bitselect(abacus_ulong a, abacus_ulong b, abacus_ulong c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ulong.
/// @param[in] b A abacus_ulong.
/// @param[in] c A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API bitselect(abacus_ulong a, abacus_ulong b, abacus_ulong c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_long.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_long x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_long.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_long x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_long.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_long x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_long.
/// @return      A abacus_long.
inline abacus_int ABACUS_API all(abacus_long x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long2.
/// @param[in] b A abacus_long2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_long2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long2 ABACUS_EXPORT_API __abacus_select(abacus_long2 a, abacus_long2 b, abacus_long2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long2.
/// @param[in] b A abacus_long2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API select(abacus_long2 a, abacus_long2 b, abacus_long2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long2.
/// @param[in] b A abacus_long2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_long2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long2 ABACUS_EXPORT_API __abacus_select(abacus_long2 a, abacus_long2 b, abacus_ulong2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long2.
/// @param[in] b A abacus_long2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API select(abacus_long2 a, abacus_long2 b, abacus_ulong2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong2.
/// @param[in] b A abacus_ulong2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_ulong2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_select(abacus_ulong2 a, abacus_ulong2 b, abacus_long2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong2.
/// @param[in] b A abacus_ulong2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API select(abacus_ulong2 a, abacus_ulong2 b, abacus_long2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong2.
/// @param[in] b A abacus_ulong2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_select(abacus_ulong2 a, abacus_ulong2 b, abacus_ulong2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong2.
/// @param[in] b A abacus_ulong2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API select(abacus_ulong2 a, abacus_ulong2 b, abacus_ulong2 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_long2.
/// @param[in] b A abacus_long2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_long2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_long2 ABACUS_EXPORT_API __abacus_bitselect(abacus_long2 a, abacus_long2 b, abacus_long2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_long2.
/// @param[in] b A abacus_long2.
/// @param[in] c A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API bitselect(abacus_long2 a, abacus_long2 b, abacus_long2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ulong2.
/// @param[in] b A abacus_ulong2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_bitselect(abacus_ulong2 a, abacus_ulong2 b, abacus_ulong2 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ulong2.
/// @param[in] b A abacus_ulong2.
/// @param[in] c A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API bitselect(abacus_ulong2 a, abacus_ulong2 b, abacus_ulong2 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_long2.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_long2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_long2.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_long2 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_long2.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_long2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_long2.
/// @return      A abacus_long2.
inline abacus_int ABACUS_API all(abacus_long2 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long3.
/// @param[in] b A abacus_long3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_long3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long3 ABACUS_EXPORT_API __abacus_select(abacus_long3 a, abacus_long3 b, abacus_long3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long3.
/// @param[in] b A abacus_long3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API select(abacus_long3 a, abacus_long3 b, abacus_long3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long3.
/// @param[in] b A abacus_long3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_long3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long3 ABACUS_EXPORT_API __abacus_select(abacus_long3 a, abacus_long3 b, abacus_ulong3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long3.
/// @param[in] b A abacus_long3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API select(abacus_long3 a, abacus_long3 b, abacus_ulong3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong3.
/// @param[in] b A abacus_ulong3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_ulong3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_select(abacus_ulong3 a, abacus_ulong3 b, abacus_long3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong3.
/// @param[in] b A abacus_ulong3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API select(abacus_ulong3 a, abacus_ulong3 b, abacus_long3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong3.
/// @param[in] b A abacus_ulong3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_select(abacus_ulong3 a, abacus_ulong3 b, abacus_ulong3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong3.
/// @param[in] b A abacus_ulong3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API select(abacus_ulong3 a, abacus_ulong3 b, abacus_ulong3 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_long3.
/// @param[in] b A abacus_long3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_long3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_long3 ABACUS_EXPORT_API __abacus_bitselect(abacus_long3 a, abacus_long3 b, abacus_long3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_long3.
/// @param[in] b A abacus_long3.
/// @param[in] c A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API bitselect(abacus_long3 a, abacus_long3 b, abacus_long3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ulong3.
/// @param[in] b A abacus_ulong3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_bitselect(abacus_ulong3 a, abacus_ulong3 b, abacus_ulong3 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ulong3.
/// @param[in] b A abacus_ulong3.
/// @param[in] c A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API bitselect(abacus_ulong3 a, abacus_ulong3 b, abacus_ulong3 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_long3.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_long3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_long3.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_long3 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_long3.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_long3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_long3.
/// @return      A abacus_long3.
inline abacus_int ABACUS_API all(abacus_long3 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long4.
/// @param[in] b A abacus_long4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_long4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long4 ABACUS_EXPORT_API __abacus_select(abacus_long4 a, abacus_long4 b, abacus_long4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long4.
/// @param[in] b A abacus_long4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API select(abacus_long4 a, abacus_long4 b, abacus_long4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long4.
/// @param[in] b A abacus_long4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_long4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long4 ABACUS_EXPORT_API __abacus_select(abacus_long4 a, abacus_long4 b, abacus_ulong4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long4.
/// @param[in] b A abacus_long4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API select(abacus_long4 a, abacus_long4 b, abacus_ulong4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong4.
/// @param[in] b A abacus_ulong4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_ulong4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_select(abacus_ulong4 a, abacus_ulong4 b, abacus_long4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong4.
/// @param[in] b A abacus_ulong4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API select(abacus_ulong4 a, abacus_ulong4 b, abacus_long4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong4.
/// @param[in] b A abacus_ulong4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_select(abacus_ulong4 a, abacus_ulong4 b, abacus_ulong4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong4.
/// @param[in] b A abacus_ulong4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API select(abacus_ulong4 a, abacus_ulong4 b, abacus_ulong4 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_long4.
/// @param[in] b A abacus_long4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_long4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_long4 ABACUS_EXPORT_API __abacus_bitselect(abacus_long4 a, abacus_long4 b, abacus_long4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_long4.
/// @param[in] b A abacus_long4.
/// @param[in] c A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API bitselect(abacus_long4 a, abacus_long4 b, abacus_long4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ulong4.
/// @param[in] b A abacus_ulong4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_bitselect(abacus_ulong4 a, abacus_ulong4 b, abacus_ulong4 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ulong4.
/// @param[in] b A abacus_ulong4.
/// @param[in] c A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API bitselect(abacus_ulong4 a, abacus_ulong4 b, abacus_ulong4 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_long4.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_long4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_long4.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_long4 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_long4.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_long4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_long4.
/// @return      A abacus_long4.
inline abacus_int ABACUS_API all(abacus_long4 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long8.
/// @param[in] b A abacus_long8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_long8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long8 ABACUS_EXPORT_API __abacus_select(abacus_long8 a, abacus_long8 b, abacus_long8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long8.
/// @param[in] b A abacus_long8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API select(abacus_long8 a, abacus_long8 b, abacus_long8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long8.
/// @param[in] b A abacus_long8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_long8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long8 ABACUS_EXPORT_API __abacus_select(abacus_long8 a, abacus_long8 b, abacus_ulong8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long8.
/// @param[in] b A abacus_long8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API select(abacus_long8 a, abacus_long8 b, abacus_ulong8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong8.
/// @param[in] b A abacus_ulong8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_ulong8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_select(abacus_ulong8 a, abacus_ulong8 b, abacus_long8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong8.
/// @param[in] b A abacus_ulong8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API select(abacus_ulong8 a, abacus_ulong8 b, abacus_long8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong8.
/// @param[in] b A abacus_ulong8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_select(abacus_ulong8 a, abacus_ulong8 b, abacus_ulong8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong8.
/// @param[in] b A abacus_ulong8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API select(abacus_ulong8 a, abacus_ulong8 b, abacus_ulong8 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_long8.
/// @param[in] b A abacus_long8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_long8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_long8 ABACUS_EXPORT_API __abacus_bitselect(abacus_long8 a, abacus_long8 b, abacus_long8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_long8.
/// @param[in] b A abacus_long8.
/// @param[in] c A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API bitselect(abacus_long8 a, abacus_long8 b, abacus_long8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ulong8.
/// @param[in] b A abacus_ulong8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_bitselect(abacus_ulong8 a, abacus_ulong8 b, abacus_ulong8 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ulong8.
/// @param[in] b A abacus_ulong8.
/// @param[in] c A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API bitselect(abacus_ulong8 a, abacus_ulong8 b, abacus_ulong8 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_long8.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_long8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_long8.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_long8 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_long8.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_long8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_long8.
/// @return      A abacus_long8.
inline abacus_int ABACUS_API all(abacus_long8 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long16.
/// @param[in] b A abacus_long16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_long16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long16 ABACUS_EXPORT_API __abacus_select(abacus_long16 a, abacus_long16 b, abacus_long16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long16.
/// @param[in] b A abacus_long16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API select(abacus_long16 a, abacus_long16 b, abacus_long16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_long16.
/// @param[in] b A abacus_long16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_long16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_long16 ABACUS_EXPORT_API __abacus_select(abacus_long16 a, abacus_long16 b, abacus_ulong16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_long16.
/// @param[in] b A abacus_long16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API select(abacus_long16 a, abacus_long16 b, abacus_ulong16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong16.
/// @param[in] b A abacus_ulong16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_ulong16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_select(abacus_ulong16 a, abacus_ulong16 b, abacus_long16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong16.
/// @param[in] b A abacus_ulong16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API select(abacus_ulong16 a, abacus_ulong16 b, abacus_long16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_ulong16.
/// @param[in] b A abacus_ulong16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_select(abacus_ulong16 a, abacus_ulong16 b, abacus_ulong16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_ulong16.
/// @param[in] b A abacus_ulong16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API select(abacus_ulong16 a, abacus_ulong16 b, abacus_ulong16 c) {
  return __abacus_select(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_long16.
/// @param[in] b A abacus_long16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_long16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_long16 ABACUS_EXPORT_API __abacus_bitselect(abacus_long16 a, abacus_long16 b, abacus_long16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_long16.
/// @param[in] b A abacus_long16.
/// @param[in] c A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API bitselect(abacus_long16 a, abacus_long16 b, abacus_long16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_ulong16.
/// @param[in] b A abacus_ulong16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_bitselect(abacus_ulong16 a, abacus_ulong16 b, abacus_ulong16 c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_ulong16.
/// @param[in] b A abacus_ulong16.
/// @param[in] c A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API bitselect(abacus_ulong16 a, abacus_ulong16 b, abacus_ulong16 c) {
  return __abacus_bitselect(a, b, c);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Any most significant bit is set.
/// @param[in] x A abacus_long16.
/// @return      A abacus_int.
///
/// Any of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 any.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_any(abacus_long16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_any.
/// @param[in] x A abacus_long16.
/// @return      A abacus_int.
inline abacus_int ABACUS_API any(abacus_long16 x) {
  return __abacus_any(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief All most significant bit is set.
/// @param[in] x A abacus_long16.
/// @return      A abacus_int.
///
/// All of the elements in @a x have most significant bit set.
///
/// Standards compliant implementation of OpenCL 1.2 all.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/any.html
abacus_int ABACUS_EXPORT_API __abacus_all(abacus_long16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_all.
/// @param[in] x A abacus_long16.
/// @return      A abacus_long16.
inline abacus_int ABACUS_API all(abacus_long16 x) {
  return __abacus_all(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif




/// @}
////////////////////////////////////////////////////////////////////////////////

#endif  //__ABACUS_ABACUS_RELATIONAL__
