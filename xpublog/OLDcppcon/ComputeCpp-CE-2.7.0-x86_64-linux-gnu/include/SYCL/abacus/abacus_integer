/******************************************************************************

    Copyright (C) 2002-2016 Codeplay Software Limited
    All Rights Reserved.

    Codeplay's ComputeCpp

*******************************************************************************/

/*!
  @file abacus_integer

  @brief Abacus integer built-ins.
*/

#ifndef __ABACUS_ABACUS_INTEGER__
#define __ABACUS_ABACUS_INTEGER__

#ifndef __ABACUS_ABACUS_CONFIG__
#include <abacus/abacus_config>
#endif

////////////////////////////////////////////////////////////////////////////////
/// @defgroup abacus_integer abacus_integer
/// @{

/// @brief |x|
/// @param[in] x A abacus_char.
/// @return      A abacus_uchar.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar ABACUS_EXPORT_API __abacus_abs(abacus_char x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_char.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API abs(abacus_char x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uchar.
/// @return      A abacus_uchar.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar ABACUS_EXPORT_API __abacus_abs(abacus_uchar x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API abs(abacus_uchar x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_uchar.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar ABACUS_EXPORT_API __abacus_abs_diff(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API abs_diff(abacus_char x, abacus_char y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar ABACUS_EXPORT_API __abacus_abs_diff(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API abs_diff(abacus_uchar x, abacus_uchar y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_char2.
/// @return      A abacus_uchar2.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_abs(abacus_char2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_char2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API abs(abacus_char2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_abs(abacus_uchar2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API abs(abacus_uchar2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_uchar2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API abs_diff(abacus_char2 x, abacus_char2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API abs_diff(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_char3.
/// @return      A abacus_uchar3.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_abs(abacus_char3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_char3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API abs(abacus_char3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_abs(abacus_uchar3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API abs(abacus_uchar3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_uchar3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API abs_diff(abacus_char3 x, abacus_char3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API abs_diff(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_char4.
/// @return      A abacus_uchar4.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_abs(abacus_char4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_char4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API abs(abacus_char4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_abs(abacus_uchar4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API abs(abacus_uchar4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_uchar4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API abs_diff(abacus_char4 x, abacus_char4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API abs_diff(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_char8.
/// @return      A abacus_uchar8.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_abs(abacus_char8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_char8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API abs(abacus_char8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_abs(abacus_uchar8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API abs(abacus_uchar8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_uchar8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API abs_diff(abacus_char8 x, abacus_char8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API abs_diff(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_char16.
/// @return      A abacus_uchar16.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_abs(abacus_char16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_char16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API abs(abacus_char16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_abs(abacus_uchar16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API abs(abacus_uchar16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_uchar16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API abs_diff(abacus_char16 x, abacus_char16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API abs_diff(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_short.
/// @return      A abacus_ushort.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort ABACUS_EXPORT_API __abacus_abs(abacus_short x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_short.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API abs(abacus_short x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ushort.
/// @return      A abacus_ushort.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort ABACUS_EXPORT_API __abacus_abs(abacus_ushort x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API abs(abacus_ushort x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_ushort.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort ABACUS_EXPORT_API __abacus_abs_diff(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API abs_diff(abacus_short x, abacus_short y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort ABACUS_EXPORT_API __abacus_abs_diff(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API abs_diff(abacus_ushort x, abacus_ushort y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_short2.
/// @return      A abacus_ushort2.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_abs(abacus_short2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_short2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API abs(abacus_short2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_abs(abacus_ushort2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API abs(abacus_ushort2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_ushort2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API abs_diff(abacus_short2 x, abacus_short2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API abs_diff(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_short3.
/// @return      A abacus_ushort3.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_abs(abacus_short3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_short3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API abs(abacus_short3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_abs(abacus_ushort3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API abs(abacus_ushort3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_ushort3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API abs_diff(abacus_short3 x, abacus_short3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API abs_diff(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_short4.
/// @return      A abacus_ushort4.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_abs(abacus_short4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_short4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API abs(abacus_short4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_abs(abacus_ushort4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API abs(abacus_ushort4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_ushort4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API abs_diff(abacus_short4 x, abacus_short4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API abs_diff(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_short8.
/// @return      A abacus_ushort8.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_abs(abacus_short8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_short8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API abs(abacus_short8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_abs(abacus_ushort8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API abs(abacus_ushort8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_ushort8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API abs_diff(abacus_short8 x, abacus_short8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API abs_diff(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_short16.
/// @return      A abacus_ushort16.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_abs(abacus_short16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_short16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API abs(abacus_short16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_abs(abacus_ushort16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API abs(abacus_ushort16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_ushort16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API abs_diff(abacus_short16 x, abacus_short16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API abs_diff(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_int.
/// @return      A abacus_uint.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint ABACUS_EXPORT_API __abacus_abs(abacus_int x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_int.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API abs(abacus_int x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uint.
/// @return      A abacus_uint.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint ABACUS_EXPORT_API __abacus_abs(abacus_uint x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API abs(abacus_uint x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_uint.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint ABACUS_EXPORT_API __abacus_abs_diff(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API abs_diff(abacus_int x, abacus_int y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint ABACUS_EXPORT_API __abacus_abs_diff(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API abs_diff(abacus_uint x, abacus_uint y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_int2.
/// @return      A abacus_uint2.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint2 ABACUS_EXPORT_API __abacus_abs(abacus_int2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_int2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API abs(abacus_int2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uint2.
/// @return      A abacus_uint2.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint2 ABACUS_EXPORT_API __abacus_abs(abacus_uint2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API abs(abacus_uint2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_uint2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API abs_diff(abacus_int2 x, abacus_int2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API abs_diff(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_int3.
/// @return      A abacus_uint3.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint3 ABACUS_EXPORT_API __abacus_abs(abacus_int3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_int3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API abs(abacus_int3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uint3.
/// @return      A abacus_uint3.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint3 ABACUS_EXPORT_API __abacus_abs(abacus_uint3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API abs(abacus_uint3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_uint3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API abs_diff(abacus_int3 x, abacus_int3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API abs_diff(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_int4.
/// @return      A abacus_uint4.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint4 ABACUS_EXPORT_API __abacus_abs(abacus_int4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_int4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API abs(abacus_int4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uint4.
/// @return      A abacus_uint4.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint4 ABACUS_EXPORT_API __abacus_abs(abacus_uint4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API abs(abacus_uint4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_uint4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API abs_diff(abacus_int4 x, abacus_int4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API abs_diff(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_int8.
/// @return      A abacus_uint8.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint8 ABACUS_EXPORT_API __abacus_abs(abacus_int8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_int8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API abs(abacus_int8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uint8.
/// @return      A abacus_uint8.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint8 ABACUS_EXPORT_API __abacus_abs(abacus_uint8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API abs(abacus_uint8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_uint8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API abs_diff(abacus_int8 x, abacus_int8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API abs_diff(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_int16.
/// @return      A abacus_uint16.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint16 ABACUS_EXPORT_API __abacus_abs(abacus_int16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_int16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API abs(abacus_int16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_uint16.
/// @return      A abacus_uint16.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint16 ABACUS_EXPORT_API __abacus_abs(abacus_uint16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API abs(abacus_uint16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_uint16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API abs_diff(abacus_int16 x, abacus_int16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_uint16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API abs_diff(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_long.
/// @return      A abacus_ulong.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong ABACUS_EXPORT_API __abacus_abs(abacus_long x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_long.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API abs(abacus_long x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ulong.
/// @return      A abacus_ulong.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong ABACUS_EXPORT_API __abacus_abs(abacus_ulong x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API abs(abacus_ulong x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_ulong.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong ABACUS_EXPORT_API __abacus_abs_diff(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API abs_diff(abacus_long x, abacus_long y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong ABACUS_EXPORT_API __abacus_abs_diff(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API abs_diff(abacus_ulong x, abacus_ulong y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_long2.
/// @return      A abacus_ulong2.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_abs(abacus_long2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_long2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API abs(abacus_long2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_abs(abacus_ulong2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API abs(abacus_ulong2 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_ulong2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API abs_diff(abacus_long2 x, abacus_long2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API abs_diff(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_long3.
/// @return      A abacus_ulong3.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_abs(abacus_long3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_long3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API abs(abacus_long3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_abs(abacus_ulong3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API abs(abacus_ulong3 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_ulong3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API abs_diff(abacus_long3 x, abacus_long3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API abs_diff(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_long4.
/// @return      A abacus_ulong4.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_abs(abacus_long4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_long4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API abs(abacus_long4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_abs(abacus_ulong4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API abs(abacus_ulong4 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_ulong4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API abs_diff(abacus_long4 x, abacus_long4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API abs_diff(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_long8.
/// @return      A abacus_ulong8.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_abs(abacus_long8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_long8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API abs(abacus_long8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_abs(abacus_ulong8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API abs(abacus_ulong8 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_ulong8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API abs_diff(abacus_long8 x, abacus_long8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API abs_diff(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief |x|
/// @param[in] x A abacus_long16.
/// @return      A abacus_ulong16.
///
/// The absolute value of x.
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_abs(abacus_long16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_long16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API abs(abacus_long16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief x
/// @param[in] x A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// The absolute value of x (which is x since x is an unsigned type).
///
/// Standards compliant implementation of OpenCL 1.2 abs.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_abs(abacus_ulong16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs.
/// @param[in] x A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API abs(abacus_ulong16 x) {
  return __abacus_abs(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_ulong16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API abs_diff(abacus_long16 x, abacus_long16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief |x - y| without modulo overflow.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// The absolute value of x - y, without module overflow.
///
/// Standards compliant implementation of OpenCL 1.2 abs_diff.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/abs.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_abs_diff(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_abs_diff.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API abs_diff(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_abs_diff(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_char ABACUS_EXPORT_API __abacus_add_sat(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API add_sat(abacus_char x, abacus_char y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_char.
/// @return      A abacus_char.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_char ABACUS_EXPORT_API __abacus_clz(abacus_char x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API clz(abacus_char x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char ABACUS_EXPORT_API __abacus_clamp(abacus_char x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API clamp(abacus_char x, abacus_char y, abacus_char z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char ABACUS_EXPORT_API __abacus_hadd(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API hadd(abacus_char x, abacus_char y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char ABACUS_EXPORT_API __abacus_max(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API max(abacus_char x, abacus_char y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char ABACUS_EXPORT_API __abacus_min(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API min(abacus_char x, abacus_char y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_char ABACUS_EXPORT_API __abacus_mad_hi(abacus_char x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API mad_hi(abacus_char x, abacus_char y, abacus_char z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_char ABACUS_EXPORT_API __abacus_mad_sat(abacus_char x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API mad_sat(abacus_char x, abacus_char y, abacus_char z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_char ABACUS_EXPORT_API __abacus_mul_hi(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API mul_hi(abacus_char x, abacus_char y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_char.
/// @return      A abacus_char.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_char ABACUS_EXPORT_API __abacus_popcount(abacus_char x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API popcount(abacus_char x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char ABACUS_EXPORT_API __abacus_rhadd(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API rhadd(abacus_char x, abacus_char y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_char ABACUS_EXPORT_API __abacus_rotate(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API rotate(abacus_char x, abacus_char y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_char ABACUS_EXPORT_API __abacus_sub_sat(abacus_char x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_char.
/// @param[in] y A abacus_char.
/// @return      A abacus_char.
inline abacus_char ABACUS_API sub_sat(abacus_char x, abacus_char y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_char2 ABACUS_EXPORT_API __abacus_add_sat(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API add_sat(abacus_char2 x, abacus_char2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_char2.
/// @return      A abacus_char2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_char2 ABACUS_EXPORT_API __abacus_clz(abacus_char2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API clz(abacus_char2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @param[in] z A abacus_char2.
/// @return      A abacus_char2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char2 ABACUS_EXPORT_API __abacus_clamp(abacus_char2 x, abacus_char2 y, abacus_char2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @param[in] z A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API clamp(abacus_char2 x, abacus_char2 y, abacus_char2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char2 ABACUS_EXPORT_API __abacus_hadd(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API hadd(abacus_char2 x, abacus_char2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char2 ABACUS_EXPORT_API __abacus_max(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API max(abacus_char2 x, abacus_char2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char2 ABACUS_EXPORT_API __abacus_min(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API min(abacus_char2 x, abacus_char2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @param[in] z A abacus_char2.
/// @return      A abacus_char2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_char2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_char2 x, abacus_char2 y, abacus_char2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @param[in] z A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API mad_hi(abacus_char2 x, abacus_char2 y, abacus_char2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @param[in] z A abacus_char2.
/// @return      A abacus_char2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_char2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_char2 x, abacus_char2 y, abacus_char2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @param[in] z A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API mad_sat(abacus_char2 x, abacus_char2 y, abacus_char2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_char2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API mul_hi(abacus_char2 x, abacus_char2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_char2.
/// @return      A abacus_char2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_char2 ABACUS_EXPORT_API __abacus_popcount(abacus_char2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API popcount(abacus_char2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char2 ABACUS_EXPORT_API __abacus_rhadd(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API rhadd(abacus_char2 x, abacus_char2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_char2 ABACUS_EXPORT_API __abacus_rotate(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API rotate(abacus_char2 x, abacus_char2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_char2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_char2 x, abacus_char2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char2.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API sub_sat(abacus_char2 x, abacus_char2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_char3 ABACUS_EXPORT_API __abacus_add_sat(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API add_sat(abacus_char3 x, abacus_char3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_char3.
/// @return      A abacus_char3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_char3 ABACUS_EXPORT_API __abacus_clz(abacus_char3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API clz(abacus_char3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @param[in] z A abacus_char3.
/// @return      A abacus_char3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char3 ABACUS_EXPORT_API __abacus_clamp(abacus_char3 x, abacus_char3 y, abacus_char3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @param[in] z A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API clamp(abacus_char3 x, abacus_char3 y, abacus_char3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char3 ABACUS_EXPORT_API __abacus_hadd(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API hadd(abacus_char3 x, abacus_char3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char3 ABACUS_EXPORT_API __abacus_max(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API max(abacus_char3 x, abacus_char3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char3 ABACUS_EXPORT_API __abacus_min(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API min(abacus_char3 x, abacus_char3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @param[in] z A abacus_char3.
/// @return      A abacus_char3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_char3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_char3 x, abacus_char3 y, abacus_char3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @param[in] z A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API mad_hi(abacus_char3 x, abacus_char3 y, abacus_char3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @param[in] z A abacus_char3.
/// @return      A abacus_char3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_char3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_char3 x, abacus_char3 y, abacus_char3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @param[in] z A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API mad_sat(abacus_char3 x, abacus_char3 y, abacus_char3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_char3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API mul_hi(abacus_char3 x, abacus_char3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_char3.
/// @return      A abacus_char3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_char3 ABACUS_EXPORT_API __abacus_popcount(abacus_char3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API popcount(abacus_char3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char3 ABACUS_EXPORT_API __abacus_rhadd(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API rhadd(abacus_char3 x, abacus_char3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_char3 ABACUS_EXPORT_API __abacus_rotate(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API rotate(abacus_char3 x, abacus_char3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_char3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_char3 x, abacus_char3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char3.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API sub_sat(abacus_char3 x, abacus_char3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_char4 ABACUS_EXPORT_API __abacus_add_sat(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API add_sat(abacus_char4 x, abacus_char4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_char4.
/// @return      A abacus_char4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_char4 ABACUS_EXPORT_API __abacus_clz(abacus_char4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API clz(abacus_char4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @param[in] z A abacus_char4.
/// @return      A abacus_char4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char4 ABACUS_EXPORT_API __abacus_clamp(abacus_char4 x, abacus_char4 y, abacus_char4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @param[in] z A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API clamp(abacus_char4 x, abacus_char4 y, abacus_char4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char4 ABACUS_EXPORT_API __abacus_hadd(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API hadd(abacus_char4 x, abacus_char4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char4 ABACUS_EXPORT_API __abacus_max(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API max(abacus_char4 x, abacus_char4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char4 ABACUS_EXPORT_API __abacus_min(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API min(abacus_char4 x, abacus_char4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @param[in] z A abacus_char4.
/// @return      A abacus_char4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_char4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_char4 x, abacus_char4 y, abacus_char4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @param[in] z A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API mad_hi(abacus_char4 x, abacus_char4 y, abacus_char4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @param[in] z A abacus_char4.
/// @return      A abacus_char4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_char4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_char4 x, abacus_char4 y, abacus_char4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @param[in] z A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API mad_sat(abacus_char4 x, abacus_char4 y, abacus_char4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_char4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API mul_hi(abacus_char4 x, abacus_char4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_char4.
/// @return      A abacus_char4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_char4 ABACUS_EXPORT_API __abacus_popcount(abacus_char4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API popcount(abacus_char4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char4 ABACUS_EXPORT_API __abacus_rhadd(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API rhadd(abacus_char4 x, abacus_char4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_char4 ABACUS_EXPORT_API __abacus_rotate(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API rotate(abacus_char4 x, abacus_char4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_char4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_char4 x, abacus_char4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char4.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API sub_sat(abacus_char4 x, abacus_char4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_char8 ABACUS_EXPORT_API __abacus_add_sat(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API add_sat(abacus_char8 x, abacus_char8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_char8.
/// @return      A abacus_char8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_char8 ABACUS_EXPORT_API __abacus_clz(abacus_char8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API clz(abacus_char8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @param[in] z A abacus_char8.
/// @return      A abacus_char8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char8 ABACUS_EXPORT_API __abacus_clamp(abacus_char8 x, abacus_char8 y, abacus_char8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @param[in] z A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API clamp(abacus_char8 x, abacus_char8 y, abacus_char8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char8 ABACUS_EXPORT_API __abacus_hadd(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API hadd(abacus_char8 x, abacus_char8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char8 ABACUS_EXPORT_API __abacus_max(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API max(abacus_char8 x, abacus_char8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char8 ABACUS_EXPORT_API __abacus_min(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API min(abacus_char8 x, abacus_char8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @param[in] z A abacus_char8.
/// @return      A abacus_char8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_char8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_char8 x, abacus_char8 y, abacus_char8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @param[in] z A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API mad_hi(abacus_char8 x, abacus_char8 y, abacus_char8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @param[in] z A abacus_char8.
/// @return      A abacus_char8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_char8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_char8 x, abacus_char8 y, abacus_char8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @param[in] z A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API mad_sat(abacus_char8 x, abacus_char8 y, abacus_char8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_char8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API mul_hi(abacus_char8 x, abacus_char8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_char8.
/// @return      A abacus_char8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_char8 ABACUS_EXPORT_API __abacus_popcount(abacus_char8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API popcount(abacus_char8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char8 ABACUS_EXPORT_API __abacus_rhadd(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API rhadd(abacus_char8 x, abacus_char8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_char8 ABACUS_EXPORT_API __abacus_rotate(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API rotate(abacus_char8 x, abacus_char8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_char8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_char8 x, abacus_char8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char8.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API sub_sat(abacus_char8 x, abacus_char8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_char16 ABACUS_EXPORT_API __abacus_add_sat(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API add_sat(abacus_char16 x, abacus_char16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_char16.
/// @return      A abacus_char16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_char16 ABACUS_EXPORT_API __abacus_clz(abacus_char16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API clz(abacus_char16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @param[in] z A abacus_char16.
/// @return      A abacus_char16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char16 ABACUS_EXPORT_API __abacus_clamp(abacus_char16 x, abacus_char16 y, abacus_char16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @param[in] z A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API clamp(abacus_char16 x, abacus_char16 y, abacus_char16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char16 ABACUS_EXPORT_API __abacus_hadd(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API hadd(abacus_char16 x, abacus_char16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char16 ABACUS_EXPORT_API __abacus_max(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API max(abacus_char16 x, abacus_char16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char16 ABACUS_EXPORT_API __abacus_min(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API min(abacus_char16 x, abacus_char16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @param[in] z A abacus_char16.
/// @return      A abacus_char16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_char16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_char16 x, abacus_char16 y, abacus_char16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @param[in] z A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API mad_hi(abacus_char16 x, abacus_char16 y, abacus_char16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @param[in] z A abacus_char16.
/// @return      A abacus_char16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_char16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_char16 x, abacus_char16 y, abacus_char16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @param[in] z A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API mad_sat(abacus_char16 x, abacus_char16 y, abacus_char16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_char16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API mul_hi(abacus_char16 x, abacus_char16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_char16.
/// @return      A abacus_char16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_char16 ABACUS_EXPORT_API __abacus_popcount(abacus_char16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API popcount(abacus_char16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_char16 ABACUS_EXPORT_API __abacus_rhadd(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API rhadd(abacus_char16 x, abacus_char16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_char16 ABACUS_EXPORT_API __abacus_rotate(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API rotate(abacus_char16 x, abacus_char16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_char16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_char16 x, abacus_char16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char16.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API sub_sat(abacus_char16 x, abacus_char16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_short ABACUS_EXPORT_API __abacus_add_sat(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API add_sat(abacus_short x, abacus_short y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_short.
/// @return      A abacus_short.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_short ABACUS_EXPORT_API __abacus_clz(abacus_short x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API clz(abacus_short x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short ABACUS_EXPORT_API __abacus_clamp(abacus_short x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API clamp(abacus_short x, abacus_short y, abacus_short z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short ABACUS_EXPORT_API __abacus_hadd(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API hadd(abacus_short x, abacus_short y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short ABACUS_EXPORT_API __abacus_max(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API max(abacus_short x, abacus_short y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short ABACUS_EXPORT_API __abacus_min(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API min(abacus_short x, abacus_short y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_short ABACUS_EXPORT_API __abacus_mad_hi(abacus_short x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API mad_hi(abacus_short x, abacus_short y, abacus_short z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_short ABACUS_EXPORT_API __abacus_mad_sat(abacus_short x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API mad_sat(abacus_short x, abacus_short y, abacus_short z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_short ABACUS_EXPORT_API __abacus_mul_hi(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API mul_hi(abacus_short x, abacus_short y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_short.
/// @return      A abacus_short.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_short ABACUS_EXPORT_API __abacus_popcount(abacus_short x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API popcount(abacus_short x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short ABACUS_EXPORT_API __abacus_rhadd(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API rhadd(abacus_short x, abacus_short y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_short ABACUS_EXPORT_API __abacus_rotate(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API rotate(abacus_short x, abacus_short y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_short ABACUS_EXPORT_API __abacus_sub_sat(abacus_short x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_short.
/// @param[in] y A abacus_short.
/// @return      A abacus_short.
inline abacus_short ABACUS_API sub_sat(abacus_short x, abacus_short y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_short2 ABACUS_EXPORT_API __abacus_add_sat(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API add_sat(abacus_short2 x, abacus_short2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_short2.
/// @return      A abacus_short2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_short2 ABACUS_EXPORT_API __abacus_clz(abacus_short2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API clz(abacus_short2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @param[in] z A abacus_short2.
/// @return      A abacus_short2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short2 ABACUS_EXPORT_API __abacus_clamp(abacus_short2 x, abacus_short2 y, abacus_short2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @param[in] z A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API clamp(abacus_short2 x, abacus_short2 y, abacus_short2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short2 ABACUS_EXPORT_API __abacus_hadd(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API hadd(abacus_short2 x, abacus_short2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short2 ABACUS_EXPORT_API __abacus_max(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API max(abacus_short2 x, abacus_short2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short2 ABACUS_EXPORT_API __abacus_min(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API min(abacus_short2 x, abacus_short2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @param[in] z A abacus_short2.
/// @return      A abacus_short2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_short2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_short2 x, abacus_short2 y, abacus_short2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @param[in] z A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API mad_hi(abacus_short2 x, abacus_short2 y, abacus_short2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @param[in] z A abacus_short2.
/// @return      A abacus_short2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_short2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_short2 x, abacus_short2 y, abacus_short2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @param[in] z A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API mad_sat(abacus_short2 x, abacus_short2 y, abacus_short2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_short2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API mul_hi(abacus_short2 x, abacus_short2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_short2.
/// @return      A abacus_short2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_short2 ABACUS_EXPORT_API __abacus_popcount(abacus_short2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API popcount(abacus_short2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short2 ABACUS_EXPORT_API __abacus_rhadd(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API rhadd(abacus_short2 x, abacus_short2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_short2 ABACUS_EXPORT_API __abacus_rotate(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API rotate(abacus_short2 x, abacus_short2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_short2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_short2 x, abacus_short2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short2.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API sub_sat(abacus_short2 x, abacus_short2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_short3 ABACUS_EXPORT_API __abacus_add_sat(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API add_sat(abacus_short3 x, abacus_short3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_short3.
/// @return      A abacus_short3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_short3 ABACUS_EXPORT_API __abacus_clz(abacus_short3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API clz(abacus_short3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @param[in] z A abacus_short3.
/// @return      A abacus_short3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short3 ABACUS_EXPORT_API __abacus_clamp(abacus_short3 x, abacus_short3 y, abacus_short3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @param[in] z A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API clamp(abacus_short3 x, abacus_short3 y, abacus_short3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short3 ABACUS_EXPORT_API __abacus_hadd(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API hadd(abacus_short3 x, abacus_short3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short3 ABACUS_EXPORT_API __abacus_max(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API max(abacus_short3 x, abacus_short3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short3 ABACUS_EXPORT_API __abacus_min(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API min(abacus_short3 x, abacus_short3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @param[in] z A abacus_short3.
/// @return      A abacus_short3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_short3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_short3 x, abacus_short3 y, abacus_short3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @param[in] z A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API mad_hi(abacus_short3 x, abacus_short3 y, abacus_short3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @param[in] z A abacus_short3.
/// @return      A abacus_short3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_short3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_short3 x, abacus_short3 y, abacus_short3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @param[in] z A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API mad_sat(abacus_short3 x, abacus_short3 y, abacus_short3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_short3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API mul_hi(abacus_short3 x, abacus_short3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_short3.
/// @return      A abacus_short3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_short3 ABACUS_EXPORT_API __abacus_popcount(abacus_short3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API popcount(abacus_short3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short3 ABACUS_EXPORT_API __abacus_rhadd(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API rhadd(abacus_short3 x, abacus_short3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_short3 ABACUS_EXPORT_API __abacus_rotate(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API rotate(abacus_short3 x, abacus_short3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_short3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_short3 x, abacus_short3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short3.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API sub_sat(abacus_short3 x, abacus_short3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_short4 ABACUS_EXPORT_API __abacus_add_sat(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API add_sat(abacus_short4 x, abacus_short4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_short4.
/// @return      A abacus_short4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_short4 ABACUS_EXPORT_API __abacus_clz(abacus_short4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API clz(abacus_short4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @param[in] z A abacus_short4.
/// @return      A abacus_short4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short4 ABACUS_EXPORT_API __abacus_clamp(abacus_short4 x, abacus_short4 y, abacus_short4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @param[in] z A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API clamp(abacus_short4 x, abacus_short4 y, abacus_short4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short4 ABACUS_EXPORT_API __abacus_hadd(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API hadd(abacus_short4 x, abacus_short4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short4 ABACUS_EXPORT_API __abacus_max(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API max(abacus_short4 x, abacus_short4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short4 ABACUS_EXPORT_API __abacus_min(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API min(abacus_short4 x, abacus_short4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @param[in] z A abacus_short4.
/// @return      A abacus_short4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_short4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_short4 x, abacus_short4 y, abacus_short4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @param[in] z A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API mad_hi(abacus_short4 x, abacus_short4 y, abacus_short4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @param[in] z A abacus_short4.
/// @return      A abacus_short4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_short4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_short4 x, abacus_short4 y, abacus_short4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @param[in] z A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API mad_sat(abacus_short4 x, abacus_short4 y, abacus_short4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_short4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API mul_hi(abacus_short4 x, abacus_short4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_short4.
/// @return      A abacus_short4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_short4 ABACUS_EXPORT_API __abacus_popcount(abacus_short4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API popcount(abacus_short4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short4 ABACUS_EXPORT_API __abacus_rhadd(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API rhadd(abacus_short4 x, abacus_short4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_short4 ABACUS_EXPORT_API __abacus_rotate(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API rotate(abacus_short4 x, abacus_short4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_short4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_short4 x, abacus_short4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short4.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API sub_sat(abacus_short4 x, abacus_short4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_short8 ABACUS_EXPORT_API __abacus_add_sat(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API add_sat(abacus_short8 x, abacus_short8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_short8.
/// @return      A abacus_short8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_short8 ABACUS_EXPORT_API __abacus_clz(abacus_short8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API clz(abacus_short8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @param[in] z A abacus_short8.
/// @return      A abacus_short8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short8 ABACUS_EXPORT_API __abacus_clamp(abacus_short8 x, abacus_short8 y, abacus_short8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @param[in] z A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API clamp(abacus_short8 x, abacus_short8 y, abacus_short8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short8 ABACUS_EXPORT_API __abacus_hadd(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API hadd(abacus_short8 x, abacus_short8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short8 ABACUS_EXPORT_API __abacus_max(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API max(abacus_short8 x, abacus_short8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short8 ABACUS_EXPORT_API __abacus_min(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API min(abacus_short8 x, abacus_short8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @param[in] z A abacus_short8.
/// @return      A abacus_short8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_short8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_short8 x, abacus_short8 y, abacus_short8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @param[in] z A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API mad_hi(abacus_short8 x, abacus_short8 y, abacus_short8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @param[in] z A abacus_short8.
/// @return      A abacus_short8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_short8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_short8 x, abacus_short8 y, abacus_short8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @param[in] z A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API mad_sat(abacus_short8 x, abacus_short8 y, abacus_short8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_short8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API mul_hi(abacus_short8 x, abacus_short8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_short8.
/// @return      A abacus_short8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_short8 ABACUS_EXPORT_API __abacus_popcount(abacus_short8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API popcount(abacus_short8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short8 ABACUS_EXPORT_API __abacus_rhadd(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API rhadd(abacus_short8 x, abacus_short8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_short8 ABACUS_EXPORT_API __abacus_rotate(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API rotate(abacus_short8 x, abacus_short8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_short8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_short8 x, abacus_short8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short8.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API sub_sat(abacus_short8 x, abacus_short8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_short16 ABACUS_EXPORT_API __abacus_add_sat(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API add_sat(abacus_short16 x, abacus_short16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_short16.
/// @return      A abacus_short16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_short16 ABACUS_EXPORT_API __abacus_clz(abacus_short16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API clz(abacus_short16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @param[in] z A abacus_short16.
/// @return      A abacus_short16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short16 ABACUS_EXPORT_API __abacus_clamp(abacus_short16 x, abacus_short16 y, abacus_short16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @param[in] z A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API clamp(abacus_short16 x, abacus_short16 y, abacus_short16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short16 ABACUS_EXPORT_API __abacus_hadd(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API hadd(abacus_short16 x, abacus_short16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short16 ABACUS_EXPORT_API __abacus_max(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API max(abacus_short16 x, abacus_short16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short16 ABACUS_EXPORT_API __abacus_min(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API min(abacus_short16 x, abacus_short16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @param[in] z A abacus_short16.
/// @return      A abacus_short16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_short16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_short16 x, abacus_short16 y, abacus_short16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @param[in] z A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API mad_hi(abacus_short16 x, abacus_short16 y, abacus_short16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @param[in] z A abacus_short16.
/// @return      A abacus_short16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_short16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_short16 x, abacus_short16 y, abacus_short16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @param[in] z A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API mad_sat(abacus_short16 x, abacus_short16 y, abacus_short16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_short16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API mul_hi(abacus_short16 x, abacus_short16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_short16.
/// @return      A abacus_short16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_short16 ABACUS_EXPORT_API __abacus_popcount(abacus_short16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API popcount(abacus_short16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_short16 ABACUS_EXPORT_API __abacus_rhadd(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API rhadd(abacus_short16 x, abacus_short16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_short16 ABACUS_EXPORT_API __abacus_rotate(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API rotate(abacus_short16 x, abacus_short16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_short16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_short16 x, abacus_short16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short16.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API sub_sat(abacus_short16 x, abacus_short16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_int ABACUS_EXPORT_API __abacus_add_sat(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API add_sat(abacus_int x, abacus_int y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_int ABACUS_EXPORT_API __abacus_clz(abacus_int x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API clz(abacus_int x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int ABACUS_EXPORT_API __abacus_clamp(abacus_int x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API clamp(abacus_int x, abacus_int y, abacus_int z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int ABACUS_EXPORT_API __abacus_hadd(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API hadd(abacus_int x, abacus_int y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int ABACUS_EXPORT_API __abacus_max(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API max(abacus_int x, abacus_int y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int ABACUS_EXPORT_API __abacus_min(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API min(abacus_int x, abacus_int y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_int ABACUS_EXPORT_API __abacus_mad_hi(abacus_int x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API mad_hi(abacus_int x, abacus_int y, abacus_int z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_int ABACUS_EXPORT_API __abacus_mad_sat(abacus_int x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API mad_sat(abacus_int x, abacus_int y, abacus_int z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_int ABACUS_EXPORT_API __abacus_mul_hi(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API mul_hi(abacus_int x, abacus_int y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_int ABACUS_EXPORT_API __abacus_popcount(abacus_int x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API popcount(abacus_int x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int ABACUS_EXPORT_API __abacus_rhadd(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API rhadd(abacus_int x, abacus_int y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_int ABACUS_EXPORT_API __abacus_rotate(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API rotate(abacus_int x, abacus_int y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_int ABACUS_EXPORT_API __abacus_sub_sat(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API sub_sat(abacus_int x, abacus_int y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_int2 ABACUS_EXPORT_API __abacus_add_sat(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API add_sat(abacus_int2 x, abacus_int2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_int2 ABACUS_EXPORT_API __abacus_clz(abacus_int2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API clz(abacus_int2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int2 ABACUS_EXPORT_API __abacus_clamp(abacus_int2 x, abacus_int2 y, abacus_int2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API clamp(abacus_int2 x, abacus_int2 y, abacus_int2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int2 ABACUS_EXPORT_API __abacus_hadd(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API hadd(abacus_int2 x, abacus_int2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int2 ABACUS_EXPORT_API __abacus_max(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API max(abacus_int2 x, abacus_int2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int2 ABACUS_EXPORT_API __abacus_min(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API min(abacus_int2 x, abacus_int2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_int2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_int2 x, abacus_int2 y, abacus_int2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API mad_hi(abacus_int2 x, abacus_int2 y, abacus_int2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_int2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_int2 x, abacus_int2 y, abacus_int2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API mad_sat(abacus_int2 x, abacus_int2 y, abacus_int2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_int2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API mul_hi(abacus_int2 x, abacus_int2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_int2 ABACUS_EXPORT_API __abacus_popcount(abacus_int2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API popcount(abacus_int2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int2 ABACUS_EXPORT_API __abacus_rhadd(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API rhadd(abacus_int2 x, abacus_int2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_int2 ABACUS_EXPORT_API __abacus_rotate(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API rotate(abacus_int2 x, abacus_int2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_int2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API sub_sat(abacus_int2 x, abacus_int2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_int3 ABACUS_EXPORT_API __abacus_add_sat(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API add_sat(abacus_int3 x, abacus_int3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_int3 ABACUS_EXPORT_API __abacus_clz(abacus_int3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API clz(abacus_int3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int3 ABACUS_EXPORT_API __abacus_clamp(abacus_int3 x, abacus_int3 y, abacus_int3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API clamp(abacus_int3 x, abacus_int3 y, abacus_int3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int3 ABACUS_EXPORT_API __abacus_hadd(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API hadd(abacus_int3 x, abacus_int3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int3 ABACUS_EXPORT_API __abacus_max(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API max(abacus_int3 x, abacus_int3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int3 ABACUS_EXPORT_API __abacus_min(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API min(abacus_int3 x, abacus_int3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_int3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_int3 x, abacus_int3 y, abacus_int3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API mad_hi(abacus_int3 x, abacus_int3 y, abacus_int3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_int3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_int3 x, abacus_int3 y, abacus_int3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API mad_sat(abacus_int3 x, abacus_int3 y, abacus_int3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_int3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API mul_hi(abacus_int3 x, abacus_int3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_int3 ABACUS_EXPORT_API __abacus_popcount(abacus_int3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API popcount(abacus_int3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int3 ABACUS_EXPORT_API __abacus_rhadd(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API rhadd(abacus_int3 x, abacus_int3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_int3 ABACUS_EXPORT_API __abacus_rotate(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API rotate(abacus_int3 x, abacus_int3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_int3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API sub_sat(abacus_int3 x, abacus_int3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_int4 ABACUS_EXPORT_API __abacus_add_sat(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API add_sat(abacus_int4 x, abacus_int4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_int4 ABACUS_EXPORT_API __abacus_clz(abacus_int4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API clz(abacus_int4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int4 ABACUS_EXPORT_API __abacus_clamp(abacus_int4 x, abacus_int4 y, abacus_int4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API clamp(abacus_int4 x, abacus_int4 y, abacus_int4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int4 ABACUS_EXPORT_API __abacus_hadd(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API hadd(abacus_int4 x, abacus_int4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int4 ABACUS_EXPORT_API __abacus_max(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API max(abacus_int4 x, abacus_int4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int4 ABACUS_EXPORT_API __abacus_min(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API min(abacus_int4 x, abacus_int4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_int4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_int4 x, abacus_int4 y, abacus_int4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API mad_hi(abacus_int4 x, abacus_int4 y, abacus_int4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_int4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_int4 x, abacus_int4 y, abacus_int4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API mad_sat(abacus_int4 x, abacus_int4 y, abacus_int4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_int4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API mul_hi(abacus_int4 x, abacus_int4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_int4 ABACUS_EXPORT_API __abacus_popcount(abacus_int4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API popcount(abacus_int4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int4 ABACUS_EXPORT_API __abacus_rhadd(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API rhadd(abacus_int4 x, abacus_int4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_int4 ABACUS_EXPORT_API __abacus_rotate(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API rotate(abacus_int4 x, abacus_int4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_int4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API sub_sat(abacus_int4 x, abacus_int4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_int8 ABACUS_EXPORT_API __abacus_add_sat(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API add_sat(abacus_int8 x, abacus_int8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_int8 ABACUS_EXPORT_API __abacus_clz(abacus_int8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API clz(abacus_int8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int8 ABACUS_EXPORT_API __abacus_clamp(abacus_int8 x, abacus_int8 y, abacus_int8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API clamp(abacus_int8 x, abacus_int8 y, abacus_int8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int8 ABACUS_EXPORT_API __abacus_hadd(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API hadd(abacus_int8 x, abacus_int8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int8 ABACUS_EXPORT_API __abacus_max(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API max(abacus_int8 x, abacus_int8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int8 ABACUS_EXPORT_API __abacus_min(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API min(abacus_int8 x, abacus_int8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_int8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_int8 x, abacus_int8 y, abacus_int8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API mad_hi(abacus_int8 x, abacus_int8 y, abacus_int8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_int8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_int8 x, abacus_int8 y, abacus_int8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API mad_sat(abacus_int8 x, abacus_int8 y, abacus_int8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_int8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API mul_hi(abacus_int8 x, abacus_int8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_int8 ABACUS_EXPORT_API __abacus_popcount(abacus_int8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API popcount(abacus_int8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int8 ABACUS_EXPORT_API __abacus_rhadd(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API rhadd(abacus_int8 x, abacus_int8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_int8 ABACUS_EXPORT_API __abacus_rotate(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API rotate(abacus_int8 x, abacus_int8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_int8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API sub_sat(abacus_int8 x, abacus_int8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_int16 ABACUS_EXPORT_API __abacus_add_sat(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API add_sat(abacus_int16 x, abacus_int16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_int16 ABACUS_EXPORT_API __abacus_clz(abacus_int16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API clz(abacus_int16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int16 ABACUS_EXPORT_API __abacus_clamp(abacus_int16 x, abacus_int16 y, abacus_int16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API clamp(abacus_int16 x, abacus_int16 y, abacus_int16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int16 ABACUS_EXPORT_API __abacus_hadd(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API hadd(abacus_int16 x, abacus_int16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int16 ABACUS_EXPORT_API __abacus_max(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API max(abacus_int16 x, abacus_int16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int16 ABACUS_EXPORT_API __abacus_min(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API min(abacus_int16 x, abacus_int16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_int16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_int16 x, abacus_int16 y, abacus_int16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API mad_hi(abacus_int16 x, abacus_int16 y, abacus_int16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_int16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_int16 x, abacus_int16 y, abacus_int16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API mad_sat(abacus_int16 x, abacus_int16 y, abacus_int16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_int16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API mul_hi(abacus_int16 x, abacus_int16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_int16 ABACUS_EXPORT_API __abacus_popcount(abacus_int16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API popcount(abacus_int16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_int16 ABACUS_EXPORT_API __abacus_rhadd(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API rhadd(abacus_int16 x, abacus_int16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_int16 ABACUS_EXPORT_API __abacus_rotate(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API rotate(abacus_int16 x, abacus_int16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_int16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API sub_sat(abacus_int16 x, abacus_int16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_long ABACUS_EXPORT_API __abacus_add_sat(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API add_sat(abacus_long x, abacus_long y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_long.
/// @return      A abacus_long.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_long ABACUS_EXPORT_API __abacus_clz(abacus_long x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API clz(abacus_long x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long ABACUS_EXPORT_API __abacus_clamp(abacus_long x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API clamp(abacus_long x, abacus_long y, abacus_long z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long ABACUS_EXPORT_API __abacus_hadd(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API hadd(abacus_long x, abacus_long y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long ABACUS_EXPORT_API __abacus_max(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API max(abacus_long x, abacus_long y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long ABACUS_EXPORT_API __abacus_min(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API min(abacus_long x, abacus_long y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_long ABACUS_EXPORT_API __abacus_mad_hi(abacus_long x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API mad_hi(abacus_long x, abacus_long y, abacus_long z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_long ABACUS_EXPORT_API __abacus_mad_sat(abacus_long x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API mad_sat(abacus_long x, abacus_long y, abacus_long z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_long ABACUS_EXPORT_API __abacus_mul_hi(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API mul_hi(abacus_long x, abacus_long y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_long.
/// @return      A abacus_long.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_long ABACUS_EXPORT_API __abacus_popcount(abacus_long x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API popcount(abacus_long x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long ABACUS_EXPORT_API __abacus_rhadd(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API rhadd(abacus_long x, abacus_long y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_long ABACUS_EXPORT_API __abacus_rotate(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API rotate(abacus_long x, abacus_long y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_long ABACUS_EXPORT_API __abacus_sub_sat(abacus_long x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_long.
/// @param[in] y A abacus_long.
/// @return      A abacus_long.
inline abacus_long ABACUS_API sub_sat(abacus_long x, abacus_long y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_long2 ABACUS_EXPORT_API __abacus_add_sat(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API add_sat(abacus_long2 x, abacus_long2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_long2.
/// @return      A abacus_long2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_long2 ABACUS_EXPORT_API __abacus_clz(abacus_long2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API clz(abacus_long2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @param[in] z A abacus_long2.
/// @return      A abacus_long2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long2 ABACUS_EXPORT_API __abacus_clamp(abacus_long2 x, abacus_long2 y, abacus_long2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @param[in] z A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API clamp(abacus_long2 x, abacus_long2 y, abacus_long2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long2 ABACUS_EXPORT_API __abacus_hadd(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API hadd(abacus_long2 x, abacus_long2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long2 ABACUS_EXPORT_API __abacus_max(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API max(abacus_long2 x, abacus_long2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long2 ABACUS_EXPORT_API __abacus_min(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API min(abacus_long2 x, abacus_long2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @param[in] z A abacus_long2.
/// @return      A abacus_long2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_long2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_long2 x, abacus_long2 y, abacus_long2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @param[in] z A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API mad_hi(abacus_long2 x, abacus_long2 y, abacus_long2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @param[in] z A abacus_long2.
/// @return      A abacus_long2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_long2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_long2 x, abacus_long2 y, abacus_long2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @param[in] z A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API mad_sat(abacus_long2 x, abacus_long2 y, abacus_long2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_long2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API mul_hi(abacus_long2 x, abacus_long2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_long2.
/// @return      A abacus_long2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_long2 ABACUS_EXPORT_API __abacus_popcount(abacus_long2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API popcount(abacus_long2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long2 ABACUS_EXPORT_API __abacus_rhadd(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API rhadd(abacus_long2 x, abacus_long2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_long2 ABACUS_EXPORT_API __abacus_rotate(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API rotate(abacus_long2 x, abacus_long2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_long2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_long2 x, abacus_long2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long2.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API sub_sat(abacus_long2 x, abacus_long2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_long3 ABACUS_EXPORT_API __abacus_add_sat(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API add_sat(abacus_long3 x, abacus_long3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_long3.
/// @return      A abacus_long3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_long3 ABACUS_EXPORT_API __abacus_clz(abacus_long3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API clz(abacus_long3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @param[in] z A abacus_long3.
/// @return      A abacus_long3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long3 ABACUS_EXPORT_API __abacus_clamp(abacus_long3 x, abacus_long3 y, abacus_long3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @param[in] z A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API clamp(abacus_long3 x, abacus_long3 y, abacus_long3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long3 ABACUS_EXPORT_API __abacus_hadd(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API hadd(abacus_long3 x, abacus_long3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long3 ABACUS_EXPORT_API __abacus_max(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API max(abacus_long3 x, abacus_long3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long3 ABACUS_EXPORT_API __abacus_min(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API min(abacus_long3 x, abacus_long3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @param[in] z A abacus_long3.
/// @return      A abacus_long3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_long3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_long3 x, abacus_long3 y, abacus_long3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @param[in] z A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API mad_hi(abacus_long3 x, abacus_long3 y, abacus_long3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @param[in] z A abacus_long3.
/// @return      A abacus_long3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_long3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_long3 x, abacus_long3 y, abacus_long3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @param[in] z A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API mad_sat(abacus_long3 x, abacus_long3 y, abacus_long3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_long3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API mul_hi(abacus_long3 x, abacus_long3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_long3.
/// @return      A abacus_long3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_long3 ABACUS_EXPORT_API __abacus_popcount(abacus_long3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API popcount(abacus_long3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long3 ABACUS_EXPORT_API __abacus_rhadd(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API rhadd(abacus_long3 x, abacus_long3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_long3 ABACUS_EXPORT_API __abacus_rotate(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API rotate(abacus_long3 x, abacus_long3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_long3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_long3 x, abacus_long3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long3.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API sub_sat(abacus_long3 x, abacus_long3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_long4 ABACUS_EXPORT_API __abacus_add_sat(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API add_sat(abacus_long4 x, abacus_long4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_long4.
/// @return      A abacus_long4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_long4 ABACUS_EXPORT_API __abacus_clz(abacus_long4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API clz(abacus_long4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @param[in] z A abacus_long4.
/// @return      A abacus_long4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long4 ABACUS_EXPORT_API __abacus_clamp(abacus_long4 x, abacus_long4 y, abacus_long4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @param[in] z A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API clamp(abacus_long4 x, abacus_long4 y, abacus_long4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long4 ABACUS_EXPORT_API __abacus_hadd(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API hadd(abacus_long4 x, abacus_long4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long4 ABACUS_EXPORT_API __abacus_max(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API max(abacus_long4 x, abacus_long4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long4 ABACUS_EXPORT_API __abacus_min(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API min(abacus_long4 x, abacus_long4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @param[in] z A abacus_long4.
/// @return      A abacus_long4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_long4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_long4 x, abacus_long4 y, abacus_long4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @param[in] z A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API mad_hi(abacus_long4 x, abacus_long4 y, abacus_long4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @param[in] z A abacus_long4.
/// @return      A abacus_long4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_long4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_long4 x, abacus_long4 y, abacus_long4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @param[in] z A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API mad_sat(abacus_long4 x, abacus_long4 y, abacus_long4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_long4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API mul_hi(abacus_long4 x, abacus_long4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_long4.
/// @return      A abacus_long4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_long4 ABACUS_EXPORT_API __abacus_popcount(abacus_long4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API popcount(abacus_long4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long4 ABACUS_EXPORT_API __abacus_rhadd(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API rhadd(abacus_long4 x, abacus_long4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_long4 ABACUS_EXPORT_API __abacus_rotate(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API rotate(abacus_long4 x, abacus_long4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_long4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_long4 x, abacus_long4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long4.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API sub_sat(abacus_long4 x, abacus_long4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_long8 ABACUS_EXPORT_API __abacus_add_sat(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API add_sat(abacus_long8 x, abacus_long8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_long8.
/// @return      A abacus_long8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_long8 ABACUS_EXPORT_API __abacus_clz(abacus_long8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API clz(abacus_long8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @param[in] z A abacus_long8.
/// @return      A abacus_long8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long8 ABACUS_EXPORT_API __abacus_clamp(abacus_long8 x, abacus_long8 y, abacus_long8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @param[in] z A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API clamp(abacus_long8 x, abacus_long8 y, abacus_long8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long8 ABACUS_EXPORT_API __abacus_hadd(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API hadd(abacus_long8 x, abacus_long8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long8 ABACUS_EXPORT_API __abacus_max(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API max(abacus_long8 x, abacus_long8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long8 ABACUS_EXPORT_API __abacus_min(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API min(abacus_long8 x, abacus_long8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @param[in] z A abacus_long8.
/// @return      A abacus_long8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_long8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_long8 x, abacus_long8 y, abacus_long8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @param[in] z A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API mad_hi(abacus_long8 x, abacus_long8 y, abacus_long8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @param[in] z A abacus_long8.
/// @return      A abacus_long8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_long8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_long8 x, abacus_long8 y, abacus_long8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @param[in] z A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API mad_sat(abacus_long8 x, abacus_long8 y, abacus_long8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_long8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API mul_hi(abacus_long8 x, abacus_long8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_long8.
/// @return      A abacus_long8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_long8 ABACUS_EXPORT_API __abacus_popcount(abacus_long8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API popcount(abacus_long8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long8 ABACUS_EXPORT_API __abacus_rhadd(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API rhadd(abacus_long8 x, abacus_long8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_long8 ABACUS_EXPORT_API __abacus_rotate(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API rotate(abacus_long8 x, abacus_long8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_long8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_long8 x, abacus_long8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long8.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API sub_sat(abacus_long8 x, abacus_long8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_long16 ABACUS_EXPORT_API __abacus_add_sat(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API add_sat(abacus_long16 x, abacus_long16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_long16.
/// @return      A abacus_long16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_long16 ABACUS_EXPORT_API __abacus_clz(abacus_long16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API clz(abacus_long16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @param[in] z A abacus_long16.
/// @return      A abacus_long16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long16 ABACUS_EXPORT_API __abacus_clamp(abacus_long16 x, abacus_long16 y, abacus_long16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @param[in] z A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API clamp(abacus_long16 x, abacus_long16 y, abacus_long16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long16 ABACUS_EXPORT_API __abacus_hadd(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API hadd(abacus_long16 x, abacus_long16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long16 ABACUS_EXPORT_API __abacus_max(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API max(abacus_long16 x, abacus_long16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long16 ABACUS_EXPORT_API __abacus_min(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API min(abacus_long16 x, abacus_long16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @param[in] z A abacus_long16.
/// @return      A abacus_long16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_long16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_long16 x, abacus_long16 y, abacus_long16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @param[in] z A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API mad_hi(abacus_long16 x, abacus_long16 y, abacus_long16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @param[in] z A abacus_long16.
/// @return      A abacus_long16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_long16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_long16 x, abacus_long16 y, abacus_long16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @param[in] z A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API mad_sat(abacus_long16 x, abacus_long16 y, abacus_long16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_long16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API mul_hi(abacus_long16 x, abacus_long16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_long16.
/// @return      A abacus_long16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_long16 ABACUS_EXPORT_API __abacus_popcount(abacus_long16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API popcount(abacus_long16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_long16 ABACUS_EXPORT_API __abacus_rhadd(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API rhadd(abacus_long16 x, abacus_long16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_long16 ABACUS_EXPORT_API __abacus_rotate(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API rotate(abacus_long16 x, abacus_long16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_long16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_long16 x, abacus_long16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long16.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API sub_sat(abacus_long16 x, abacus_long16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uchar ABACUS_EXPORT_API __abacus_add_sat(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API add_sat(abacus_uchar x, abacus_uchar y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uchar.
/// @return      A abacus_uchar.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uchar ABACUS_EXPORT_API __abacus_clz(abacus_uchar x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API clz(abacus_uchar x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar ABACUS_EXPORT_API __abacus_clamp(abacus_uchar x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API clamp(abacus_uchar x, abacus_uchar y, abacus_uchar z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar ABACUS_EXPORT_API __abacus_hadd(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API hadd(abacus_uchar x, abacus_uchar y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar ABACUS_EXPORT_API __abacus_max(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API max(abacus_uchar x, abacus_uchar y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar ABACUS_EXPORT_API __abacus_min(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API min(abacus_uchar x, abacus_uchar y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uchar ABACUS_EXPORT_API __abacus_mad_hi(abacus_uchar x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API mad_hi(abacus_uchar x, abacus_uchar y, abacus_uchar z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uchar ABACUS_EXPORT_API __abacus_mad_sat(abacus_uchar x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API mad_sat(abacus_uchar x, abacus_uchar y, abacus_uchar z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uchar ABACUS_EXPORT_API __abacus_mul_hi(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API mul_hi(abacus_uchar x, abacus_uchar y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uchar.
/// @return      A abacus_uchar.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uchar ABACUS_EXPORT_API __abacus_popcount(abacus_uchar x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API popcount(abacus_uchar x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar ABACUS_EXPORT_API __abacus_rhadd(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API rhadd(abacus_uchar x, abacus_uchar y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uchar ABACUS_EXPORT_API __abacus_rotate(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API rotate(abacus_uchar x, abacus_uchar y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uchar ABACUS_EXPORT_API __abacus_sub_sat(abacus_uchar x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uchar.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar.
inline abacus_uchar ABACUS_API sub_sat(abacus_uchar x, abacus_uchar y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_add_sat(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API add_sat(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_clz(abacus_uchar2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API clz(abacus_uchar2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @param[in] z A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar2 x, abacus_uchar2 y, abacus_uchar2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @param[in] z A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API clamp(abacus_uchar2 x, abacus_uchar2 y, abacus_uchar2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_hadd(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API hadd(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_max(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API max(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_min(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API min(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @param[in] z A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uchar2 x, abacus_uchar2 y, abacus_uchar2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @param[in] z A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API mad_hi(abacus_uchar2 x, abacus_uchar2 y, abacus_uchar2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @param[in] z A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uchar2 x, abacus_uchar2 y, abacus_uchar2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @param[in] z A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API mad_sat(abacus_uchar2 x, abacus_uchar2 y, abacus_uchar2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API mul_hi(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_popcount(abacus_uchar2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API popcount(abacus_uchar2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_rhadd(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API rhadd(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_rotate(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API rotate(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uchar2 x, abacus_uchar2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar2.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API sub_sat(abacus_uchar2 x, abacus_uchar2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_add_sat(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API add_sat(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_clz(abacus_uchar3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API clz(abacus_uchar3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @param[in] z A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar3 x, abacus_uchar3 y, abacus_uchar3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @param[in] z A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API clamp(abacus_uchar3 x, abacus_uchar3 y, abacus_uchar3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_hadd(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API hadd(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_max(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API max(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_min(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API min(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @param[in] z A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uchar3 x, abacus_uchar3 y, abacus_uchar3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @param[in] z A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API mad_hi(abacus_uchar3 x, abacus_uchar3 y, abacus_uchar3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @param[in] z A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uchar3 x, abacus_uchar3 y, abacus_uchar3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @param[in] z A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API mad_sat(abacus_uchar3 x, abacus_uchar3 y, abacus_uchar3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API mul_hi(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_popcount(abacus_uchar3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API popcount(abacus_uchar3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_rhadd(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API rhadd(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_rotate(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API rotate(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uchar3 x, abacus_uchar3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar3.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API sub_sat(abacus_uchar3 x, abacus_uchar3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_add_sat(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API add_sat(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_clz(abacus_uchar4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API clz(abacus_uchar4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @param[in] z A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar4 x, abacus_uchar4 y, abacus_uchar4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @param[in] z A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API clamp(abacus_uchar4 x, abacus_uchar4 y, abacus_uchar4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_hadd(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API hadd(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_max(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API max(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_min(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API min(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @param[in] z A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uchar4 x, abacus_uchar4 y, abacus_uchar4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @param[in] z A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API mad_hi(abacus_uchar4 x, abacus_uchar4 y, abacus_uchar4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @param[in] z A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uchar4 x, abacus_uchar4 y, abacus_uchar4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @param[in] z A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API mad_sat(abacus_uchar4 x, abacus_uchar4 y, abacus_uchar4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API mul_hi(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_popcount(abacus_uchar4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API popcount(abacus_uchar4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_rhadd(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API rhadd(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_rotate(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API rotate(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uchar4 x, abacus_uchar4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar4.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API sub_sat(abacus_uchar4 x, abacus_uchar4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_add_sat(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API add_sat(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_clz(abacus_uchar8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API clz(abacus_uchar8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @param[in] z A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar8 x, abacus_uchar8 y, abacus_uchar8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @param[in] z A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API clamp(abacus_uchar8 x, abacus_uchar8 y, abacus_uchar8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_hadd(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API hadd(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_max(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API max(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_min(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API min(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @param[in] z A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uchar8 x, abacus_uchar8 y, abacus_uchar8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @param[in] z A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API mad_hi(abacus_uchar8 x, abacus_uchar8 y, abacus_uchar8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @param[in] z A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uchar8 x, abacus_uchar8 y, abacus_uchar8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @param[in] z A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API mad_sat(abacus_uchar8 x, abacus_uchar8 y, abacus_uchar8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API mul_hi(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_popcount(abacus_uchar8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API popcount(abacus_uchar8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_rhadd(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API rhadd(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_rotate(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API rotate(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uchar8 x, abacus_uchar8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar8.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API sub_sat(abacus_uchar8 x, abacus_uchar8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_add_sat(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API add_sat(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_clz(abacus_uchar16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API clz(abacus_uchar16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @param[in] z A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar16 x, abacus_uchar16 y, abacus_uchar16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @param[in] z A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API clamp(abacus_uchar16 x, abacus_uchar16 y, abacus_uchar16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_hadd(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API hadd(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_max(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API max(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_min(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API min(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @param[in] z A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uchar16 x, abacus_uchar16 y, abacus_uchar16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @param[in] z A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API mad_hi(abacus_uchar16 x, abacus_uchar16 y, abacus_uchar16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @param[in] z A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uchar16 x, abacus_uchar16 y, abacus_uchar16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @param[in] z A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API mad_sat(abacus_uchar16 x, abacus_uchar16 y, abacus_uchar16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API mul_hi(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_popcount(abacus_uchar16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API popcount(abacus_uchar16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_rhadd(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API rhadd(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_rotate(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API rotate(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uchar16 x, abacus_uchar16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar16.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API sub_sat(abacus_uchar16 x, abacus_uchar16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ushort ABACUS_EXPORT_API __abacus_add_sat(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API add_sat(abacus_ushort x, abacus_ushort y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ushort.
/// @return      A abacus_ushort.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ushort ABACUS_EXPORT_API __abacus_clz(abacus_ushort x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API clz(abacus_ushort x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort ABACUS_EXPORT_API __abacus_clamp(abacus_ushort x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API clamp(abacus_ushort x, abacus_ushort y, abacus_ushort z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort ABACUS_EXPORT_API __abacus_hadd(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API hadd(abacus_ushort x, abacus_ushort y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort ABACUS_EXPORT_API __abacus_max(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API max(abacus_ushort x, abacus_ushort y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort ABACUS_EXPORT_API __abacus_min(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API min(abacus_ushort x, abacus_ushort y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ushort ABACUS_EXPORT_API __abacus_mad_hi(abacus_ushort x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API mad_hi(abacus_ushort x, abacus_ushort y, abacus_ushort z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ushort ABACUS_EXPORT_API __abacus_mad_sat(abacus_ushort x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API mad_sat(abacus_ushort x, abacus_ushort y, abacus_ushort z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ushort ABACUS_EXPORT_API __abacus_mul_hi(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API mul_hi(abacus_ushort x, abacus_ushort y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ushort.
/// @return      A abacus_ushort.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ushort ABACUS_EXPORT_API __abacus_popcount(abacus_ushort x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API popcount(abacus_ushort x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort ABACUS_EXPORT_API __abacus_rhadd(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API rhadd(abacus_ushort x, abacus_ushort y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ushort ABACUS_EXPORT_API __abacus_rotate(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API rotate(abacus_ushort x, abacus_ushort y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ushort ABACUS_EXPORT_API __abacus_sub_sat(abacus_ushort x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ushort.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort.
inline abacus_ushort ABACUS_API sub_sat(abacus_ushort x, abacus_ushort y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_add_sat(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API add_sat(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_clz(abacus_ushort2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API clz(abacus_ushort2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @param[in] z A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort2 x, abacus_ushort2 y, abacus_ushort2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @param[in] z A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API clamp(abacus_ushort2 x, abacus_ushort2 y, abacus_ushort2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_hadd(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API hadd(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_max(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API max(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_min(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API min(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @param[in] z A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ushort2 x, abacus_ushort2 y, abacus_ushort2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @param[in] z A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API mad_hi(abacus_ushort2 x, abacus_ushort2 y, abacus_ushort2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @param[in] z A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ushort2 x, abacus_ushort2 y, abacus_ushort2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @param[in] z A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API mad_sat(abacus_ushort2 x, abacus_ushort2 y, abacus_ushort2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API mul_hi(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_popcount(abacus_ushort2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API popcount(abacus_ushort2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_rhadd(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API rhadd(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_rotate(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API rotate(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ushort2 x, abacus_ushort2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort2.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API sub_sat(abacus_ushort2 x, abacus_ushort2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_add_sat(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API add_sat(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_clz(abacus_ushort3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API clz(abacus_ushort3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @param[in] z A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort3 x, abacus_ushort3 y, abacus_ushort3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @param[in] z A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API clamp(abacus_ushort3 x, abacus_ushort3 y, abacus_ushort3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_hadd(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API hadd(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_max(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API max(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_min(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API min(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @param[in] z A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ushort3 x, abacus_ushort3 y, abacus_ushort3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @param[in] z A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API mad_hi(abacus_ushort3 x, abacus_ushort3 y, abacus_ushort3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @param[in] z A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ushort3 x, abacus_ushort3 y, abacus_ushort3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @param[in] z A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API mad_sat(abacus_ushort3 x, abacus_ushort3 y, abacus_ushort3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API mul_hi(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_popcount(abacus_ushort3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API popcount(abacus_ushort3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_rhadd(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API rhadd(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_rotate(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API rotate(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ushort3 x, abacus_ushort3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort3.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API sub_sat(abacus_ushort3 x, abacus_ushort3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_add_sat(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API add_sat(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_clz(abacus_ushort4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API clz(abacus_ushort4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @param[in] z A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort4 x, abacus_ushort4 y, abacus_ushort4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @param[in] z A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API clamp(abacus_ushort4 x, abacus_ushort4 y, abacus_ushort4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_hadd(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API hadd(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_max(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API max(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_min(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API min(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @param[in] z A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ushort4 x, abacus_ushort4 y, abacus_ushort4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @param[in] z A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API mad_hi(abacus_ushort4 x, abacus_ushort4 y, abacus_ushort4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @param[in] z A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ushort4 x, abacus_ushort4 y, abacus_ushort4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @param[in] z A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API mad_sat(abacus_ushort4 x, abacus_ushort4 y, abacus_ushort4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API mul_hi(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_popcount(abacus_ushort4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API popcount(abacus_ushort4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_rhadd(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API rhadd(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_rotate(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API rotate(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ushort4 x, abacus_ushort4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort4.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API sub_sat(abacus_ushort4 x, abacus_ushort4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_add_sat(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API add_sat(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_clz(abacus_ushort8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API clz(abacus_ushort8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @param[in] z A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort8 x, abacus_ushort8 y, abacus_ushort8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @param[in] z A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API clamp(abacus_ushort8 x, abacus_ushort8 y, abacus_ushort8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_hadd(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API hadd(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_max(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API max(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_min(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API min(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @param[in] z A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ushort8 x, abacus_ushort8 y, abacus_ushort8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @param[in] z A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API mad_hi(abacus_ushort8 x, abacus_ushort8 y, abacus_ushort8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @param[in] z A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ushort8 x, abacus_ushort8 y, abacus_ushort8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @param[in] z A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API mad_sat(abacus_ushort8 x, abacus_ushort8 y, abacus_ushort8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API mul_hi(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_popcount(abacus_ushort8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API popcount(abacus_ushort8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_rhadd(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API rhadd(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_rotate(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API rotate(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ushort8 x, abacus_ushort8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort8.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API sub_sat(abacus_ushort8 x, abacus_ushort8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_add_sat(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API add_sat(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_clz(abacus_ushort16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API clz(abacus_ushort16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @param[in] z A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort16 x, abacus_ushort16 y, abacus_ushort16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @param[in] z A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API clamp(abacus_ushort16 x, abacus_ushort16 y, abacus_ushort16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_hadd(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API hadd(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_max(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API max(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_min(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API min(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @param[in] z A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ushort16 x, abacus_ushort16 y, abacus_ushort16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @param[in] z A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API mad_hi(abacus_ushort16 x, abacus_ushort16 y, abacus_ushort16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @param[in] z A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ushort16 x, abacus_ushort16 y, abacus_ushort16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @param[in] z A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API mad_sat(abacus_ushort16 x, abacus_ushort16 y, abacus_ushort16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API mul_hi(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_popcount(abacus_ushort16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API popcount(abacus_ushort16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_rhadd(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API rhadd(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_rotate(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API rotate(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ushort16 x, abacus_ushort16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort16.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API sub_sat(abacus_ushort16 x, abacus_ushort16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uint ABACUS_EXPORT_API __abacus_add_sat(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API add_sat(abacus_uint x, abacus_uint y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uint.
/// @return      A abacus_uint.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uint ABACUS_EXPORT_API __abacus_clz(abacus_uint x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API clz(abacus_uint x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint ABACUS_EXPORT_API __abacus_clamp(abacus_uint x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API clamp(abacus_uint x, abacus_uint y, abacus_uint z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint ABACUS_EXPORT_API __abacus_hadd(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API hadd(abacus_uint x, abacus_uint y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint ABACUS_EXPORT_API __abacus_max(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API max(abacus_uint x, abacus_uint y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint ABACUS_EXPORT_API __abacus_min(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API min(abacus_uint x, abacus_uint y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uint ABACUS_EXPORT_API __abacus_mad_hi(abacus_uint x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API mad_hi(abacus_uint x, abacus_uint y, abacus_uint z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uint ABACUS_EXPORT_API __abacus_mad_sat(abacus_uint x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API mad_sat(abacus_uint x, abacus_uint y, abacus_uint z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uint ABACUS_EXPORT_API __abacus_mul_hi(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API mul_hi(abacus_uint x, abacus_uint y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uint.
/// @return      A abacus_uint.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uint ABACUS_EXPORT_API __abacus_popcount(abacus_uint x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API popcount(abacus_uint x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint ABACUS_EXPORT_API __abacus_rhadd(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API rhadd(abacus_uint x, abacus_uint y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uint ABACUS_EXPORT_API __abacus_rotate(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API rotate(abacus_uint x, abacus_uint y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uint ABACUS_EXPORT_API __abacus_sub_sat(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API sub_sat(abacus_uint x, abacus_uint y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uint2 ABACUS_EXPORT_API __abacus_add_sat(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API add_sat(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uint2.
/// @return      A abacus_uint2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uint2 ABACUS_EXPORT_API __abacus_clz(abacus_uint2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API clz(abacus_uint2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint2 ABACUS_EXPORT_API __abacus_clamp(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API clamp(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint2 ABACUS_EXPORT_API __abacus_hadd(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API hadd(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint2 ABACUS_EXPORT_API __abacus_max(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API max(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint2 ABACUS_EXPORT_API __abacus_min(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API min(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uint2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API mad_hi(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uint2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API mad_sat(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uint2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API mul_hi(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uint2.
/// @return      A abacus_uint2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uint2 ABACUS_EXPORT_API __abacus_popcount(abacus_uint2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API popcount(abacus_uint2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint2 ABACUS_EXPORT_API __abacus_rhadd(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API rhadd(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uint2 ABACUS_EXPORT_API __abacus_rotate(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API rotate(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uint2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API sub_sat(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uint3 ABACUS_EXPORT_API __abacus_add_sat(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API add_sat(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uint3.
/// @return      A abacus_uint3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uint3 ABACUS_EXPORT_API __abacus_clz(abacus_uint3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API clz(abacus_uint3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint3 ABACUS_EXPORT_API __abacus_clamp(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API clamp(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint3 ABACUS_EXPORT_API __abacus_hadd(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API hadd(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint3 ABACUS_EXPORT_API __abacus_max(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API max(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint3 ABACUS_EXPORT_API __abacus_min(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API min(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uint3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API mad_hi(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uint3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API mad_sat(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uint3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API mul_hi(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uint3.
/// @return      A abacus_uint3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uint3 ABACUS_EXPORT_API __abacus_popcount(abacus_uint3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API popcount(abacus_uint3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint3 ABACUS_EXPORT_API __abacus_rhadd(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API rhadd(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uint3 ABACUS_EXPORT_API __abacus_rotate(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API rotate(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uint3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API sub_sat(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uint4 ABACUS_EXPORT_API __abacus_add_sat(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API add_sat(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uint4.
/// @return      A abacus_uint4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uint4 ABACUS_EXPORT_API __abacus_clz(abacus_uint4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API clz(abacus_uint4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint4 ABACUS_EXPORT_API __abacus_clamp(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API clamp(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint4 ABACUS_EXPORT_API __abacus_hadd(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API hadd(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint4 ABACUS_EXPORT_API __abacus_max(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API max(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint4 ABACUS_EXPORT_API __abacus_min(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API min(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uint4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API mad_hi(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uint4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API mad_sat(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uint4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API mul_hi(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uint4.
/// @return      A abacus_uint4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uint4 ABACUS_EXPORT_API __abacus_popcount(abacus_uint4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API popcount(abacus_uint4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint4 ABACUS_EXPORT_API __abacus_rhadd(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API rhadd(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uint4 ABACUS_EXPORT_API __abacus_rotate(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API rotate(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uint4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API sub_sat(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uint8 ABACUS_EXPORT_API __abacus_add_sat(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API add_sat(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uint8.
/// @return      A abacus_uint8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uint8 ABACUS_EXPORT_API __abacus_clz(abacus_uint8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API clz(abacus_uint8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint8 ABACUS_EXPORT_API __abacus_clamp(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API clamp(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint8 ABACUS_EXPORT_API __abacus_hadd(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API hadd(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint8 ABACUS_EXPORT_API __abacus_max(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API max(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint8 ABACUS_EXPORT_API __abacus_min(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API min(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uint8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API mad_hi(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uint8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API mad_sat(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uint8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API mul_hi(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uint8.
/// @return      A abacus_uint8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uint8 ABACUS_EXPORT_API __abacus_popcount(abacus_uint8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API popcount(abacus_uint8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint8 ABACUS_EXPORT_API __abacus_rhadd(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API rhadd(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uint8 ABACUS_EXPORT_API __abacus_rotate(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API rotate(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uint8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API sub_sat(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_uint16 ABACUS_EXPORT_API __abacus_add_sat(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API add_sat(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_uint16.
/// @return      A abacus_uint16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_uint16 ABACUS_EXPORT_API __abacus_clz(abacus_uint16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API clz(abacus_uint16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint16 ABACUS_EXPORT_API __abacus_clamp(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API clamp(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint16 ABACUS_EXPORT_API __abacus_hadd(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API hadd(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint16 ABACUS_EXPORT_API __abacus_max(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API max(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint16 ABACUS_EXPORT_API __abacus_min(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API min(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_uint16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API mad_hi(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_uint16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API mad_sat(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_uint16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API mul_hi(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_uint16.
/// @return      A abacus_uint16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_uint16 ABACUS_EXPORT_API __abacus_popcount(abacus_uint16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API popcount(abacus_uint16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_uint16 ABACUS_EXPORT_API __abacus_rhadd(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API rhadd(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_uint16 ABACUS_EXPORT_API __abacus_rotate(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API rotate(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_uint16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API sub_sat(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ulong ABACUS_EXPORT_API __abacus_add_sat(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API add_sat(abacus_ulong x, abacus_ulong y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ulong.
/// @return      A abacus_ulong.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ulong ABACUS_EXPORT_API __abacus_clz(abacus_ulong x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API clz(abacus_ulong x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong ABACUS_EXPORT_API __abacus_clamp(abacus_ulong x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API clamp(abacus_ulong x, abacus_ulong y, abacus_ulong z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong ABACUS_EXPORT_API __abacus_hadd(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API hadd(abacus_ulong x, abacus_ulong y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong ABACUS_EXPORT_API __abacus_max(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API max(abacus_ulong x, abacus_ulong y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong ABACUS_EXPORT_API __abacus_min(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API min(abacus_ulong x, abacus_ulong y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ulong ABACUS_EXPORT_API __abacus_mad_hi(abacus_ulong x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API mad_hi(abacus_ulong x, abacus_ulong y, abacus_ulong z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ulong ABACUS_EXPORT_API __abacus_mad_sat(abacus_ulong x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API mad_sat(abacus_ulong x, abacus_ulong y, abacus_ulong z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ulong ABACUS_EXPORT_API __abacus_mul_hi(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API mul_hi(abacus_ulong x, abacus_ulong y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ulong.
/// @return      A abacus_ulong.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ulong ABACUS_EXPORT_API __abacus_popcount(abacus_ulong x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API popcount(abacus_ulong x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong ABACUS_EXPORT_API __abacus_rhadd(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API rhadd(abacus_ulong x, abacus_ulong y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ulong ABACUS_EXPORT_API __abacus_rotate(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API rotate(abacus_ulong x, abacus_ulong y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ulong ABACUS_EXPORT_API __abacus_sub_sat(abacus_ulong x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ulong.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong.
inline abacus_ulong ABACUS_API sub_sat(abacus_ulong x, abacus_ulong y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_add_sat(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API add_sat(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_clz(abacus_ulong2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API clz(abacus_ulong2 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @param[in] z A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong2 x, abacus_ulong2 y, abacus_ulong2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @param[in] z A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API clamp(abacus_ulong2 x, abacus_ulong2 y, abacus_ulong2 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_hadd(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API hadd(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_max(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API max(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_min(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API min(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @param[in] z A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ulong2 x, abacus_ulong2 y, abacus_ulong2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @param[in] z A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API mad_hi(abacus_ulong2 x, abacus_ulong2 y, abacus_ulong2 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @param[in] z A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ulong2 x, abacus_ulong2 y, abacus_ulong2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @param[in] z A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API mad_sat(abacus_ulong2 x, abacus_ulong2 y, abacus_ulong2 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API mul_hi(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_popcount(abacus_ulong2 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API popcount(abacus_ulong2 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_rhadd(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API rhadd(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_rotate(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API rotate(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ulong2 x, abacus_ulong2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong2.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API sub_sat(abacus_ulong2 x, abacus_ulong2 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_add_sat(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API add_sat(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_clz(abacus_ulong3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API clz(abacus_ulong3 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @param[in] z A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong3 x, abacus_ulong3 y, abacus_ulong3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @param[in] z A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API clamp(abacus_ulong3 x, abacus_ulong3 y, abacus_ulong3 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_hadd(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API hadd(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_max(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API max(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_min(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API min(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @param[in] z A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ulong3 x, abacus_ulong3 y, abacus_ulong3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @param[in] z A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API mad_hi(abacus_ulong3 x, abacus_ulong3 y, abacus_ulong3 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @param[in] z A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ulong3 x, abacus_ulong3 y, abacus_ulong3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @param[in] z A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API mad_sat(abacus_ulong3 x, abacus_ulong3 y, abacus_ulong3 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API mul_hi(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_popcount(abacus_ulong3 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API popcount(abacus_ulong3 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_rhadd(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API rhadd(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_rotate(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API rotate(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ulong3 x, abacus_ulong3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong3.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API sub_sat(abacus_ulong3 x, abacus_ulong3 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_add_sat(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API add_sat(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_clz(abacus_ulong4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API clz(abacus_ulong4 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @param[in] z A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong4 x, abacus_ulong4 y, abacus_ulong4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @param[in] z A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API clamp(abacus_ulong4 x, abacus_ulong4 y, abacus_ulong4 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_hadd(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API hadd(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_max(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API max(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_min(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API min(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @param[in] z A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ulong4 x, abacus_ulong4 y, abacus_ulong4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @param[in] z A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API mad_hi(abacus_ulong4 x, abacus_ulong4 y, abacus_ulong4 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @param[in] z A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ulong4 x, abacus_ulong4 y, abacus_ulong4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @param[in] z A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API mad_sat(abacus_ulong4 x, abacus_ulong4 y, abacus_ulong4 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API mul_hi(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_popcount(abacus_ulong4 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API popcount(abacus_ulong4 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_rhadd(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API rhadd(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_rotate(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API rotate(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ulong4 x, abacus_ulong4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong4.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API sub_sat(abacus_ulong4 x, abacus_ulong4 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_add_sat(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API add_sat(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_clz(abacus_ulong8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API clz(abacus_ulong8 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @param[in] z A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong8 x, abacus_ulong8 y, abacus_ulong8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @param[in] z A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API clamp(abacus_ulong8 x, abacus_ulong8 y, abacus_ulong8 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_hadd(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API hadd(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_max(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API max(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_min(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API min(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @param[in] z A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ulong8 x, abacus_ulong8 y, abacus_ulong8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @param[in] z A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API mad_hi(abacus_ulong8 x, abacus_ulong8 y, abacus_ulong8 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @param[in] z A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ulong8 x, abacus_ulong8 y, abacus_ulong8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @param[in] z A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API mad_sat(abacus_ulong8 x, abacus_ulong8 y, abacus_ulong8 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API mul_hi(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_popcount(abacus_ulong8 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API popcount(abacus_ulong8 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_rhadd(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API rhadd(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_rotate(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API rotate(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ulong8 x, abacus_ulong8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong8.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API sub_sat(abacus_ulong8 x, abacus_ulong8 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief (x + y) and saturates result.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// add_sat returns (x + y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 add_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/add_sat.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_add_sat(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_add_sat.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API add_sat(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_add_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The number of leading 0-bits in x.
/// @param[in] x A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// clz returns the number of leading 0-bits in x, starting at the most 
/// significant bit position.
///
/// Standards compliant implementation of OpenCL 1.2 clz.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clz.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_clz(abacus_ulong16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clz.
/// @param[in] x A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API clz(abacus_ulong16 x) {
  return __abacus_clz(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @param[in] z A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong16 x, abacus_ulong16 y, abacus_ulong16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @param[in] z A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API clamp(abacus_ulong16 x, abacus_ulong16 y, abacus_ulong16 z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// hadd returns (x + y) >> 1. The intermediate sum does not modulo overflow.
///
/// Standards compliant implementation of OpenCL 1.2 hadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_hadd(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_hadd.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API hadd(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_hadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_max(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API max(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_min(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API min(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul_hi(a , b) + c.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @param[in] z A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// mad_hi returns __abacus_mul_hi(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_hi.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_mad_hi(abacus_ulong16 x, abacus_ulong16 y, abacus_ulong16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_hi.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @param[in] z A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API mad_hi(abacus_ulong16 x, abacus_ulong16 y, abacus_ulong16 z) {
  return __abacus_mad_hi(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief a * b + c and saturate the result.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @param[in] z A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// mad_hi a * b + c and saturate the result.
///
/// Standards compliant implementation of OpenCL 1.2 mad_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad_sat.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_mad_sat(abacus_ulong16 x, abacus_ulong16 y, abacus_ulong16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad_sat.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @param[in] z A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API mad_sat(abacus_ulong16 x, abacus_ulong16 y, abacus_ulong16 z) {
  return __abacus_mad_sat(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief High half of the product of x and y.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// x * y and returns the high half of the product of x and y.
///
/// Standards compliant implementation of OpenCL 1.2 mul_hi.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul_hi.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_mul_hi(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul_hi.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API mul_hi(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_mul_hi(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Returns the number of non-zero bits in x.
/// @param[in] x A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// popcount returns the number of non-zero bits in x.
///
/// Standards compliant implementation of OpenCL 1.2 popcount.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/popcount.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_popcount(abacus_ulong16 x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_popcount.
/// @param[in] x A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API popcount(abacus_ulong16 x) {
  return __abacus_popcount(x);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x + y) >> 1 without modulo overflow.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// rhadd returns (x + y + 1) >> 1. The intermediate sum does not modulo
///   overflow.
///
/// Standards compliant implementation of OpenCL 1.2 rhadd.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/hadd.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_rhadd(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rhadd.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API rhadd(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_rhadd(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Rotate bits left.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// For each element in v, the bits are shifted left by the number of bits given 
/// by the corresponding element in i (subject to usual shift modulo rules). 
/// Bits shifted off the left side of the element are shifted back in from the 
/// right.
///
/// Standards compliant implementation of OpenCL 1.2 rotate.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/rotate.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_rotate(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_rotate.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API rotate(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_rotate(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief (x - y) and saturates result.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
///
/// sub_sat returns (x - y) and saturates result.
///
/// Standards compliant implementation of OpenCL 1.2 sub_sat.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sub_sat.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_sub_sat(abacus_ulong16 x, abacus_ulong16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_sub_sat.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong16.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API sub_sat(abacus_ulong16 x, abacus_ulong16 y) {
  return __abacus_sub_sat(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_char.
/// @param[in] lo A abacus_uchar.
/// @return       A abacus_short.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_short ABACUS_EXPORT_API __abacus_upsample(abacus_char hi, abacus_uchar lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_char.
/// @param[in] lo A abacus_uchar.
/// @return       A abacus_short.
inline abacus_short ABACUS_API upsample(abacus_char hi, abacus_uchar lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uchar.
/// @param[in] lo A abacus_uchar.
/// @return       A abacus_ushort.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ushort ABACUS_EXPORT_API __abacus_upsample(abacus_uchar hi, abacus_uchar lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uchar.
/// @param[in] lo A abacus_uchar.
/// @return       A abacus_ushort.
inline abacus_ushort ABACUS_API upsample(abacus_uchar hi, abacus_uchar lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_char2.
/// @param[in] lo A abacus_uchar2.
/// @return       A abacus_short2.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_short2 ABACUS_EXPORT_API __abacus_upsample(abacus_char2 hi, abacus_uchar2 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_char2.
/// @param[in] lo A abacus_uchar2.
/// @return       A abacus_short2.
inline abacus_short2 ABACUS_API upsample(abacus_char2 hi, abacus_uchar2 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uchar2.
/// @param[in] lo A abacus_uchar2.
/// @return       A abacus_ushort2.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_upsample(abacus_uchar2 hi, abacus_uchar2 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uchar2.
/// @param[in] lo A abacus_uchar2.
/// @return       A abacus_ushort2.
inline abacus_ushort2 ABACUS_API upsample(abacus_uchar2 hi, abacus_uchar2 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_char3.
/// @param[in] lo A abacus_uchar3.
/// @return       A abacus_short3.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_short3 ABACUS_EXPORT_API __abacus_upsample(abacus_char3 hi, abacus_uchar3 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_char3.
/// @param[in] lo A abacus_uchar3.
/// @return       A abacus_short3.
inline abacus_short3 ABACUS_API upsample(abacus_char3 hi, abacus_uchar3 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uchar3.
/// @param[in] lo A abacus_uchar3.
/// @return       A abacus_ushort3.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_upsample(abacus_uchar3 hi, abacus_uchar3 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uchar3.
/// @param[in] lo A abacus_uchar3.
/// @return       A abacus_ushort3.
inline abacus_ushort3 ABACUS_API upsample(abacus_uchar3 hi, abacus_uchar3 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_char4.
/// @param[in] lo A abacus_uchar4.
/// @return       A abacus_short4.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_short4 ABACUS_EXPORT_API __abacus_upsample(abacus_char4 hi, abacus_uchar4 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_char4.
/// @param[in] lo A abacus_uchar4.
/// @return       A abacus_short4.
inline abacus_short4 ABACUS_API upsample(abacus_char4 hi, abacus_uchar4 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uchar4.
/// @param[in] lo A abacus_uchar4.
/// @return       A abacus_ushort4.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_upsample(abacus_uchar4 hi, abacus_uchar4 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uchar4.
/// @param[in] lo A abacus_uchar4.
/// @return       A abacus_ushort4.
inline abacus_ushort4 ABACUS_API upsample(abacus_uchar4 hi, abacus_uchar4 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_char8.
/// @param[in] lo A abacus_uchar8.
/// @return       A abacus_short8.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_short8 ABACUS_EXPORT_API __abacus_upsample(abacus_char8 hi, abacus_uchar8 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_char8.
/// @param[in] lo A abacus_uchar8.
/// @return       A abacus_short8.
inline abacus_short8 ABACUS_API upsample(abacus_char8 hi, abacus_uchar8 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uchar8.
/// @param[in] lo A abacus_uchar8.
/// @return       A abacus_ushort8.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_upsample(abacus_uchar8 hi, abacus_uchar8 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uchar8.
/// @param[in] lo A abacus_uchar8.
/// @return       A abacus_ushort8.
inline abacus_ushort8 ABACUS_API upsample(abacus_uchar8 hi, abacus_uchar8 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_char16.
/// @param[in] lo A abacus_uchar16.
/// @return       A abacus_short16.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_short16 ABACUS_EXPORT_API __abacus_upsample(abacus_char16 hi, abacus_uchar16 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_char16.
/// @param[in] lo A abacus_uchar16.
/// @return       A abacus_short16.
inline abacus_short16 ABACUS_API upsample(abacus_char16 hi, abacus_uchar16 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uchar16.
/// @param[in] lo A abacus_uchar16.
/// @return       A abacus_ushort16.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_upsample(abacus_uchar16 hi, abacus_uchar16 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uchar16.
/// @param[in] lo A abacus_uchar16.
/// @return       A abacus_ushort16.
inline abacus_ushort16 ABACUS_API upsample(abacus_uchar16 hi, abacus_uchar16 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_short.
/// @param[in] lo A abacus_ushort.
/// @return       A abacus_int.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_int ABACUS_EXPORT_API __abacus_upsample(abacus_short hi, abacus_ushort lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_short.
/// @param[in] lo A abacus_ushort.
/// @return       A abacus_int.
inline abacus_int ABACUS_API upsample(abacus_short hi, abacus_ushort lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_ushort.
/// @param[in] lo A abacus_ushort.
/// @return       A abacus_uint.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_uint ABACUS_EXPORT_API __abacus_upsample(abacus_ushort hi, abacus_ushort lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_ushort.
/// @param[in] lo A abacus_ushort.
/// @return       A abacus_uint.
inline abacus_uint ABACUS_API upsample(abacus_ushort hi, abacus_ushort lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_short2.
/// @param[in] lo A abacus_ushort2.
/// @return       A abacus_int2.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_int2 ABACUS_EXPORT_API __abacus_upsample(abacus_short2 hi, abacus_ushort2 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_short2.
/// @param[in] lo A abacus_ushort2.
/// @return       A abacus_int2.
inline abacus_int2 ABACUS_API upsample(abacus_short2 hi, abacus_ushort2 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_ushort2.
/// @param[in] lo A abacus_ushort2.
/// @return       A abacus_uint2.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_uint2 ABACUS_EXPORT_API __abacus_upsample(abacus_ushort2 hi, abacus_ushort2 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_ushort2.
/// @param[in] lo A abacus_ushort2.
/// @return       A abacus_uint2.
inline abacus_uint2 ABACUS_API upsample(abacus_ushort2 hi, abacus_ushort2 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_short3.
/// @param[in] lo A abacus_ushort3.
/// @return       A abacus_int3.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_int3 ABACUS_EXPORT_API __abacus_upsample(abacus_short3 hi, abacus_ushort3 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_short3.
/// @param[in] lo A abacus_ushort3.
/// @return       A abacus_int3.
inline abacus_int3 ABACUS_API upsample(abacus_short3 hi, abacus_ushort3 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_ushort3.
/// @param[in] lo A abacus_ushort3.
/// @return       A abacus_uint3.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_uint3 ABACUS_EXPORT_API __abacus_upsample(abacus_ushort3 hi, abacus_ushort3 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_ushort3.
/// @param[in] lo A abacus_ushort3.
/// @return       A abacus_uint3.
inline abacus_uint3 ABACUS_API upsample(abacus_ushort3 hi, abacus_ushort3 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_short4.
/// @param[in] lo A abacus_ushort4.
/// @return       A abacus_int4.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_int4 ABACUS_EXPORT_API __abacus_upsample(abacus_short4 hi, abacus_ushort4 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_short4.
/// @param[in] lo A abacus_ushort4.
/// @return       A abacus_int4.
inline abacus_int4 ABACUS_API upsample(abacus_short4 hi, abacus_ushort4 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_ushort4.
/// @param[in] lo A abacus_ushort4.
/// @return       A abacus_uint4.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_uint4 ABACUS_EXPORT_API __abacus_upsample(abacus_ushort4 hi, abacus_ushort4 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_ushort4.
/// @param[in] lo A abacus_ushort4.
/// @return       A abacus_uint4.
inline abacus_uint4 ABACUS_API upsample(abacus_ushort4 hi, abacus_ushort4 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_short8.
/// @param[in] lo A abacus_ushort8.
/// @return       A abacus_int8.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_int8 ABACUS_EXPORT_API __abacus_upsample(abacus_short8 hi, abacus_ushort8 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_short8.
/// @param[in] lo A abacus_ushort8.
/// @return       A abacus_int8.
inline abacus_int8 ABACUS_API upsample(abacus_short8 hi, abacus_ushort8 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_ushort8.
/// @param[in] lo A abacus_ushort8.
/// @return       A abacus_uint8.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_uint8 ABACUS_EXPORT_API __abacus_upsample(abacus_ushort8 hi, abacus_ushort8 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_ushort8.
/// @param[in] lo A abacus_ushort8.
/// @return       A abacus_uint8.
inline abacus_uint8 ABACUS_API upsample(abacus_ushort8 hi, abacus_ushort8 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_short16.
/// @param[in] lo A abacus_ushort16.
/// @return       A abacus_int16.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_int16 ABACUS_EXPORT_API __abacus_upsample(abacus_short16 hi, abacus_ushort16 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_short16.
/// @param[in] lo A abacus_ushort16.
/// @return       A abacus_int16.
inline abacus_int16 ABACUS_API upsample(abacus_short16 hi, abacus_ushort16 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_ushort16.
/// @param[in] lo A abacus_ushort16.
/// @return       A abacus_uint16.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_uint16 ABACUS_EXPORT_API __abacus_upsample(abacus_ushort16 hi, abacus_ushort16 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_ushort16.
/// @param[in] lo A abacus_ushort16.
/// @return       A abacus_uint16.
inline abacus_uint16 ABACUS_API upsample(abacus_ushort16 hi, abacus_ushort16 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_int.
/// @param[in] lo A abacus_uint.
/// @return       A abacus_long.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_long ABACUS_EXPORT_API __abacus_upsample(abacus_int hi, abacus_uint lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_int.
/// @param[in] lo A abacus_uint.
/// @return       A abacus_long.
inline abacus_long ABACUS_API upsample(abacus_int hi, abacus_uint lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uint.
/// @param[in] lo A abacus_uint.
/// @return       A abacus_ulong.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ulong ABACUS_EXPORT_API __abacus_upsample(abacus_uint hi, abacus_uint lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uint.
/// @param[in] lo A abacus_uint.
/// @return       A abacus_ulong.
inline abacus_ulong ABACUS_API upsample(abacus_uint hi, abacus_uint lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_int2.
/// @param[in] lo A abacus_uint2.
/// @return       A abacus_long2.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_long2 ABACUS_EXPORT_API __abacus_upsample(abacus_int2 hi, abacus_uint2 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_int2.
/// @param[in] lo A abacus_uint2.
/// @return       A abacus_long2.
inline abacus_long2 ABACUS_API upsample(abacus_int2 hi, abacus_uint2 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uint2.
/// @param[in] lo A abacus_uint2.
/// @return       A abacus_ulong2.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_upsample(abacus_uint2 hi, abacus_uint2 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uint2.
/// @param[in] lo A abacus_uint2.
/// @return       A abacus_ulong2.
inline abacus_ulong2 ABACUS_API upsample(abacus_uint2 hi, abacus_uint2 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_int3.
/// @param[in] lo A abacus_uint3.
/// @return       A abacus_long3.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_long3 ABACUS_EXPORT_API __abacus_upsample(abacus_int3 hi, abacus_uint3 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_int3.
/// @param[in] lo A abacus_uint3.
/// @return       A abacus_long3.
inline abacus_long3 ABACUS_API upsample(abacus_int3 hi, abacus_uint3 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uint3.
/// @param[in] lo A abacus_uint3.
/// @return       A abacus_ulong3.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_upsample(abacus_uint3 hi, abacus_uint3 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uint3.
/// @param[in] lo A abacus_uint3.
/// @return       A abacus_ulong3.
inline abacus_ulong3 ABACUS_API upsample(abacus_uint3 hi, abacus_uint3 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_int4.
/// @param[in] lo A abacus_uint4.
/// @return       A abacus_long4.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_long4 ABACUS_EXPORT_API __abacus_upsample(abacus_int4 hi, abacus_uint4 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_int4.
/// @param[in] lo A abacus_uint4.
/// @return       A abacus_long4.
inline abacus_long4 ABACUS_API upsample(abacus_int4 hi, abacus_uint4 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uint4.
/// @param[in] lo A abacus_uint4.
/// @return       A abacus_ulong4.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_upsample(abacus_uint4 hi, abacus_uint4 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uint4.
/// @param[in] lo A abacus_uint4.
/// @return       A abacus_ulong4.
inline abacus_ulong4 ABACUS_API upsample(abacus_uint4 hi, abacus_uint4 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_int8.
/// @param[in] lo A abacus_uint8.
/// @return       A abacus_long8.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_long8 ABACUS_EXPORT_API __abacus_upsample(abacus_int8 hi, abacus_uint8 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_int8.
/// @param[in] lo A abacus_uint8.
/// @return       A abacus_long8.
inline abacus_long8 ABACUS_API upsample(abacus_int8 hi, abacus_uint8 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uint8.
/// @param[in] lo A abacus_uint8.
/// @return       A abacus_ulong8.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_upsample(abacus_uint8 hi, abacus_uint8 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uint8.
/// @param[in] lo A abacus_uint8.
/// @return       A abacus_ulong8.
inline abacus_ulong8 ABACUS_API upsample(abacus_uint8 hi, abacus_uint8 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_int16.
/// @param[in] lo A abacus_uint16.
/// @return       A abacus_long16.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_long16 ABACUS_EXPORT_API __abacus_upsample(abacus_int16 hi, abacus_uint16 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_int16.
/// @param[in] lo A abacus_uint16.
/// @return       A abacus_long16.
inline abacus_long16 ABACUS_API upsample(abacus_int16 hi, abacus_uint16 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Combines two smaller types into a large one.
/// @param[in] hi A abacus_uint16.
/// @param[in] lo A abacus_uint16.
/// @return       A abacus_ulong16.
///
/// Standards compliant implementation of OpenCL 1.2 upsample.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/upsample.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_upsample(abacus_uint16 hi, abacus_uint16 lo);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_upsample.
/// @param[in] hi A abacus_uint16.
/// @param[in] lo A abacus_uint16.
/// @return       A abacus_ulong16.
inline abacus_ulong16 ABACUS_API upsample(abacus_uint16 hi, abacus_uint16 lo) {
  return __abacus_upsample(hi, lo);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif
/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char2 ABACUS_EXPORT_API __abacus_clamp(abacus_char2 x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API clamp(abacus_char2 x, abacus_char y, abacus_char z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char.
/// @return      A abacus_char2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char2 ABACUS_EXPORT_API __abacus_max(abacus_char2 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API max(abacus_char2 x, abacus_char y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char.
/// @return      A abacus_char2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char2 ABACUS_EXPORT_API __abacus_min(abacus_char2 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char2.
/// @param[in] y A abacus_char.
/// @return      A abacus_char2.
inline abacus_char2 ABACUS_API min(abacus_char2 x, abacus_char y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char3 ABACUS_EXPORT_API __abacus_clamp(abacus_char3 x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API clamp(abacus_char3 x, abacus_char y, abacus_char z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char.
/// @return      A abacus_char3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char3 ABACUS_EXPORT_API __abacus_max(abacus_char3 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API max(abacus_char3 x, abacus_char y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char.
/// @return      A abacus_char3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char3 ABACUS_EXPORT_API __abacus_min(abacus_char3 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char3.
/// @param[in] y A abacus_char.
/// @return      A abacus_char3.
inline abacus_char3 ABACUS_API min(abacus_char3 x, abacus_char y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char4 ABACUS_EXPORT_API __abacus_clamp(abacus_char4 x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API clamp(abacus_char4 x, abacus_char y, abacus_char z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char.
/// @return      A abacus_char4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char4 ABACUS_EXPORT_API __abacus_max(abacus_char4 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API max(abacus_char4 x, abacus_char y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char.
/// @return      A abacus_char4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char4 ABACUS_EXPORT_API __abacus_min(abacus_char4 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char4.
/// @param[in] y A abacus_char.
/// @return      A abacus_char4.
inline abacus_char4 ABACUS_API min(abacus_char4 x, abacus_char y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char8 ABACUS_EXPORT_API __abacus_clamp(abacus_char8 x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API clamp(abacus_char8 x, abacus_char y, abacus_char z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char.
/// @return      A abacus_char8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char8 ABACUS_EXPORT_API __abacus_max(abacus_char8 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API max(abacus_char8 x, abacus_char y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char.
/// @return      A abacus_char8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char8 ABACUS_EXPORT_API __abacus_min(abacus_char8 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char8.
/// @param[in] y A abacus_char.
/// @return      A abacus_char8.
inline abacus_char8 ABACUS_API min(abacus_char8 x, abacus_char y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_char16 ABACUS_EXPORT_API __abacus_clamp(abacus_char16 x, abacus_char y, abacus_char z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char.
/// @param[in] z A abacus_char.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API clamp(abacus_char16 x, abacus_char y, abacus_char z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char.
/// @return      A abacus_char16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_char16 ABACUS_EXPORT_API __abacus_max(abacus_char16 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API max(abacus_char16 x, abacus_char y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char.
/// @return      A abacus_char16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_char16 ABACUS_EXPORT_API __abacus_min(abacus_char16 x, abacus_char y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_char16.
/// @param[in] y A abacus_char.
/// @return      A abacus_char16.
inline abacus_char16 ABACUS_API min(abacus_char16 x, abacus_char y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short2 ABACUS_EXPORT_API __abacus_clamp(abacus_short2 x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API clamp(abacus_short2 x, abacus_short y, abacus_short z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short.
/// @return      A abacus_short2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short2 ABACUS_EXPORT_API __abacus_max(abacus_short2 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API max(abacus_short2 x, abacus_short y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short.
/// @return      A abacus_short2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short2 ABACUS_EXPORT_API __abacus_min(abacus_short2 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short2.
/// @param[in] y A abacus_short.
/// @return      A abacus_short2.
inline abacus_short2 ABACUS_API min(abacus_short2 x, abacus_short y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short3 ABACUS_EXPORT_API __abacus_clamp(abacus_short3 x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API clamp(abacus_short3 x, abacus_short y, abacus_short z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short.
/// @return      A abacus_short3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short3 ABACUS_EXPORT_API __abacus_max(abacus_short3 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API max(abacus_short3 x, abacus_short y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short.
/// @return      A abacus_short3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short3 ABACUS_EXPORT_API __abacus_min(abacus_short3 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short3.
/// @param[in] y A abacus_short.
/// @return      A abacus_short3.
inline abacus_short3 ABACUS_API min(abacus_short3 x, abacus_short y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short4 ABACUS_EXPORT_API __abacus_clamp(abacus_short4 x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API clamp(abacus_short4 x, abacus_short y, abacus_short z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short.
/// @return      A abacus_short4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short4 ABACUS_EXPORT_API __abacus_max(abacus_short4 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API max(abacus_short4 x, abacus_short y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short.
/// @return      A abacus_short4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short4 ABACUS_EXPORT_API __abacus_min(abacus_short4 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short4.
/// @param[in] y A abacus_short.
/// @return      A abacus_short4.
inline abacus_short4 ABACUS_API min(abacus_short4 x, abacus_short y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short8 ABACUS_EXPORT_API __abacus_clamp(abacus_short8 x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API clamp(abacus_short8 x, abacus_short y, abacus_short z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short.
/// @return      A abacus_short8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short8 ABACUS_EXPORT_API __abacus_max(abacus_short8 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API max(abacus_short8 x, abacus_short y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short.
/// @return      A abacus_short8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short8 ABACUS_EXPORT_API __abacus_min(abacus_short8 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short8.
/// @param[in] y A abacus_short.
/// @return      A abacus_short8.
inline abacus_short8 ABACUS_API min(abacus_short8 x, abacus_short y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_short16 ABACUS_EXPORT_API __abacus_clamp(abacus_short16 x, abacus_short y, abacus_short z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short.
/// @param[in] z A abacus_short.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API clamp(abacus_short16 x, abacus_short y, abacus_short z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short.
/// @return      A abacus_short16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_short16 ABACUS_EXPORT_API __abacus_max(abacus_short16 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API max(abacus_short16 x, abacus_short y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short.
/// @return      A abacus_short16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_short16 ABACUS_EXPORT_API __abacus_min(abacus_short16 x, abacus_short y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_short16.
/// @param[in] y A abacus_short.
/// @return      A abacus_short16.
inline abacus_short16 ABACUS_API min(abacus_short16 x, abacus_short y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int2 ABACUS_EXPORT_API __abacus_clamp(abacus_int2 x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API clamp(abacus_int2 x, abacus_int y, abacus_int z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int.
/// @return      A abacus_int2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int2 ABACUS_EXPORT_API __abacus_max(abacus_int2 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API max(abacus_int2 x, abacus_int y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int.
/// @return      A abacus_int2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int2 ABACUS_EXPORT_API __abacus_min(abacus_int2 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API min(abacus_int2 x, abacus_int y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int3 ABACUS_EXPORT_API __abacus_clamp(abacus_int3 x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API clamp(abacus_int3 x, abacus_int y, abacus_int z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int.
/// @return      A abacus_int3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int3 ABACUS_EXPORT_API __abacus_max(abacus_int3 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API max(abacus_int3 x, abacus_int y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int.
/// @return      A abacus_int3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int3 ABACUS_EXPORT_API __abacus_min(abacus_int3 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API min(abacus_int3 x, abacus_int y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int4 ABACUS_EXPORT_API __abacus_clamp(abacus_int4 x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API clamp(abacus_int4 x, abacus_int y, abacus_int z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int.
/// @return      A abacus_int4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int4 ABACUS_EXPORT_API __abacus_max(abacus_int4 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API max(abacus_int4 x, abacus_int y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int.
/// @return      A abacus_int4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int4 ABACUS_EXPORT_API __abacus_min(abacus_int4 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API min(abacus_int4 x, abacus_int y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int8 ABACUS_EXPORT_API __abacus_clamp(abacus_int8 x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API clamp(abacus_int8 x, abacus_int y, abacus_int z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int.
/// @return      A abacus_int8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int8 ABACUS_EXPORT_API __abacus_max(abacus_int8 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API max(abacus_int8 x, abacus_int y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int.
/// @return      A abacus_int8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int8 ABACUS_EXPORT_API __abacus_min(abacus_int8 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API min(abacus_int8 x, abacus_int y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_int16 ABACUS_EXPORT_API __abacus_clamp(abacus_int16 x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API clamp(abacus_int16 x, abacus_int y, abacus_int z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int.
/// @return      A abacus_int16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_int16 ABACUS_EXPORT_API __abacus_max(abacus_int16 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API max(abacus_int16 x, abacus_int y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int.
/// @return      A abacus_int16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_int16 ABACUS_EXPORT_API __abacus_min(abacus_int16 x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API min(abacus_int16 x, abacus_int y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long2 ABACUS_EXPORT_API __abacus_clamp(abacus_long2 x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API clamp(abacus_long2 x, abacus_long y, abacus_long z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long.
/// @return      A abacus_long2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long2 ABACUS_EXPORT_API __abacus_max(abacus_long2 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API max(abacus_long2 x, abacus_long y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long.
/// @return      A abacus_long2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long2 ABACUS_EXPORT_API __abacus_min(abacus_long2 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long2.
/// @param[in] y A abacus_long.
/// @return      A abacus_long2.
inline abacus_long2 ABACUS_API min(abacus_long2 x, abacus_long y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long3 ABACUS_EXPORT_API __abacus_clamp(abacus_long3 x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API clamp(abacus_long3 x, abacus_long y, abacus_long z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long.
/// @return      A abacus_long3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long3 ABACUS_EXPORT_API __abacus_max(abacus_long3 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API max(abacus_long3 x, abacus_long y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long.
/// @return      A abacus_long3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long3 ABACUS_EXPORT_API __abacus_min(abacus_long3 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long3.
/// @param[in] y A abacus_long.
/// @return      A abacus_long3.
inline abacus_long3 ABACUS_API min(abacus_long3 x, abacus_long y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long4 ABACUS_EXPORT_API __abacus_clamp(abacus_long4 x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API clamp(abacus_long4 x, abacus_long y, abacus_long z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long.
/// @return      A abacus_long4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long4 ABACUS_EXPORT_API __abacus_max(abacus_long4 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API max(abacus_long4 x, abacus_long y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long.
/// @return      A abacus_long4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long4 ABACUS_EXPORT_API __abacus_min(abacus_long4 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long4.
/// @param[in] y A abacus_long.
/// @return      A abacus_long4.
inline abacus_long4 ABACUS_API min(abacus_long4 x, abacus_long y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long8 ABACUS_EXPORT_API __abacus_clamp(abacus_long8 x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API clamp(abacus_long8 x, abacus_long y, abacus_long z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long.
/// @return      A abacus_long8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long8 ABACUS_EXPORT_API __abacus_max(abacus_long8 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API max(abacus_long8 x, abacus_long y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long.
/// @return      A abacus_long8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long8 ABACUS_EXPORT_API __abacus_min(abacus_long8 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long8.
/// @param[in] y A abacus_long.
/// @return      A abacus_long8.
inline abacus_long8 ABACUS_API min(abacus_long8 x, abacus_long y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_long16 ABACUS_EXPORT_API __abacus_clamp(abacus_long16 x, abacus_long y, abacus_long z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long.
/// @param[in] z A abacus_long.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API clamp(abacus_long16 x, abacus_long y, abacus_long z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long.
/// @return      A abacus_long16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_long16 ABACUS_EXPORT_API __abacus_max(abacus_long16 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API max(abacus_long16 x, abacus_long y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long.
/// @return      A abacus_long16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_long16 ABACUS_EXPORT_API __abacus_min(abacus_long16 x, abacus_long y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_long16.
/// @param[in] y A abacus_long.
/// @return      A abacus_long16.
inline abacus_long16 ABACUS_API min(abacus_long16 x, abacus_long y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar2 x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API clamp(abacus_uchar2 x, abacus_uchar y, abacus_uchar z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_max(abacus_uchar2 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API max(abacus_uchar2 x, abacus_uchar y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar2 ABACUS_EXPORT_API __abacus_min(abacus_uchar2 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar2.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar2.
inline abacus_uchar2 ABACUS_API min(abacus_uchar2 x, abacus_uchar y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar3 x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API clamp(abacus_uchar3 x, abacus_uchar y, abacus_uchar z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_max(abacus_uchar3 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API max(abacus_uchar3 x, abacus_uchar y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar3 ABACUS_EXPORT_API __abacus_min(abacus_uchar3 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar3.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar3.
inline abacus_uchar3 ABACUS_API min(abacus_uchar3 x, abacus_uchar y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar4 x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API clamp(abacus_uchar4 x, abacus_uchar y, abacus_uchar z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_max(abacus_uchar4 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API max(abacus_uchar4 x, abacus_uchar y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar4 ABACUS_EXPORT_API __abacus_min(abacus_uchar4 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar4.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar4.
inline abacus_uchar4 ABACUS_API min(abacus_uchar4 x, abacus_uchar y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar8 x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API clamp(abacus_uchar8 x, abacus_uchar y, abacus_uchar z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_max(abacus_uchar8 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API max(abacus_uchar8 x, abacus_uchar y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar8 ABACUS_EXPORT_API __abacus_min(abacus_uchar8 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar8.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar8.
inline abacus_uchar8 ABACUS_API min(abacus_uchar8 x, abacus_uchar y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_clamp(abacus_uchar16 x, abacus_uchar y, abacus_uchar z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar.
/// @param[in] z A abacus_uchar.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API clamp(abacus_uchar16 x, abacus_uchar y, abacus_uchar z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_max(abacus_uchar16 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API max(abacus_uchar16 x, abacus_uchar y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uchar16 ABACUS_EXPORT_API __abacus_min(abacus_uchar16 x, abacus_uchar y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uchar16.
/// @param[in] y A abacus_uchar.
/// @return      A abacus_uchar16.
inline abacus_uchar16 ABACUS_API min(abacus_uchar16 x, abacus_uchar y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort2 x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API clamp(abacus_ushort2 x, abacus_ushort y, abacus_ushort z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_max(abacus_ushort2 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API max(abacus_ushort2 x, abacus_ushort y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort2 ABACUS_EXPORT_API __abacus_min(abacus_ushort2 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort2.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort2.
inline abacus_ushort2 ABACUS_API min(abacus_ushort2 x, abacus_ushort y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort3 x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API clamp(abacus_ushort3 x, abacus_ushort y, abacus_ushort z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_max(abacus_ushort3 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API max(abacus_ushort3 x, abacus_ushort y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort3 ABACUS_EXPORT_API __abacus_min(abacus_ushort3 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort3.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort3.
inline abacus_ushort3 ABACUS_API min(abacus_ushort3 x, abacus_ushort y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort4 x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API clamp(abacus_ushort4 x, abacus_ushort y, abacus_ushort z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_max(abacus_ushort4 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API max(abacus_ushort4 x, abacus_ushort y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort4 ABACUS_EXPORT_API __abacus_min(abacus_ushort4 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort4.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort4.
inline abacus_ushort4 ABACUS_API min(abacus_ushort4 x, abacus_ushort y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort8 x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API clamp(abacus_ushort8 x, abacus_ushort y, abacus_ushort z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_max(abacus_ushort8 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API max(abacus_ushort8 x, abacus_ushort y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort8 ABACUS_EXPORT_API __abacus_min(abacus_ushort8 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort8.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort8.
inline abacus_ushort8 ABACUS_API min(abacus_ushort8 x, abacus_ushort y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_clamp(abacus_ushort16 x, abacus_ushort y, abacus_ushort z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort.
/// @param[in] z A abacus_ushort.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API clamp(abacus_ushort16 x, abacus_ushort y, abacus_ushort z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_max(abacus_ushort16 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API max(abacus_ushort16 x, abacus_ushort y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ushort16 ABACUS_EXPORT_API __abacus_min(abacus_ushort16 x, abacus_ushort y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ushort16.
/// @param[in] y A abacus_ushort.
/// @return      A abacus_ushort16.
inline abacus_ushort16 ABACUS_API min(abacus_ushort16 x, abacus_ushort y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint2 ABACUS_EXPORT_API __abacus_clamp(abacus_uint2 x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API clamp(abacus_uint2 x, abacus_uint y, abacus_uint z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint2 ABACUS_EXPORT_API __abacus_max(abacus_uint2 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API max(abacus_uint2 x, abacus_uint y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint2 ABACUS_EXPORT_API __abacus_min(abacus_uint2 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API min(abacus_uint2 x, abacus_uint y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint3 ABACUS_EXPORT_API __abacus_clamp(abacus_uint3 x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API clamp(abacus_uint3 x, abacus_uint y, abacus_uint z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint3 ABACUS_EXPORT_API __abacus_max(abacus_uint3 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API max(abacus_uint3 x, abacus_uint y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint3 ABACUS_EXPORT_API __abacus_min(abacus_uint3 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API min(abacus_uint3 x, abacus_uint y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint4 ABACUS_EXPORT_API __abacus_clamp(abacus_uint4 x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API clamp(abacus_uint4 x, abacus_uint y, abacus_uint z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint4 ABACUS_EXPORT_API __abacus_max(abacus_uint4 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API max(abacus_uint4 x, abacus_uint y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint4 ABACUS_EXPORT_API __abacus_min(abacus_uint4 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API min(abacus_uint4 x, abacus_uint y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint8 ABACUS_EXPORT_API __abacus_clamp(abacus_uint8 x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API clamp(abacus_uint8 x, abacus_uint y, abacus_uint z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint8 ABACUS_EXPORT_API __abacus_max(abacus_uint8 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API max(abacus_uint8 x, abacus_uint y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint8 ABACUS_EXPORT_API __abacus_min(abacus_uint8 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API min(abacus_uint8 x, abacus_uint y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_uint16 ABACUS_EXPORT_API __abacus_clamp(abacus_uint16 x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API clamp(abacus_uint16 x, abacus_uint y, abacus_uint z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_uint16 ABACUS_EXPORT_API __abacus_max(abacus_uint16 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API max(abacus_uint16 x, abacus_uint y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_uint16 ABACUS_EXPORT_API __abacus_min(abacus_uint16 x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API min(abacus_uint16 x, abacus_uint y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong2.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong2 x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API clamp(abacus_ulong2 x, abacus_ulong y, abacus_ulong z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong2.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_max(abacus_ulong2 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API max(abacus_ulong2 x, abacus_ulong y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong2.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong2 ABACUS_EXPORT_API __abacus_min(abacus_ulong2 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong2.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong2.
inline abacus_ulong2 ABACUS_API min(abacus_ulong2 x, abacus_ulong y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong3.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong3 x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API clamp(abacus_ulong3 x, abacus_ulong y, abacus_ulong z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong3.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_max(abacus_ulong3 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API max(abacus_ulong3 x, abacus_ulong y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong3.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong3 ABACUS_EXPORT_API __abacus_min(abacus_ulong3 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong3.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong3.
inline abacus_ulong3 ABACUS_API min(abacus_ulong3 x, abacus_ulong y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong4.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong4 x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API clamp(abacus_ulong4 x, abacus_ulong y, abacus_ulong z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong4.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_max(abacus_ulong4 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API max(abacus_ulong4 x, abacus_ulong y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong4.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong4 ABACUS_EXPORT_API __abacus_min(abacus_ulong4 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong4.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong4.
inline abacus_ulong4 ABACUS_API min(abacus_ulong4 x, abacus_ulong y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong8.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong8 x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API clamp(abacus_ulong8 x, abacus_ulong y, abacus_ulong z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong8.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_max(abacus_ulong8 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API max(abacus_ulong8 x, abacus_ulong y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong8.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong8 ABACUS_EXPORT_API __abacus_min(abacus_ulong8 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong8.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong8.
inline abacus_ulong8 ABACUS_API min(abacus_ulong8 x, abacus_ulong y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief min(max(x, y), z).
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong16.
///
/// clamp returns min(max(x, y), z). Results are undefined if y > z.
///
/// Standards compliant implementation of OpenCL 1.2 clamp.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerClamp.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_clamp(abacus_ulong16 x, abacus_ulong y, abacus_ulong z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_clamp.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong.
/// @param[in] z A abacus_ulong.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API clamp(abacus_ulong16 x, abacus_ulong y, abacus_ulong z) {
  return __abacus_clamp(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The greater of x or y.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong16.
///
/// Standards compliant implementation of OpenCL 1.2 max.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMax.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_max(abacus_ulong16 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_max.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API max(abacus_ulong16 x, abacus_ulong y) {
  return __abacus_max(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief The lesser of x or y.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong16.
///
/// Standards compliant implementation of OpenCL 1.2 min.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/integerMin.html
abacus_ulong16 ABACUS_EXPORT_API __abacus_min(abacus_ulong16 x, abacus_ulong y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_min.
/// @param[in] x A abacus_ulong16.
/// @param[in] y A abacus_ulong.
/// @return      A abacus_ulong16.
inline abacus_ulong16 ABACUS_API min(abacus_ulong16 x, abacus_ulong y) {
  return __abacus_min(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_int ABACUS_EXPORT_API __abacus_mad24(abacus_int x, abacus_int y, abacus_int z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @param[in] z A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API mad24(abacus_int x, abacus_int y, abacus_int z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_int ABACUS_EXPORT_API __abacus_mul24(abacus_int x, abacus_int y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_int.
/// @param[in] y A abacus_int.
/// @return      A abacus_int.
inline abacus_int ABACUS_API mul24(abacus_int x, abacus_int y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_int2 ABACUS_EXPORT_API __abacus_mad24(abacus_int2 x, abacus_int2 y, abacus_int2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @param[in] z A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API mad24(abacus_int2 x, abacus_int2 y, abacus_int2 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_int2 ABACUS_EXPORT_API __abacus_mul24(abacus_int2 x, abacus_int2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_int2.
/// @param[in] y A abacus_int2.
/// @return      A abacus_int2.
inline abacus_int2 ABACUS_API mul24(abacus_int2 x, abacus_int2 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_int3 ABACUS_EXPORT_API __abacus_mad24(abacus_int3 x, abacus_int3 y, abacus_int3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @param[in] z A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API mad24(abacus_int3 x, abacus_int3 y, abacus_int3 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_int3 ABACUS_EXPORT_API __abacus_mul24(abacus_int3 x, abacus_int3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_int3.
/// @param[in] y A abacus_int3.
/// @return      A abacus_int3.
inline abacus_int3 ABACUS_API mul24(abacus_int3 x, abacus_int3 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_int4 ABACUS_EXPORT_API __abacus_mad24(abacus_int4 x, abacus_int4 y, abacus_int4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @param[in] z A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API mad24(abacus_int4 x, abacus_int4 y, abacus_int4 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_int4 ABACUS_EXPORT_API __abacus_mul24(abacus_int4 x, abacus_int4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_int4.
/// @param[in] y A abacus_int4.
/// @return      A abacus_int4.
inline abacus_int4 ABACUS_API mul24(abacus_int4 x, abacus_int4 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_int8 ABACUS_EXPORT_API __abacus_mad24(abacus_int8 x, abacus_int8 y, abacus_int8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @param[in] z A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API mad24(abacus_int8 x, abacus_int8 y, abacus_int8 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_int8 ABACUS_EXPORT_API __abacus_mul24(abacus_int8 x, abacus_int8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_int8.
/// @param[in] y A abacus_int8.
/// @return      A abacus_int8.
inline abacus_int8 ABACUS_API mul24(abacus_int8 x, abacus_int8 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_int16 ABACUS_EXPORT_API __abacus_mad24(abacus_int16 x, abacus_int16 y, abacus_int16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @param[in] z A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API mad24(abacus_int16 x, abacus_int16 y, abacus_int16 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_int16 ABACUS_EXPORT_API __abacus_mul24(abacus_int16 x, abacus_int16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_int16.
/// @param[in] y A abacus_int16.
/// @return      A abacus_int16.
inline abacus_int16 ABACUS_API mul24(abacus_int16 x, abacus_int16 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_uint ABACUS_EXPORT_API __abacus_mad24(abacus_uint x, abacus_uint y, abacus_uint z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @param[in] z A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API mad24(abacus_uint x, abacus_uint y, abacus_uint z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_uint ABACUS_EXPORT_API __abacus_mul24(abacus_uint x, abacus_uint y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_uint.
/// @param[in] y A abacus_uint.
/// @return      A abacus_uint.
inline abacus_uint ABACUS_API mul24(abacus_uint x, abacus_uint y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_uint2 ABACUS_EXPORT_API __abacus_mad24(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @param[in] z A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API mad24(abacus_uint2 x, abacus_uint2 y, abacus_uint2 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_uint2 ABACUS_EXPORT_API __abacus_mul24(abacus_uint2 x, abacus_uint2 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_uint2.
/// @param[in] y A abacus_uint2.
/// @return      A abacus_uint2.
inline abacus_uint2 ABACUS_API mul24(abacus_uint2 x, abacus_uint2 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_uint3 ABACUS_EXPORT_API __abacus_mad24(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @param[in] z A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API mad24(abacus_uint3 x, abacus_uint3 y, abacus_uint3 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_uint3 ABACUS_EXPORT_API __abacus_mul24(abacus_uint3 x, abacus_uint3 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_uint3.
/// @param[in] y A abacus_uint3.
/// @return      A abacus_uint3.
inline abacus_uint3 ABACUS_API mul24(abacus_uint3 x, abacus_uint3 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_uint4 ABACUS_EXPORT_API __abacus_mad24(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @param[in] z A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API mad24(abacus_uint4 x, abacus_uint4 y, abacus_uint4 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_uint4 ABACUS_EXPORT_API __abacus_mul24(abacus_uint4 x, abacus_uint4 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_uint4.
/// @param[in] y A abacus_uint4.
/// @return      A abacus_uint4.
inline abacus_uint4 ABACUS_API mul24(abacus_uint4 x, abacus_uint4 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_uint8 ABACUS_EXPORT_API __abacus_mad24(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @param[in] z A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API mad24(abacus_uint8 x, abacus_uint8 y, abacus_uint8 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_uint8 ABACUS_EXPORT_API __abacus_mul24(abacus_uint8 x, abacus_uint8 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_uint8.
/// @param[in] y A abacus_uint8.
/// @return      A abacus_uint8.
inline abacus_uint8 ABACUS_API mul24(abacus_uint8 x, abacus_uint8 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


/// @brief __abacus_mul24(a , b) + c.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
///
/// mad24 returns __abacus_mul24(a, b) + c.
///
/// Standards compliant implementation of OpenCL 1.2 mad24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mad24.html
abacus_uint16 ABACUS_EXPORT_API __abacus_mad24(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mad24.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @param[in] z A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API mad24(abacus_uint16 x, abacus_uint16 y, abacus_uint16 z) {
  return __abacus_mad24(x, y, z);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Multiply 24-bit integer values a and b.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
///
/// Standards compliant implementation of OpenCL 1.2 mul24.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/mul24.html
abacus_uint16 ABACUS_EXPORT_API __abacus_mul24(abacus_uint16 x, abacus_uint16 y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
/// @brief Wrapper for __abacus_mul24.
/// @param[in] x A abacus_uint16.
/// @param[in] y A abacus_uint16.
/// @return      A abacus_uint16.
inline abacus_uint16 ABACUS_API mul24(abacus_uint16 x, abacus_uint16 y) {
  return __abacus_mul24(x, y);
}
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif




/// @}
////////////////////////////////////////////////////////////////////////////////

#endif  //__ABACUS_ABACUS_INTEGER__
