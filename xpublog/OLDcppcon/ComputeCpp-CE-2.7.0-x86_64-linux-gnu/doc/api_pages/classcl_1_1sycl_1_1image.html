<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Codeplay ComputeCpp: cl::sycl::image&lt; kDimensions, AllocatorT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Codeplay ComputeCpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcl_1_1sycl_1_1image.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcl_1_1sycl_1_1image-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::image&lt; kDimensions, AllocatorT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="image_8h_source.html">image.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cl::sycl::image&lt; kDimensions, AllocatorT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_1_1sycl_1_1image.png" usemap="#cl::sycl::image_3C_20kDimensions_2C_20AllocatorT_20_3E_map" alt=""/>
  <map id="cl::sycl::image_3C_20kDimensions_2C_20AllocatorT_20_3E_map" name="cl::sycl::image&lt; kDimensions, AllocatorT &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c67b462ef27c943b138b5d8d15af010"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a3c67b462ef27c943b138b5d8d15af010">image</a> (const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;)=default</td></tr>
<tr class="memdesc:a3c67b462ef27c943b138b5d8d15af010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a3c67b462ef27c943b138b5d8d15af010">More...</a><br /></td></tr>
<tr class="separator:a3c67b462ef27c943b138b5d8d15af010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289a08cc1dffdac8cf1d766967ac1ac5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a289a08cc1dffdac8cf1d766967ac1ac5">image</a> (<a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&amp;rhs)=default</td></tr>
<tr class="memdesc:a289a08cc1dffdac8cf1d766967ac1ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor.  <a href="#a289a08cc1dffdac8cf1d766967ac1ac5">More...</a><br /></td></tr>
<tr class="separator:a289a08cc1dffdac8cf1d766967ac1ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8e0669831514216b9deccb297033fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#aad8e0669831514216b9deccb297033fe">operator=</a> (const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;rhs)=default</td></tr>
<tr class="memdesc:aad8e0669831514216b9deccb297033fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.Copies the image descriptor of the original image.  <a href="#aad8e0669831514216b9deccb297033fe">More...</a><br /></td></tr>
<tr class="separator:aad8e0669831514216b9deccb297033fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cb05edcc8f51b8c2da8122b357ea6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#ad9cb05edcc8f51b8c2da8122b357ea6b">operator=</a> (<a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&amp;rhs)=default</td></tr>
<tr class="memdesc:ad9cb05edcc8f51b8c2da8122b357ea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Assignment.  <a href="#ad9cb05edcc8f51b8c2da8122b357ea6b">More...</a><br /></td></tr>
<tr class="separator:ad9cb05edcc8f51b8c2da8122b357ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1af36f47c43a3f8012fdd74db938bd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#ac1af36f47c43a3f8012fdd74db938bd1">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ac1af36f47c43a3f8012fdd74db938bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.  <a href="#ac1af36f47c43a3f8012fdd74db938bd1">More...</a><br /></td></tr>
<tr class="separator:ac1af36f47c43a3f8012fdd74db938bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be5ee5b28b938b4197d934eae99268e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a3be5ee5b28b938b4197d934eae99268e">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a3be5ee5b28b938b4197d934eae99268e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.  <a href="#a3be5ee5b28b938b4197d934eae99268e">More...</a><br /></td></tr>
<tr class="separator:a3be5ee5b28b938b4197d934eae99268e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568fa28650238f5cc19bb1cc2701ec53"><td class="memTemplParams" colspan="2">template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </td></tr>
<tr class="memitem:a568fa28650238f5cc19bb1cc2701ec53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a568fa28650238f5cc19bb1cc2701ec53">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const pitch_range_t &amp;pit, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a568fa28650238f5cc19bb1cc2701ec53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.  <a href="#a568fa28650238f5cc19bb1cc2701ec53">More...</a><br /></td></tr>
<tr class="separator:a568fa28650238f5cc19bb1cc2701ec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3163e2332c98a89917aa5c79f6d17392"><td class="memTemplParams" colspan="2">template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </td></tr>
<tr class="memitem:a3163e2332c98a89917aa5c79f6d17392"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a3163e2332c98a89917aa5c79f6d17392">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const pitch_range_t &amp;pit, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a3163e2332c98a89917aa5c79f6d17392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.  <a href="#a3163e2332c98a89917aa5c79f6d17392">More...</a><br /></td></tr>
<tr class="separator:a3163e2332c98a89917aa5c79f6d17392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6de4227f82604e3fe737178cda9796d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#ad6de4227f82604e3fe737178cda9796d">image</a> (void *hostPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ad6de4227f82604e3fe737178cda9796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with a raw host pointer to the image data.  <a href="#ad6de4227f82604e3fe737178cda9796d">More...</a><br /></td></tr>
<tr class="separator:ad6de4227f82604e3fe737178cda9796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aad09f1ea4af87e0959212565eeea4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a98aad09f1ea4af87e0959212565eeea4">image</a> (void *hostPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a98aad09f1ea4af87e0959212565eeea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with a raw host pointer to the image data.  <a href="#a98aad09f1ea4af87e0959212565eeea4">More...</a><br /></td></tr>
<tr class="separator:a98aad09f1ea4af87e0959212565eeea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4d6c3c0dec2db9e5c2e4fb7d82f4de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a7e4d6c3c0dec2db9e5c2e4fb7d82f4de">image</a> (const void *hostPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a7e4d6c3c0dec2db9e5c2e4fb7d82f4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with a constant raw host pointer to the image data.  <a href="#a7e4d6c3c0dec2db9e5c2e4fb7d82f4de">More...</a><br /></td></tr>
<tr class="separator:a7e4d6c3c0dec2db9e5c2e4fb7d82f4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867f8ee2508794e5893d433abd428332"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a867f8ee2508794e5893d433abd428332">image</a> (const void *hostPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a867f8ee2508794e5893d433abd428332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with a raw host pointer to the image data.  <a href="#a867f8ee2508794e5893d433abd428332">More...</a><br /></td></tr>
<tr class="separator:a867f8ee2508794e5893d433abd428332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e07850477bd197a8b75f52b74bd3af"><td class="memTemplParams" colspan="2">template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </td></tr>
<tr class="memitem:ab9e07850477bd197a8b75f52b74bd3af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#ab9e07850477bd197a8b75f52b74bd3af">image</a> (void *hostPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const pitch_range_t &amp;pit, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ab9e07850477bd197a8b75f52b74bd3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type, range and pitch, with a raw host pointer to the image data.  <a href="#ab9e07850477bd197a8b75f52b74bd3af">More...</a><br /></td></tr>
<tr class="separator:ab9e07850477bd197a8b75f52b74bd3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf81fb0be6a973d366872f5ae06a821"><td class="memTemplParams" colspan="2">template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </td></tr>
<tr class="memitem:a6cf81fb0be6a973d366872f5ae06a821"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a6cf81fb0be6a973d366872f5ae06a821">image</a> (void *hostPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const pitch_range_t &amp;pit, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a6cf81fb0be6a973d366872f5ae06a821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type, range and pitch, with a raw host pointer to the image data.  <a href="#a6cf81fb0be6a973d366872f5ae06a821">More...</a><br /></td></tr>
<tr class="separator:a6cf81fb0be6a973d366872f5ae06a821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827d0a58289e8ab0c276fbbb8d48bb24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a827d0a58289e8ab0c276fbbb8d48bb24">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; sharedPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a827d0a58289e8ab0c276fbbb8d48bb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with a shared host pointer to the image data.  <a href="#a827d0a58289e8ab0c276fbbb8d48bb24">More...</a><br /></td></tr>
<tr class="separator:a827d0a58289e8ab0c276fbbb8d48bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c18fd79efb3fd9899670ae7089fab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#ae67c18fd79efb3fd9899670ae7089fab">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; sharedPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:ae67c18fd79efb3fd9899670ae7089fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type and range, with a shared host pointer to the image data.  <a href="#ae67c18fd79efb3fd9899670ae7089fab">More...</a><br /></td></tr>
<tr class="separator:ae67c18fd79efb3fd9899670ae7089fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b985089b35eaeb248cc8a3fcf65a5cb"><td class="memTemplParams" colspan="2">template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </td></tr>
<tr class="memitem:a8b985089b35eaeb248cc8a3fcf65a5cb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a8b985089b35eaeb248cc8a3fcf65a5cb">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; sharedPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const pitch_range_t &amp;pit, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a8b985089b35eaeb248cc8a3fcf65a5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type, range and pitch, with a shared host pointer to the image data.  <a href="#a8b985089b35eaeb248cc8a3fcf65a5cb">More...</a><br /></td></tr>
<tr class="separator:a8b985089b35eaeb248cc8a3fcf65a5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac36031d973fa78bcdd0bdbf77934aa"><td class="memTemplParams" colspan="2">template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </td></tr>
<tr class="memitem:a3ac36031d973fa78bcdd0bdbf77934aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a3ac36031d973fa78bcdd0bdbf77934aa">image</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; sharedPtr, <a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a> order, <a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a> type, const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;rng, const pitch_range_t &amp;pit, AllocatorT allocator, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a3ac36031d973fa78bcdd0bdbf77934aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an image of the specified channel_order and channel_type, range and pitch, with a shared host pointer to the image data.  <a href="#a3ac36031d973fa78bcdd0bdbf77934aa">More...</a><br /></td></tr>
<tr class="separator:a3ac36031d973fa78bcdd0bdbf77934aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586cec9478e45b1d8019563b1e7d04be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a586cec9478e45b1d8019563b1e7d04be">image</a> (cl_mem memObject, const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;syclContext, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> availableEvent={})</td></tr>
<tr class="separator:a586cec9478e45b1d8019563b1e7d04be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a506fd59c41d2a399c8726d8e913e0a"><td class="memTemplParams" colspan="2">template&lt;typename T , access::mode accessMode&gt; </td></tr>
<tr class="memitem:a0a506fd59c41d2a399c8726d8e913e0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, kDimensions, accessMode, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7ad19909e3ef6decbf2453174616b470c2">access::target::host_image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a0a506fd59c41d2a399c8726d8e913e0a">get_access</a> ()</td></tr>
<tr class="memdesc:a0a506fd59c41d2a399c8726d8e913e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor to the image.  <a href="#a0a506fd59c41d2a399c8726d8e913e0a">More...</a><br /></td></tr>
<tr class="separator:a0a506fd59c41d2a399c8726d8e913e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c3346084b0a4a962ed40f495a2a575"><td class="memTemplParams" colspan="2">template&lt;typename T , access::mode accessMode&gt; </td></tr>
<tr class="memitem:a45c3346084b0a4a962ed40f495a2a575"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, kDimensions, accessMode, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7a78805a221a988e79ef3f42d7c5bfd418">access::target::image</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a45c3346084b0a4a962ed40f495a2a575">get_access</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;cgh)</td></tr>
<tr class="memdesc:a45c3346084b0a4a962ed40f495a2a575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor to the image for command group <a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a>.  <a href="#a45c3346084b0a4a962ed40f495a2a575">More...</a><br /></td></tr>
<tr class="separator:a45c3346084b0a4a962ed40f495a2a575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a307dafab628d50386884a9868f074"><td class="memTemplParams" colspan="2">template&lt;int dims = kDimensions, class  = typename std::enable_if&lt;(2 == dims) || (3 == dims)&gt;::type&gt; </td></tr>
<tr class="memitem:a23a307dafab628d50386884a9868f074"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; dims-1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a23a307dafab628d50386884a9868f074">get_pitch</a> () const </td></tr>
<tr class="memdesc:a23a307dafab628d50386884a9868f074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pitch of the image object.  <a href="#a23a307dafab628d50386884a9868f074">More...</a><br /></td></tr>
<tr class="separator:a23a307dafab628d50386884a9868f074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051e3a91a389a94a43324e318ece2580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1range.html">cl::sycl::range</a>&lt; kDimensions &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a051e3a91a389a94a43324e318ece2580">get_range</a> () const </td></tr>
<tr class="separator:a051e3a91a389a94a43324e318ece2580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbed375a0a00af6f44e9f12ef67d2b5"><td class="memTemplParams" colspan="2">template&lt;typename propertyT &gt; </td></tr>
<tr class="memitem:aadbed375a0a00af6f44e9f12ef67d2b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#aadbed375a0a00af6f44e9f12ef67d2b5">has_property</a> () const noexcept</td></tr>
<tr class="memdesc:aadbed375a0a00af6f44e9f12ef67d2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this SYCL image was constructed with the property specified by propertyT.  <a href="#aadbed375a0a00af6f44e9f12ef67d2b5">More...</a><br /></td></tr>
<tr class="separator:aadbed375a0a00af6f44e9f12ef67d2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada11830ba8e089d4c47c4e64904ffe77"><td class="memTemplParams" colspan="2">template&lt;typename propertyT &gt; </td></tr>
<tr class="memitem:ada11830ba8e089d4c47c4e64904ffe77"><td class="memTemplItemLeft" align="right" valign="top">propertyT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#ada11830ba8e089d4c47c4e64904ffe77">get_property</a> () const </td></tr>
<tr class="memdesc:ada11830ba8e089d4c47c4e64904ffe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the property of type propertyT that this SYCL image was constructed with.  <a href="#ada11830ba8e089d4c47c4e64904ffe77">More...</a><br /></td></tr>
<tr class="separator:ada11830ba8e089d4c47c4e64904ffe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0322aeab67c1ad6c9ff3e46544d7f4"><td class="memItemLeft" align="right" valign="top">AllocatorT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a3d0322aeab67c1ad6c9ff3e46544d7f4">get_allocator</a> () const </td></tr>
<tr class="memdesc:a3d0322aeab67c1ad6c9ff3e46544d7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator provided to the image.  <a href="#a3d0322aeab67c1ad6c9ff3e46544d7f4">More...</a><br /></td></tr>
<tr class="separator:a3d0322aeab67c1ad6c9ff3e46544d7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a53db86e905a82d553464d70afd4a92e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#a53db86e905a82d553464d70afd4a92e2">operator==</a> (const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a> &amp;lhs, const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a> &amp;rhs)</td></tr>
<tr class="memdesc:a53db86e905a82d553464d70afd4a92e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if lhs and rhs are equal.  <a href="#a53db86e905a82d553464d70afd4a92e2">More...</a><br /></td></tr>
<tr class="separator:a53db86e905a82d553464d70afd4a92e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead4e7e956c67f92cdb503d13ba1bb9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1image.html#aead4e7e956c67f92cdb503d13ba1bb9a">operator!=</a> (const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a> &amp;lhs, const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a> &amp;rhs)</td></tr>
<tr class="memdesc:aead4e7e956c67f92cdb503d13ba1bb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if lhs and rhs are not equal.  <a href="#aead4e7e956c67f92cdb503d13ba1bb9a">More...</a><br /></td></tr>
<tr class="separator:aead4e7e956c67f92cdb503d13ba1bb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt;<br />
class cl::sycl::image&lt; kDimensions, AllocatorT &gt;</h3>


<p>Definition at line <a class="el" href="image_8h_source.html#l00188">188</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3c67b462ef27c943b138b5d8d15af010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Copy the image descriptor of the original image. After the copy, both image object will point to the same underlying memory. </p>

</div>
</div>
<a class="anchor" id="a289a08cc1dffdac8cf1d766967ac1ac5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Constructor. </p>
<p>Moves the image descriptor of the original image. After the move, rhs will be invalid. </p>

</div>
</div>
<a class="anchor" id="ac1af36f47c43a3f8012fdd74db938bd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used. </p>
<p>Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00264">264</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3be5ee5b28b938b4197d934eae99268e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used. </p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00288">288</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a568fa28650238f5cc19bb1cc2701ec53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pitch_range_t &amp;&#160;</td>
          <td class="paramname"><em>pit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used. </p>
<p>Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Only enabled when kDimensions greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">pit</td><td>Image pitch. </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00315">315</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3163e2332c98a89917aa5c79f6d17392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pitch_range_t &amp;&#160;</td>
          <td class="paramname"><em>pit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with no host pointer, performing device side allocation of the buffer, this means that on destruction the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used. </p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Only enabled when kDimensions greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">pit</td><td>Image pitch. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00343">343</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6de4227f82604e3fe737178cda9796d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with a raw host pointer to the image data. </p>
<p>On object destruction, the data will be copied to the specified host pointer unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Raw pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00368">368</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98aad09f1ea4af87e0959212565eeea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with a raw host pointer to the image data. </p>
<p>On object destruction, the data will be copied to the specified host pointer unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Raw pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00395">395</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e4d6c3c0dec2db9e5c2e4fb7d82f4de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with a constant raw host pointer to the image data. </p>
<p>On object destruction, the data will not be copied back, unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Raw pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00421">421</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a867f8ee2508794e5893d433abd428332"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with a raw host pointer to the image data. </p>
<p>On object destruction, the data will not be copied back unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Raw pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00449">449</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e07850477bd197a8b75f52b74bd3af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pitch_range_t &amp;&#160;</td>
          <td class="paramname"><em>pit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type, range and pitch, with a raw host pointer to the image data. </p>
<p>On object destruction, the data will be copied to the specified host pointer unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Only enabled when kDimensions greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Raw pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">pit</td><td>Image pitch. </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00479">479</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf81fb0be6a973d366872f5ae06a821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hostPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pitch_range_t &amp;&#160;</td>
          <td class="paramname"><em>pit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type, range and pitch, with a raw host pointer to the image data. </p>
<p>On object destruction, the data will be copied to the specified host pointer unless a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Only enabled when kDimensions greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostPtr</td><td>Raw pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">pit</td><td>Image pitch. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00508">508</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a827d0a58289e8ab0c276fbbb8d48bb24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>sharedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with a shared host pointer to the image data. </p>
<p>The host pointer's ownership is shared and on destruction the data will be copied to the specified host pointer unless the runtime maintains the last reference to the shared_ptr or a final pointer is specified using set_final_data() in which case that specified pointer will be used. Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharedPtr</td><td>shared pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00536">536</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae67c18fd79efb3fd9899670ae7089fab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>sharedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type and range, with a shared host pointer to the image data. </p>
<p>The host pointer's ownership is shared and on destruction the data will be copied to the specified host pointer unless the runtime maintains the last reference to the shared_ptr or a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharedPtr</td><td>shared pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00564">564</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8b985089b35eaeb248cc8a3fcf65a5cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>sharedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pitch_range_t &amp;&#160;</td>
          <td class="paramname"><em>pit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type, range and pitch, with a shared host pointer to the image data. </p>
<p>The host pointer's ownership is shared and on destruction the data will be copied to the specified host pointer unless the runtime maintains the last reference to the shared_ptr or a final pointer is specified using set_final_data() in which case that specified pointer will be used. Any host side allocation of data will be performed using the allocator specified by AllocatorT. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Only enabled when kDimensions greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharedPtr</td><td>Shared pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">pit</td><td>Image pitch. </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00593">593</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ac36031d973fa78bcdd0bdbf77934aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;COMPUTECPP_ENABLE_IF(kdims_t,(kDimensions &gt; 1)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>sharedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8557ea72c6739001cf30a301567cf3df">cl::sycl::image_channel_order</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a78b713c5436596506d5232e591a3b7ae">cl::sycl::image_channel_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; kDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pitch_range_t &amp;&#160;</td>
          <td class="paramname"><em>pit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocatorT&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an image of the specified channel_order and channel_type, range and pitch, with a shared host pointer to the image data. </p>
<p>The host pointer's ownership is shared and on destruction the data will be copied to the specified host pointer unless the runtime maintains the last reference to the shared_ptr or a final pointer is specified using set_final_data() in which case that specified pointer will be used.</p>
<p>Any host side allocation of data will be performed using the provided allocator. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Only enabled when kDimensions greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharedPtr</td><td>Shared pointer to the image data. </td></tr>
    <tr><td class="paramname">order</td><td>Image channel order. </td></tr>
    <tr><td class="paramname">type</td><td>Image channel type. </td></tr>
    <tr><td class="paramname">rng</td><td>Image range. </td></tr>
    <tr><td class="paramname">pit</td><td>Image pitch. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to create internal storage </td></tr>
    <tr><td class="paramname">propList</td><td>List of image properties </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00624">624</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a586cec9478e45b1d8019563b1e7d04be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::<a class="el" href="classcl_1_1sycl_1_1image.html">image</a> </td>
          <td>(</td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>memObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>syclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>availableEvent</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="image_8h_source.html#l00635">635</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0a506fd59c41d2a399c8726d8e913e0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;typename T , access::mode accessMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;T, kDimensions, accessMode, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7ad19909e3ef6decbf2453174616b470c2">access::target::host_image</a>&gt; <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an accessor to the image. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>The data access mode descriptor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00651">651</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a45c3346084b0a4a962ed40f495a2a575"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;typename T , access::mode accessMode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;T, kDimensions, accessMode, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7a78805a221a988e79ef3f42d7c5bfd418">access::target::image</a>&gt; <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>cgh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an accessor to the image for command group <a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the accessor </td></tr>
    <tr><td class="paramname">accessMode</td><td>The data access mode descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgh</td><td>The command group handler </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00663">663</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d0322aeab67c1ad6c9ff3e46544d7f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AllocatorT <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator provided to the image. </p>
<dl class="section return"><dt>Returns</dt><dd>Allocator that was provided to the image </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00708">708</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a23a307dafab628d50386884a9868f074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;int dims = kDimensions, class  = typename std::enable_if&lt;(2 == dims) || (3 == dims)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt;dims - 1&gt; <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::get_pitch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pitch of the image object. </p>
<dl class="section return"><dt>Returns</dt><dd>pitch </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00674">674</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada11830ba8e089d4c47c4e64904ffe77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;typename propertyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">propertyT <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::get_property </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the property of type propertyT that this SYCL image was constructed with. </p>
<p>Throws an error if image was not constructed with the property. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propertyT</td><td>Property to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the property </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00701">701</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a051e3a91a389a94a43324e318ece2580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1range.html">cl::sycl::range</a>&lt;kDimensions&gt; <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::get_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The image range </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00680">680</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="aadbed375a0a00af6f44e9f12ef67d2b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<div class="memtemplate">
template&lt;typename propertyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::has_property </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this SYCL image was constructed with the property specified by propertyT. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propertyT</td><td>Property to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if image constructed with the property </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00690">690</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad8e0669831514216b9deccb297033fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt;kDimensions, AllocatorT&gt;&amp; <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment.Copies the image descriptor of the original image. </p>
<p>After the copy, both image object will point to the same underlying memory. </p>

</div>
</div>
<a class="anchor" id="ad9cb05edcc8f51b8c2da8122b357ea6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt;kDimensions, AllocatorT&gt;&amp; <a class="el" href="classcl_1_1sycl_1_1image.html">cl::sycl::image</a>&lt; kDimensions, AllocatorT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Assignment. </p>
<p>Moves the image descriptor of the original image. After the move, rhs will be invalid. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aead4e7e956c67f92cdb503d13ba1bb9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if lhs and rhs are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side object in comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side object in comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if different underlying objects </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00246">246</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53db86e905a82d553464d70afd4a92e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions = 1, typename AllocatorT = image_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1image.html">image</a>&lt; kDimensions, AllocatorT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if lhs and rhs are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side object in comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side object in comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if same underlying object </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00237">237</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="image_8h_source.html">image.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="classcl_1_1sycl_1_1image.html">image</a></li>
    <li class="footer">Generated on Mon Sep 27 2021 12:13:49 for Codeplay ComputeCpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
