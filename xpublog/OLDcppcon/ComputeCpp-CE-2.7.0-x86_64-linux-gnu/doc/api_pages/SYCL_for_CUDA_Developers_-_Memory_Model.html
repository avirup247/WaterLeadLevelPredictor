
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<style>html, body {
    background-color: #ccc;
    margin: 0;
    padding: 0;
    font-family: 'Open Sans', arial, sans-serif;
}

a {
    color: inherit;
    text-decoration: inherit;
    cursor: pointer
}

h1, h2, h3, h4, h5, h6 {
    cursor: inherit !important;
}

* {
    box-sizing: border-box;
}

main {
    background-color: white;
    padding: 2rem 4rem 2rem 4rem;
}

@media screen and (min-width: 56rem) {
    html, body {
        height: 100%;
    }

    main {
        box-shadow: 10px 0px 10px -8px rgba(0,0,0,0.1);
    }

    .combined-document main {
        margin: 0 0 0 320px;
        max-width: 1000px;
        min-height: 100%;
    }

    .single-document main {
        margin: 0 auto;
        width: 1000px;
    }
}

article header h1 {
    font-size: 1.7em;
}

article#title header h1 {
    font-size: 2.6rem;
}

article {
    padding: 2rem 0 1rem 0;
    position: relative;
}

article header a h1 {
    cursor: pointer;
}

article div.page-counter {
    display: block;
    text-align: right;
    width: auto;
    height: auto;
    color: #666;
    font-size: .8rem;
    padding: .2rem .5rem .2rem .5rem;
    margin-top: 4rem;
}

article:not(#title):not(:last-of-type) {
    border-bottom: #efefef 1px solid;
}

article#title img {
    width: 160px;
}

article#title nav ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

article#title nav > ul > li a {
    opacity: .9;
    text-decoration: none;
}

article#title nav li > a:hover,
article#title nav li.selected > a {
    opacity: 1;
    font-weight: bold;
}

article#title nav > ul > li a {
    display: block;
    padding: .3rem;
    cursor: pointer;
}

article#title nav > ul > li > a { padding-left: 0rem; padding-right: 0rem; }
article#title nav > ul > li > ul > li > a { padding-left: 1rem; padding-right: 1rem; }
article#title nav > ul > li > ul > li > ul > li > a { padding-left: 2rem; padding-right: 2rem; }
article#title nav > ul > li > ul > li > ul > li > ul > li > a { padding-left: 3rem; padding-right: 3rem; }
article#title nav > ul > li > ul > li > ul > li > ul > li > ul > li > a { padding-left: 4rem; padding-right: 4rem; }
article#title nav > ul > li > ul > li > ul > li > ul > li > ul > li > ul > li > a { padding-left: 5rem; padding-right: 5rem; }

@media screen and (min-width: 56rem) {
    .combined-document article#title {
        position: fixed;
        height: 100%;
        width: 320px;
        left: 0;
        top: 0;
        overflow: auto;
    }

    .combined-document article#title header img {
        width: 100px;
    }

    .combined-document article#title header h1 {
        font-size: 1.2rem;
    }

    .combined-document article#title > header > div {
        display: block;
        width: 100%;
        padding: 0 2rem 1rem 2rem;
        border-bottom: #bbb 1px solid;
    }

    .combined-document article#title nav {
        padding: 2rem 2rem 0 2rem;
        opacity: .6;
        transition: .3s all;
        font-size: .8rem;
    }

    .combined-document article#title nav h1 {
        display: none;
    }

    .combined-document article#title nav:hover {
        opacity: 1;
    }
}

#copyright {
    font-size: 12px;
    color: #ccc;
    padding: 1rem 0 1rem 0;
    margin-top: 1rem;
}



pre {
    table-layout: fixed;
    width: 100%;
    word-wrap: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

hr,img,legend {
    border:0;
}

blockquote,h6 {
    color:#777;
}

a,h3,h4,h5,tt {
    color:#333;
}

article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary {
    display:block;
}

a {
    background:0 0;
}

a:focus {
    outline:dotted thin;
}

a:active,a:hover {
    outline:0;
}

abbr[title] {
    border-bottom:1px dotted;
}

hr {
    -moz-box-sizing:content-box;
    box-sizing:content-box;
    background:url('data:image/png; base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC') repeat-x;
    color:#ccc;
    height:4px;
    padding:0;
}

mark {
    background:#ff0;
}

kbd,samp {
    font-family:monospace,serif;
    font-size:1em;
}

q {
    quotes:\201C \201D \2018 \2019;
}

small {
    font-size:80%;
}

sup {
    top:-.5em;
}

sub {
    bottom:-.25em;
    vertical-align:sub;
    top:-1px;
}

img {
    max-width:100%;
}

svg:not(:root) {
    overflow:hidden;
}

figure {
    margin:0;
}

dl dt,h1,h2,h3,h4,h5,h6 {
    font-weight:700;
    padding:0;
}

a:hover {
    text-decoration:underline;
}

h1,h2,h3,h4,h5,h6 {
    cursor:text;
    margin:20px 0 10px;
}

article:not(#title) h1,
article:not(#title) h2,
article:not(#title) h3,
article:not(#title) h4,
article:not(#title) h5 {
    padding: 1rem 0 1rem 0;
}

dl dt,h5,h6 {
    font-size:14px;
}

blockquote,p,table {
    margin:15px 0;
}

ol,ul {
    padding-left:30px;
}

blockquote>:first-child,dl dd>:first-child,dl dt>:first-child,h1+p,h2+p,h3+p,h4+p,h5+p,h6+p,ol li ul:first-of-type,ol li>:first-child,ul li>:first-child {
    margin-top:0;
}

a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6,body>h1:first-child,body>h1:first-child+h2,body>h2:first-child,body>h3:first-child,body>h4:first-child,body>h5:first-child,body>h6:first-child {
    margin-top:0;
    padding-top:0;
}

table td,table th {
    border:1px solid #ccc;
    padding:6px 13px;
}

dl dt {
    font-style:italic;
    margin:15px 0 5px;
}

blockquote>:last-child,dl dd>:last-child,dl dt>:last-child {
    margin-bottom:0;
}

dl dd {
    margin:0 0 15px;
    padding:0 15px;
}

blockquote {
    border-left:4px solid #DDD;
    padding:0 15px;
}

table {
    border-collapse:collapse;
    border-spacing:0;
    font:inherit;
    width: 100%;
}

table tr {
    border-top:1px solid #ccc;
    background-color:#fff;
}

a.footnote,sub,sup {
    font-size:1.4ex;
    height:0;
    line-height:1;
    vertical-align:super;
    position:relative;
}


/**
 * Tables
 */
table thead tr {
    background-color: #111111;
    color: #efefef;
}

table th:empty {
    display: none;
}

table th,
table td {
    padding: 1rem;
}

table tbody tr:nth-child(even) {
    background-color: #efefef;
}

/**
 * General
 */
p a {
    font-weight: bold;
}


span.citation {
    font-weight: bold;
    vertical-align: super;
}


.highlight { background-color: #111; color: #efefef; padding: 1rem; }
.highlight .hll { background-color: #222; font-size: 8px; }
.highlight .c { color: #75715e } /* Comment */
.highlight .err { color: #960050; background-color: #1e0010 } /* Error */
.highlight .k { color: #66d9ef } /* Keyword */
.highlight .l { color: #ae81ff } /* Literal */
.highlight .n { color: #f8f8f2 } /* Name */
.highlight .o { color: #f92672 } /* Operator */
.highlight .p { color: #f8f8f2 } /* Punctuation */
.highlight .cm { color: #75715e } /* Comment.Multiline */
.highlight .cp { color: #75715e } /* Comment.Preproc */
.highlight .c1 { color: #75715e } /* Comment.Single */
.highlight .cs { color: #75715e } /* Comment.Special */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .kc { color: #66d9ef } /* Keyword.Constant */
.highlight .kd { color: #66d9ef } /* Keyword.Declaration */
.highlight .kn { color: #f92672 } /* Keyword.Namespace */
.highlight .kp { color: #66d9ef } /* Keyword.Pseudo */
.highlight .kr { color: #66d9ef } /* Keyword.Reserved */
.highlight .kt { color: #66d9ef } /* Keyword.Type */
.highlight .ld { color: #e6db74 } /* Literal.Date */
.highlight .m { color: #ae81ff } /* Literal.Number */
.highlight .s { color: #e6db74 } /* Literal.String */
.highlight .na { color: #a6e22e } /* Name.Attribute */
.highlight .nb { color: #f8f8f2 } /* Name.Builtin */
.highlight .nc { color: #a6e22e } /* Name.Class */
.highlight .no { color: #66d9ef } /* Name.Constant */
.highlight .nd { color: #a6e22e } /* Name.Decorator */
.highlight .ni { color: #f8f8f2 } /* Name.Entity */
.highlight .ne { color: #a6e22e } /* Name.Exception */
.highlight .nf { color: #a6e22e } /* Name.Function */
.highlight .nl { color: #f8f8f2 } /* Name.Label */
.highlight .nn { color: #f8f8f2 } /* Name.Namespace */
.highlight .nx { color: #a6e22e } /* Name.Other */
.highlight .py { color: #f8f8f2 } /* Name.Property */
.highlight .nt { color: #f92672 } /* Name.Tag */
.highlight .nv { color: #f8f8f2 } /* Name.Variable */
.highlight .ow { color: #f92672 } /* Operator.Word */
.highlight .w { color: #f8f8f2 } /* Text.Whitespace */
.highlight .mf { color: #ae81ff } /* Literal.Number.Float */
.highlight .mh { color: #ae81ff } /* Literal.Number.Hex */
.highlight .mi { color: #ae81ff } /* Literal.Number.Integer */
.highlight .mo { color: #ae81ff } /* Literal.Number.Oct */
.highlight .sb { color: #e6db74 } /* Literal.String.Backtick */
.highlight .sc { color: #e6db74 } /* Literal.String.Char */
.highlight .sd { color: #e6db74 } /* Literal.String.Doc */
.highlight .s2 { color: #e6db74 } /* Literal.String.Double */
.highlight .se { color: #ae81ff } /* Literal.String.Escape */
.highlight .sh { color: #e6db74 } /* Literal.String.Heredoc */
.highlight .si { color: #e6db74 } /* Literal.String.Interpol */
.highlight .sx { color: #e6db74 } /* Literal.String.Other */
.highlight .sr { color: #e6db74 } /* Literal.String.Regex */
.highlight .s1 { color: #e6db74 } /* Literal.String.Single */
.highlight .ss { color: #e6db74 } /* Literal.String.Symbol */
.highlight .bp { color: #f8f8f2 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #f8f8f2 } /* Name.Variable.Class */
.highlight .vg { color: #f8f8f2 } /* Name.Variable.Global */
.highlight .vi { color: #f8f8f2 } /* Name.Variable.Instance */
.highlight .il { color: #ae81ff } /* Literal.Number.Integer.Long */

.highlight .gh { } /* Generic Heading & Diff Header */
.highlight .gu { color: #75715e; } /* Generic.Subheading & Diff Unified/Comment? */
.highlight .gd { color: #f92672; } /* Generic.Deleted & Diff Deleted */
.highlight .gi { color: #a6e22e; } /* Generic.Inserted & Diff Inserted */"</style>
<title>SYCL for CUDA Developers - Memory Model</title>
<meta charset="utf-8"/>
</head>
<body class="single-document">
<main>
<article id="title">
<header>
<div>
<a href="https://www.codeplay.com" id="logo" style="width: 160px; height: 46px; display: block; " target="_blank">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMi4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTG9nbyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCAzNzkuNSAxMTAuNiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzc5LjUgMTEwLjY7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+DQoJLnN0MHtmaWxsOiNBQkQzRjE7fQ0KCS5zdDF7ZmlsbDojOTYzNTk0O30NCgkuc3Qye2ZpbGw6IzVCMUQ1Nzt9DQoJLnN0M3tmaWxsOnVybCgjU1ZHSURfMV8pO30NCgkuc3Q0e2ZpbGw6dXJsKCNTVkdJRF8yXyk7fQ0KCS5zdDV7ZmlsbDp1cmwoI1NWR0lEXzNfKTt9DQoJLnN0NntmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLW1pdGVybGltaXQ6MTA7fQ0KCS5zdDd7ZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7fQ0KCS5zdDh7b3BhY2l0eTowLjczO30NCjwvc3R5bGU+DQo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNNTYuNSw0MGMwLDE1LjYtMTIuNywyOC4zLTI4LjUsMjguM1YxMS43QzQzLjgsMTEuNyw1Ni41LDI0LjQsNTYuNSw0MHoiLz4NCjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0wLDQwYzAtMTUuNiwxMi42LTI4LjMsMjgtMjguM3Y1Ni42QzEyLjYsNjguMywwLDU1LjYsMCw0MHoiLz4NCjxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0yOC4xLDYyYy0xMi4xLDAtMjItOS44LTIyLTIyczkuOC0yMiwyMi0yMlY2MnoiLz4NCjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMzkuMDI4OSIgeTE9IjYxLjk4MjEiIHgyPSIzOS4wMjg5IiB5Mj0iMTguMDY1NCI+DQoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzlGQ0VFRiIvPg0KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiM1M0IyRTUiLz4NCjwvbGluZWFyR3JhZGllbnQ+DQo8cGF0aCBjbGFzcz0ic3QzIiBkPSJNNTAsNDBjMCwxMi4xLTkuOCwyMi0yMiwyMlYxOC4xQzQwLjIsMTguMSw1MCwyNy45LDUwLDQweiIvPg0KPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMS4yMzIzIiB5MT0iMTguMDkxNyIgeDI9IjIxLjIzMjMiIHkyPSI2MS45ODIxIj4NCgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojQzJFOEY4Ii8+DQoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzI0QUJFMiIvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik0yOCw2MmMtNy41LDAtMTMuNi05LjgtMTMuNi0yMlMyMC41LDE4LjEsMjgsMTguMVY2MnoiLz4NCjxyYWRpYWxHcmFkaWVudCBpZD0iU1ZHSURfM18iIGN4PSIzMC43NDc3IiBjeT0iMzQuODU3MSIgcj0iMTMuMTc4NCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPg0KCTxzdG9wICBvZmZzZXQ9IjAuMTM5OSIgc3R5bGU9InN0b3AtY29sb3I6I0ZGRkZGRiIvPg0KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRkYyMDAiLz4NCjwvcmFkaWFsR3JhZGllbnQ+DQo8cGF0aCBjbGFzcz0ic3Q1IiBkPSJNMjguMywyNC43Yy0wLjQsMC0wLjcsMC4xLTEsMC4yYy01LDAuNi05LDcuMi05LDE1LjJjMCw4LjQsNC40LDE1LjMsOS44LDE1LjN2MGMwLjEsMC0wLjEsMCwwLDANCgljOC41LDAsMTUuNS02LjksMTUuNS0xNS4zUzM2LjcsMjQuNywyOC4zLDI0Ljd6Ii8+DQo8Zz4NCgk8cGF0aCBkPSJNMTAwLjEsMjYuM2wtMy43LDYuNGMtMi0xLjktNC43LTIuOC04LjEtMi44Yy0zLjIsMC01LjgsMS4xLTcuNywzLjJzLTIuOCw1LjEtMi44LDguOWMwLDcuNywzLjcsMTEuNSwxMSwxMS41DQoJCWMzLjIsMCw1LjktMSw4LjQtMy4xbDMuMSw2LjdjLTIuNSwxLjUtNC42LDIuNS02LjUsMi45cy00LDAuNi02LjYsMC42Yy01LjYsMC0xMC4xLTEuNi0xMy40LTQuOXMtNC45LTcuOS00LjktMTMuNw0KCQljMC01LjgsMS44LTEwLjQsNS40LTE0YzMuNi0zLjUsOC40LTUuMywxNC42LTUuM0M5My4zLDIyLjcsOTcsMjMuOSwxMDAuMSwyNi4zeiIvPg0KCTxwYXRoIGQ9Ik0xMDQuOCw0MS42YzAtNS42LDEuNi0xMC4xLDQuOC0xMy42YzMuMi0zLjUsNy41LTUuMywxMi43LTUuM2M1LjYsMCw5LjksMS43LDEyLjksNS4xczQuNiw4LDQuNiwxMy44DQoJCWMwLDUuOC0xLjYsMTAuNS00LjcsMTMuOXMtNy40LDUuMi0xMi44LDUuMmMtNS42LDAtOS45LTEuNy0xMy01LjJDMTA2LjQsNTIsMTA0LjgsNDcuMywxMDQuOCw0MS42eiBNMTEzLjcsNDEuNg0KCQljMCw4LjEsMi45LDEyLjEsOC43LDEyLjFjMi43LDAsNC44LTEsNi4zLTMuMWMxLjYtMi4xLDIuMy01LjEsMi4zLTguOWMwLTcuOS0yLjktMTEuOS04LjctMTEuOWMtMi43LDAtNC44LDEtNi4zLDMuMQ0KCQlDMTE0LjUsMzQuOSwxMTMuNywzNy44LDExMy43LDQxLjZ6Ii8+DQoJPHBhdGggZD0iTTE3MC4zLDU5Ljl2LTIuMmMtMC43LDAuOC0xLjksMS41LTMuNiwyYy0xLjcsMC42LTMuNCwwLjktNS4yLDAuOWMtNS4xLDAtOS4xLTEuNi0xMi00LjhjLTIuOS0zLjItNC40LTcuNy00LjQtMTMuNQ0KCQlzMS43LTEwLjUsNS0xNC4xYzMuNC0zLjYsNy42LTUuNCwxMi42LTUuNGMyLjgsMCw1LjMsMC42LDcuNiwxLjdWOS44bDguNS0ydjUyLjJIMTcwLjN6IE0xNzAuMywzMi4xYy0xLjgtMS41LTMuNy0yLjItNS43LTIuMg0KCQljLTMuNCwwLTYsMS03LjksMy4xcy0yLjgsNS4xLTIuOCw5YzAsNy42LDMuNywxMS40LDExLDExLjRjMC44LDAsMS44LTAuMiwzLTAuN2MxLjItMC41LDItMSwyLjMtMS41VjMyLjF6Ii8+DQoJPHBhdGggZD0iTTIyMCw0NC4zaC0yNi4xYzAuMiwyLjksMS4yLDUuMiwzLDYuOGMxLjgsMS42LDQuMywyLjQsNy40LDIuNGMzLjksMCw2LjgtMSw4LjktM2wzLjMsNi41Yy0zLDIuNC03LjUsMy43LTEzLjQsMy43DQoJCWMtNS42LDAtMTAtMS42LTEzLjItNC45Yy0zLjItMy4zLTQuOS03LjgtNC45LTEzLjdjMC01LjgsMS44LTEwLjQsNS4zLTE0YzMuNi0zLjYsNy44LTUuNCwxMi44LTUuNGM1LjMsMCw5LjYsMS42LDEyLjgsNC43DQoJCWMzLjIsMy4yLDQuOCw3LjIsNC44LDEyLjFDMjIwLjcsNDAuNiwyMjAuNSw0Mi4yLDIyMCw0NC4zeiBNMTk0LjIsMzcuOWgxOGMtMC42LTUuMy0zLjUtOC04LjktOEMxOTguNCwyOS44LDE5NS40LDMyLjUsMTk0LjIsMzcuOQ0KCQl6Ii8+DQoJPHBhdGggZD0iTTIzNS40LDU5djE1LjNoLTguNVYyMy40aDguNXYyLjVjMi4xLTIuMSw0LjgtMy4xLDcuOS0zLjFjMTEuNiwwLDE3LjUsNi40LDE3LjUsMTkuMmMwLDYtMS42LDEwLjYtNC44LDEzLjgNCgkJYy0zLjIsMy4yLTcuNiw0LjgtMTMuMiw0LjhDMjQwLDYwLjYsMjM3LjYsNjAuMSwyMzUuNCw1OXogTTIzNS40LDMyLjN2MTkuMmMxLjUsMS4zLDMuNCwxLjksNS40LDEuOWMzLjksMCw2LjgtMC45LDguNS0yLjgNCgkJYzEuNy0xLjksMi42LTQuOCwyLjYtOC45YzAtNC4zLTAuOS03LjQtMi42LTkuMWMtMS43LTEuOC00LjUtMi42LTguNS0yLjZDMjM4LjgsMjkuOSwyMzcsMzAuNywyMzUuNCwzMi4zeiIvPg0KCTxwYXRoIGQ9Ik0yNjkuNyw5LjhsOC41LTJ2NDEuMWMwLDQuNSwxLjMsNy4yLDQsOC4xYy0xLjMsMi41LTMuNiwzLjgtNi44LDMuOGMtMy45LDAtNS44LTIuNy01LjgtOC4xVjkuOHoiLz4NCgk8cGF0aCBkPSJNMzA5LjIsNTYuM2MtMC44LDEuMy0yLjEsMi4zLTQsMy4xYy0xLjksMC44LTMuOSwxLjItNiwxLjJjLTMuOSwwLTctMS05LjMtM2MtMi4zLTItMy40LTQuOC0zLjQtOC40DQoJCWMwLTQuMiwxLjYtNy41LDQuOC05LjlzNy43LTMuNiwxMy41LTMuNmMxLDAsMi4yLDAuMiwzLjUsMC41YzAtNC4zLTIuNy02LjUtOC4yLTYuNWMtMy4yLDAtNS45LDAuNS04LjEsMS42bC0xLjgtNi42DQoJCWMyLjktMS40LDYuNC0yLjEsMTAuNS0yLjFjNS42LDAsOS43LDEuMywxMi4zLDMuOGMyLjYsMi41LDMuOSw3LjMsMy45LDE0LjR2Ny44YzAsNC45LDEsNy45LDIuOSw5LjJjLTAuNywxLjItMS41LDItMi40LDIuMw0KCQljLTAuOSwwLjMtMS45LDAuNC0zLDAuNGMtMS4yLDAtMi4zLTAuNS0zLjMtMS40UzMwOS41LDU3LjQsMzA5LjIsNTYuM3ogTTMwOC40LDQyLjdjLTEuNS0wLjMtMi41LTAuNC0zLjMtMC40DQoJCWMtNi43LDAtMTAuMSwyLjItMTAuMSw2LjZjMCwzLjMsMS45LDQuOSw1LjcsNC45YzUuMSwwLDcuNy0yLjYsNy43LTcuN1Y0Mi43eiIvPg0KCTxwYXRoIGQ9Ik0zNDIuMyw2NS44Yy0wLjksMi40LTIuOSw0LjUtNS45LDYuMWMtMywxLjYtNi41LDIuNC0xMC41LDIuNHYtNy41YzYuNiwwLDkuOS0xLjcsOS45LTQuOWMwLTIuMi0wLjktNS41LTIuNy0xMA0KCQlsLTExLjQtMjguNGg4LjhsMTAsMjUuM2w5LTI1LjNoOC44TDM0Mi4zLDY1Ljh6Ii8+DQo8L2c+DQo8ZyBpZD0iSGFuZCI+DQoJPGNpcmNsZSBjbGFzcz0ic3Q2IiBjeD0iMzcyLjQiIGN5PSIxNi4zIiByPSI2LjYiLz4NCgk8cGF0aCBjbGFzcz0ic3Q3IiBkPSJNMzc0LjIsMTkuMmMwLDAsMC45LTAuNywxLjEtMC44YzAsMCwwLjktMC41LDAuOS0wLjZjMCwwLDAuNS0wLjIsMC4yLTAuNmMwLDAtMC41LTAuNS0xLjQsMC4zDQoJCWMwLDAtMC4yLDAuMi0wLjMsMC4yYzAsMC0wLjgsMC42LTAuOSwwLjVjMCwwLTAuMy0wLjUsMC0wLjljMCwwLDAuNC0wLjYsMC40LTAuN2MwLDAsMC4xLTAuMiwwLjMtMC4zYzAsMCwwLjQtMC41LDAuNS0wLjYNCgkJYzAsMCwwLjYtMC44LDAuNi0wLjljMCwwLDAuMS0wLjIsMC4yLTAuM2MwLDAsMC42LTAuOSwwLjMtMS4xYzAsMC0wLjMtMC41LTAuOCwwLjNsLTAuMiwwLjNjMCwwLTAuMiwwLjMtMC4zLDAuNA0KCQljMCwwLTAuNCwwLjQtMC41LDAuNmMwLDAtMC41LDAuNS0wLjYsMC43YzAsMC0wLjIsMC4yLTAuMywwLjJjMCwwLTAuMiwwLjEsMC4xLTAuM2MwLDAsMC41LTAuOCwwLjUtMC45YzAsMCwwLjYtMSwwLjUtMS4xDQoJCWMwLDAsMC40LTAuOCwwLjQtMC44YzAsMCwwLjMtMC41LTAuMi0wLjdjMCwwLTAuNCwwLTAuNiwwLjZjMCwwLTAuNCwwLjctMC40LDAuN2MwLDAtMC41LDAuNy0wLjUsMC44YzAsMC0wLjcsMS0wLjgsMS4yDQoJCWMwLDAtMC4zLDAuMi0wLjEtMC4zYzAsMCwwLjItMC42LDAuMi0wLjljMCwwLDAuMy0wLjcsMC4yLTAuOGMwLDAsMC4yLTAuMiwwLjItMC40YzAsMCwwLjYtMC44LDAuMi0xYzAsMC0wLjMtMC4zLTAuNywwLjMNCgkJYzAsMC0wLjMsMC41LTAuMywwLjdjMCwwLTAuNiwxLTAuNiwxLjJjMCwwLTAuNCwxLjItMC41LDEuMmMwLDAtMC40LDAuMS0wLjMtMC4zYzAsMCwwLTAuMywwLTAuNWMwLDAsMC0wLjYsMC0wLjgNCgkJYzAsMCwwLTAuNCwwLjEtMC42YzAsMCwwLjItMC44LTAuMS0wLjljMCwwLTAuNS0wLjItMC42LDEuMWMwLDAtMC4xLDAuOC0wLjEsMWMwLDAtMC4xLDEuMS0wLjEsMS4zYzAsMC0wLjUsMS43LTAuNiwxLjcNCgkJYzAsMC0wLjEsMC44LTAuMSwxLjRjMCwwLDAuMSwwLjgsMSwxLjFsMC41LDAuNGMwLDAsMC45LDAuNCwxLjQsMC4xQzM3MS44LDIwLjUsMzczLjQsMjAsMzc0LjIsMTkuMnoiLz4NCjwvZz4NCjxnIGNsYXNzPSJzdDgiPg0KCTxwYXRoIGQ9Ik03NC45LDk4LjNjLTAuMiwxLjktMC45LDMuMy0yLDQuM2MtMS4xLDEtMi42LDEuNS00LjUsMS41Yy0xLjMsMC0yLjUtMC4zLTMuNS0xYy0xLTAuNy0xLjgtMS42LTIuMy0yLjgNCgkJYy0wLjYtMS4yLTAuOC0yLjYtMC44LTQuMXYtMi4zYzAtMS42LDAuMy0zLDAuOC00LjJjMC42LTEuMiwxLjMtMi4yLDIuNC0yLjhjMS0wLjcsMi4yLTEsMy42LTFjMS45LDAsMy40LDAuNSw0LjUsMS41DQoJCWMxLjEsMSwxLjcsMi40LDEuOSw0LjNoLTEuNWMtMC40LTMtMi00LjUtNC45LTQuNWMtMS42LDAtMi45LDAuNi0zLjksMS44Yy0xLDEuMi0xLjQsMi45LTEuNCw1Vjk2YzAsMi4xLDAuNSwzLjcsMS40LDQuOQ0KCQljMC45LDEuMiwyLjIsMS44LDMuOCwxLjhjMS42LDAsMi44LTAuNCwzLjYtMS4xYzAuOC0wLjgsMS4zLTEuOSwxLjUtMy40SDc0Ljl6Ii8+DQoJPHBhdGggZD0iTTc3LjUsOTdjMC0xLjMsMC4yLTIuNCwwLjctMy40YzAuNS0xLDEuMi0xLjgsMi4xLTIuNGMwLjktMC42LDEuOS0wLjgsMy4xLTAuOGMxLjgsMCwzLjIsMC42LDQuMywxLjgNCgkJYzEuMSwxLjIsMS42LDIuOSwxLjYsNC45djAuM2MwLDEuMy0wLjIsMi40LTAuNywzLjRjLTAuNSwxLTEuMiwxLjgtMi4xLDIuNGMtMC45LDAuNi0xLjksMC44LTMuMSwwLjhjLTEuOCwwLTMuMi0wLjYtNC4zLTEuOA0KCQljLTEuMS0xLjItMS42LTIuOS0xLjYtNC45Vjk3eiBNNzguOSw5Ny40YzAsMS42LDAuNCwyLjksMS4yLDMuOWMwLjgsMSwxLjksMS41LDMuMiwxLjVjMS4zLDAsMi40LTAuNSwzLjItMS41YzAuOC0xLDEuMi0yLjMsMS4yLTQNCgkJVjk3YzAtMS0wLjItMS45LTAuNi0yLjhjLTAuNC0wLjgtMC45LTEuNS0xLjYtMS45Yy0wLjctMC41LTEuNC0wLjctMi4zLTAuN2MtMS4zLDAtMi40LDAuNS0zLjIsMS41Yy0wLjgsMS0xLjIsMi40LTEuMiw0Vjk3LjR6Ii8+DQoJPHBhdGggZD0iTTkzLjYsOTAuNmwwLDIuM2MwLjUtMC44LDEuMS0xLjQsMS45LTEuOWMwLjctMC40LDEuNi0wLjYsMi41LTAuNmMxLjQsMCwyLjUsMC40LDMuMiwxLjJjMC43LDAuOCwxLDIsMSwzLjZ2OC43aC0xLjV2LTguNw0KCQljMC0xLjItMC4zLTIuMS0wLjgtMi42Yy0wLjUtMC42LTEuMy0wLjktMi40LTAuOWMtMC45LDAtMS43LDAuMy0yLjQsMC44Yy0wLjcsMC42LTEuMiwxLjMtMS41LDIuM3Y5aC0xLjVWOTAuNkg5My42eiIvPg0KCTxwYXRoIGQ9Ik0xMDcuNCw5MC42bDAsMi4zYzAuNS0wLjgsMS4xLTEuNCwxLjktMS45YzAuNy0wLjQsMS42LTAuNiwyLjUtMC42YzEuNCwwLDIuNSwwLjQsMy4yLDEuMmMwLjcsMC44LDEsMiwxLDMuNnY4LjdoLTEuNQ0KCQl2LTguN2MwLTEuMi0wLjMtMi4xLTAuOC0yLjZjLTAuNS0wLjYtMS4zLTAuOS0yLjQtMC45Yy0wLjksMC0xLjcsMC4zLTIuNCwwLjhjLTAuNywwLjYtMS4yLDEuMy0xLjUsMi4zdjlIMTA2VjkwLjZIMTA3LjR6Ii8+DQoJPHBhdGggZD0iTTEyNC44LDEwNC4xYy0xLjEsMC0yLjEtMC4zLTMtMC44Yy0wLjktMC42LTEuNi0xLjMtMi4xLTIuM2MtMC41LTEtMC44LTIuMS0wLjgtMy4zdi0wLjVjMC0xLjMsMC4yLTIuNCwwLjctMy40DQoJCWMwLjUtMSwxLjItMS44LDIuMS0yLjRjMC45LTAuNiwxLjgtMC45LDIuOS0wLjljMS42LDAsMi45LDAuNSwzLjgsMS42YzAuOSwxLjEsMS40LDIuNiwxLjQsNC41djAuOGgtOS40djAuMw0KCQljMCwxLjUsMC40LDIuNywxLjMsMy43YzAuOSwxLDEuOSwxLjUsMy4yLDEuNWMwLjgsMCwxLjUtMC4xLDIuMS0wLjRjMC42LTAuMywxLjEtMC43LDEuNi0xLjRsMC45LDAuNw0KCQlDMTI4LjQsMTAzLjMsMTI2LjksMTA0LjEsMTI0LjgsMTA0LjF6IE0xMjQuNiw5MS42Yy0xLjEsMC0yLDAuNC0yLjgsMS4yYy0wLjgsMC44LTEuMiwxLjktMS40LDMuMmg3Ljl2LTAuMmMwLTEuMy0wLjQtMi4zLTEuMS0zLjENCgkJUzEyNS43LDkxLjYsMTI0LjYsOTEuNnoiLz4NCgk8cGF0aCBkPSJNMTM3LjUsMTAyLjhjMSwwLDEuOS0wLjMsMi42LTAuOWMwLjctMC42LDEuMS0xLjMsMS4xLTIuMmgxLjRjMCwwLjgtMC4zLDEuNS0wLjgsMi4ycy0xLjEsMS4yLTEuOCwxLjYNCgkJYy0wLjgsMC40LTEuNiwwLjYtMi41LDAuNmMtMS43LDAtMy4xLTAuNi00LjEtMS44Yy0xLTEuMi0xLjUtMi44LTEuNS00LjlWOTdjMC0xLjMsMC4yLTIuNSwwLjctMy41YzAuNS0xLDEuMS0xLjgsMi0yLjMNCgkJYzAuOS0wLjUsMS44LTAuOCwzLTAuOGMxLjQsMCwyLjYsMC40LDMuNiwxLjNjMC45LDAuOSwxLjQsMiwxLjUsMy40aC0xLjRjLTAuMS0xLTAuNC0xLjktMS4xLTIuNWMtMC43LTAuNi0xLjUtMS0yLjYtMQ0KCQljLTEuMywwLTIuMywwLjUtMy4xLDEuNGMtMC43LDEtMS4xLDIuMy0xLjEsNHYwLjRjMCwxLjcsMC40LDMsMS4xLDMuOUMxMzUuMiwxMDIuNCwxMzYuMiwxMDIuOCwxMzcuNSwxMDIuOHoiLz4NCgk8cGF0aCBkPSJNMTQ3LjgsODcuMnYzLjRoMi43djEuMmgtMi43djguOGMwLDAuNywwLjEsMS4zLDAuNCwxLjZjMC4zLDAuNCwwLjcsMC41LDEuMywwLjVjMC4yLDAsMC42LDAsMS4yLTAuMWwwLjEsMS4yDQoJCWMtMC40LDAuMS0wLjksMC4yLTEuNiwwLjJjLTEsMC0xLjctMC4zLTIuMi0wLjljLTAuNS0wLjYtMC43LTEuNC0wLjctMi42di04LjhoLTIuNHYtMS4yaDIuNHYtMy40SDE0Ny44eiIvPg0KCTxwYXRoIGQ9Ik0xNTMuNSw4Ni44YzAtMC4zLDAuMS0wLjUsMC4zLTAuN2MwLjItMC4yLDAuNC0wLjMsMC43LTAuM2MwLjMsMCwwLjYsMC4xLDAuNywwLjNjMC4yLDAuMiwwLjMsMC40LDAuMywwLjcNCgkJYzAsMC4zLTAuMSwwLjUtMC4zLDAuN2MtMC4yLDAuMi0wLjQsMC4zLTAuNywwLjNjLTAuMywwLTAuNi0wLjEtMC43LTAuM0MxNTMuNiw4Ny4zLDE1My41LDg3LjEsMTUzLjUsODYuOHogTTE1NS4yLDEwMy44aC0xLjUNCgkJVjkwLjZoMS41VjEwMy44eiIvPg0KCTxwYXRoIGQ9Ik0xNjAuNSw5MC42bDAsMi4zYzAuNS0wLjgsMS4xLTEuNCwxLjktMS45YzAuNy0wLjQsMS42LTAuNiwyLjUtMC42YzEuNCwwLDIuNSwwLjQsMy4yLDEuMmMwLjcsMC44LDEsMiwxLDMuNnY4LjdoLTEuNQ0KCQl2LTguN2MwLTEuMi0wLjMtMi4xLTAuOC0yLjZjLTAuNS0wLjYtMS4zLTAuOS0yLjQtMC45Yy0wLjksMC0xLjcsMC4zLTIuNCwwLjhjLTAuNywwLjYtMS4yLDEuMy0xLjUsMi4zdjloLTEuNVY5MC42SDE2MC41eiIvPg0KCTxwYXRoIGQ9Ik0xNzIuMyw5Ny4xYzAtMi4xLDAuNS0zLjcsMS40LTQuOWMwLjktMS4yLDIuMi0xLjgsMy43LTEuOGMxLjgsMCwzLjIsMC43LDQuMSwyLjFsMC4xLTEuOWgxLjR2MTIuOWMwLDEuNy0wLjUsMy0xLjQsNA0KCQlzLTIuMiwxLjUtMy45LDEuNWMtMC45LDAtMS44LTAuMi0yLjYtMC42Yy0wLjgtMC40LTEuNS0xLTItMS42bDAuOC0wLjljMSwxLjMsMi4zLDEuOSwzLjcsMS45YzEuMiwwLDIuMi0wLjQsMi45LTEuMQ0KCQljMC43LTAuNywxLTEuNywxLjEtM3YtMS43Yy0wLjksMS4zLTIuMywyLTQuMSwyYy0xLjUsMC0yLjgtMC42LTMuNy0xLjhzLTEuNC0yLjktMS40LTQuOVY5Ny4xeiBNMTczLjgsOTcuM2MwLDEuNywwLjMsMywxLDQNCgkJYzAuNywxLDEuNiwxLjUsMi45LDEuNWMxLjgsMCwzLjEtMC44LDMuOC0yLjR2LTYuMWMtMC4zLTAuOC0wLjgtMS41LTEuNS0xLjljLTAuNi0wLjQtMS40LTAuNy0yLjMtMC43Yy0xLjIsMC0yLjIsMC41LTIuOSwxLjQNCgkJQzE3NC4xLDk0LDE3My44LDk1LjUsMTczLjgsOTcuM3oiLz4NCgk8cGF0aCBkPSJNMjAyLjgsOTguOGgtOC4xbC0xLjgsNWgtMS42TDE5OCw4NmgxLjRsNi43LDE3LjhoLTEuNkwyMDIuOCw5OC44eiBNMTk1LjIsOTcuNmg3LjFsLTMuNi05LjdMMTk1LjIsOTcuNnoiLz4NCgk8cGF0aCBkPSJNMjEwLjYsMTAzLjhoLTEuNVY4NmgxLjVWMTAzLjh6Ii8+DQoJPHBhdGggZD0iTTIyMy40LDg3LjJ2My40aDIuN3YxLjJoLTIuN3Y4LjhjMCwwLjcsMC4xLDEuMywwLjQsMS42czAuNywwLjUsMS4zLDAuNWMwLjIsMCwwLjYsMCwxLjItMC4xbDAuMSwxLjINCgkJYy0wLjQsMC4xLTAuOSwwLjItMS42LDAuMmMtMSwwLTEuNy0wLjMtMi4yLTAuOWMtMC41LTAuNi0wLjctMS40LTAuNy0yLjZ2LTguOGgtMi40di0xLjJoMi40di0zLjRIMjIzLjR6Ii8+DQoJPHBhdGggZD0iTTIyOC4yLDk3YzAtMS4zLDAuMi0yLjQsMC43LTMuNHMxLjItMS44LDIuMS0yLjRjMC45LTAuNiwxLjktMC44LDMuMS0wLjhjMS44LDAsMy4yLDAuNiw0LjMsMS44YzEuMSwxLjIsMS42LDIuOSwxLjYsNC45DQoJCXYwLjNjMCwxLjMtMC4yLDIuNC0wLjcsMy40Yy0wLjUsMS0xLjIsMS44LTIuMSwyLjRzLTEuOSwwLjgtMy4xLDAuOGMtMS44LDAtMy4yLTAuNi00LjMtMS44Yy0xLjEtMS4yLTEuNi0yLjktMS42LTQuOVY5N3oNCgkJIE0yMjkuNiw5Ny40YzAsMS42LDAuNCwyLjksMS4yLDMuOWMwLjgsMSwxLjksMS41LDMuMiwxLjVjMS4zLDAsMi40LTAuNSwzLjItMS41YzAuOC0xLDEuMi0yLjMsMS4yLTRWOTdjMC0xLTAuMi0xLjktMC42LTIuOA0KCQlzLTAuOS0xLjUtMS42LTEuOWMtMC43LTAuNS0xLjQtMC43LTIuMy0wLjdjLTEuMywwLTIuNCwwLjUtMy4yLDEuNWMtMC44LDEtMS4yLDIuNC0xLjIsNFY5Ny40eiIvPg0KCTxwYXRoIGQ9Ik0yNTkuNCw5OS40YzAtMS0wLjMtMS44LTEtMi4zYy0wLjctMC42LTItMS4xLTMuOC0xLjZjLTEuOC0wLjUtMy4yLTEuMS00LTEuN2MtMS4yLTAuOS0xLjgtMi0xLjgtMy40DQoJCWMwLTEuNCwwLjYtMi41LDEuNy0zLjNjMS4xLTAuOSwyLjUtMS4zLDQuMy0xLjNjMS4yLDAsMi4yLDAuMiwzLjIsMC43YzAuOSwwLjUsMS43LDEuMSwyLjIsMS45YzAuNSwwLjgsMC44LDEuNywwLjgsMi43aC0xLjUNCgkJYzAtMS4yLTAuNC0yLjItMS4yLTIuOWMtMC44LTAuNy0xLjktMS4xLTMuMy0xLjFjLTEuNCwwLTIuNCwwLjMtMy4yLDAuOWMtMC44LDAuNi0xLjIsMS40LTEuMiwyLjRjMCwwLjksMC40LDEuNiwxLjEsMi4yDQoJCWMwLjcsMC42LDEuOSwxLjEsMy41LDEuNWMxLjYsMC40LDIuOCwwLjksMy42LDEuNGMwLjgsMC41LDEuNCwxLDEuOSwxLjdjMC40LDAuNywwLjYsMS40LDAuNiwyLjNjMCwxLjQtMC42LDIuNS0xLjcsMy40DQoJCWMtMS4xLDAuOC0yLjYsMS4zLTQuNCwxLjNjLTEuMywwLTIuNC0wLjItMy40LTAuN3MtMS44LTEuMS0yLjQtMS45Yy0wLjUtMC44LTAuOC0xLjctMC44LTIuOGgxLjVjMCwxLjMsMC41LDIuMiwxLjQsMw0KCQljMC45LDAuNywyLjIsMS4xLDMuNywxLjFjMS40LDAsMi41LTAuMywzLjMtMC45QzI1OSwxMDEuMywyNTkuNCwxMDAuNSwyNTkuNCw5OS40eiIvPg0KCTxwYXRoIGQ9Ik0yNjMuOCw4Ni44YzAtMC4zLDAuMS0wLjUsMC4zLTAuN3MwLjQtMC4zLDAuNy0wLjNzMC42LDAuMSwwLjcsMC4zYzAuMiwwLjIsMC4zLDAuNCwwLjMsMC43YzAsMC4zLTAuMSwwLjUtMC4zLDAuNw0KCQljLTAuMiwwLjItMC40LDAuMy0wLjcsMC4zcy0wLjYtMC4xLTAuNy0wLjNTMjYzLjgsODcuMSwyNjMuOCw4Ni44eiBNMjY1LjUsMTAzLjhIMjY0VjkwLjZoMS41VjEwMy44eiIvPg0KCTxwYXRoIGQ9Ik0yNzEuMSwxMDMuOGgtMS41Vjg1LjFoMS41VjEwMy44eiIvPg0KCTxwYXRoIGQ9Ik0yNzUsODYuOGMwLTAuMywwLjEtMC41LDAuMy0wLjdzMC40LTAuMywwLjctMC4zczAuNiwwLjEsMC43LDAuM2MwLjIsMC4yLDAuMywwLjQsMC4zLDAuN2MwLDAuMy0wLjEsMC41LTAuMywwLjcNCgkJYy0wLjIsMC4yLTAuNCwwLjMtMC43LDAuM3MtMC42LTAuMS0wLjctMC4zUzI3NSw4Ny4xLDI3NSw4Ni44eiBNMjc2LjcsMTAzLjhoLTEuNVY5MC42aDEuNVYxMDMuOHoiLz4NCgk8cGF0aCBkPSJNMjg1LjUsMTAyLjhjMSwwLDEuOS0wLjMsMi42LTAuOWMwLjctMC42LDEuMS0xLjMsMS4xLTIuMmgxLjRjMCwwLjgtMC4zLDEuNS0wLjgsMi4ycy0xLjEsMS4yLTEuOCwxLjYNCgkJYy0wLjgsMC40LTEuNiwwLjYtMi41LDAuNmMtMS43LDAtMy4xLTAuNi00LjEtMS44Yy0xLTEuMi0xLjUtMi44LTEuNS00LjlWOTdjMC0xLjMsMC4yLTIuNSwwLjctMy41czEuMS0xLjgsMi0yLjMNCgkJYzAuOS0wLjUsMS44LTAuOCwzLTAuOGMxLjQsMCwyLjYsMC40LDMuNiwxLjNjMC45LDAuOSwxLjQsMiwxLjUsMy40aC0xLjRjLTAuMS0xLTAuNC0xLjktMS4xLTIuNXMtMS41LTEtMi42LTENCgkJYy0xLjMsMC0yLjMsMC41LTMuMSwxLjRzLTEuMSwyLjMtMS4xLDR2MC40YzAsMS43LDAuNCwzLDEuMSwzLjlDMjgzLjIsMTAyLjQsMjg0LjIsMTAyLjgsMjg1LjUsMTAyLjh6Ii8+DQoJPHBhdGggZD0iTTI5Mi43LDk3YzAtMS4zLDAuMi0yLjQsMC43LTMuNHMxLjItMS44LDIuMS0yLjRjMC45LTAuNiwxLjktMC44LDMuMS0wLjhjMS44LDAsMy4yLDAuNiw0LjMsMS44YzEuMSwxLjIsMS42LDIuOSwxLjYsNC45DQoJCXYwLjNjMCwxLjMtMC4yLDIuNC0wLjcsMy40Yy0wLjUsMS0xLjIsMS44LTIuMSwyLjRzLTEuOSwwLjgtMy4xLDAuOGMtMS44LDAtMy4yLTAuNi00LjMtMS44Yy0xLjEtMS4yLTEuNi0yLjktMS42LTQuOVY5N3oNCgkJIE0yOTQuMiw5Ny40YzAsMS42LDAuNCwyLjksMS4yLDMuOWMwLjgsMSwxLjksMS41LDMuMiwxLjVjMS4zLDAsMi40LTAuNSwzLjItMS41YzAuOC0xLDEuMi0yLjMsMS4yLTRWOTdjMC0xLTAuMi0xLjktMC42LTIuOA0KCQlzLTAuOS0xLjUtMS42LTEuOWMtMC43LTAuNS0xLjQtMC43LTIuMy0wLjdjLTEuMywwLTIuNCwwLjUtMy4yLDEuNWMtMC44LDEtMS4yLDIuNC0xLjIsNFY5Ny40eiIvPg0KCTxwYXRoIGQ9Ik0zMDguOSw5MC42bDAsMi4zYzAuNS0wLjgsMS4xLTEuNCwxLjktMS45YzAuNy0wLjQsMS42LTAuNiwyLjUtMC42YzEuNCwwLDIuNSwwLjQsMy4yLDEuMmMwLjcsMC44LDEsMiwxLDMuNnY4LjdIMzE2di04LjcNCgkJYzAtMS4yLTAuMy0yLjEtMC44LTIuNmMtMC41LTAuNi0xLjMtMC45LTIuNC0wLjljLTAuOSwwLTEuNywwLjMtMi40LDAuOGMtMC43LDAuNi0xLjIsMS4zLTEuNSwyLjN2OWgtMS41VjkwLjZIMzA4Ljl6Ii8+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8L3N2Zz4NCg=="/>
</a>
<h1>SYCL for CUDA Developers - Memory Model</h1>
</div>
</header>
</article>
<a class="header-link" href="#memory-model" id="memory-model"><h1>﻿Memory Model</h1></a>
<p>GPUs employ a similar memory hierarchy to the one used in CPU devices, 
including multiple levels of memory with different latency, bandwidths, 
and capacity.  The lower the memory latency is, the closer the memory 
position is to the processor, and the lower its capacity is. 
In the following sections we explain how these levels of memory are 
exposed in both CUDA and SYCL.</p>
<a class="header-link" href="#cuda-memory-model" id="cuda-memory-model"><h2>CUDA Memory Model</h2></a>
<p>The CUDA memory model is explicit. This will expose the full control of memory
hierarchy to the programmer for allocation, de-allocation and data movement
between host and device.  CUDA memory allocations are performed using
<em>cudaMalloc</em> which is equivalent to a <em>malloc</em> function, and returns a pointer
that is not dereferencable on the host.  The following image represents the
overall architecture of the CUDA memory model.</p>
<p><img alt="CUDA memory architecture" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeEAAAJWCAIAAADgD6gJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGRmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxOC0wNi0yMlQxNTowNTowNyswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0wNi0yMlQxNTowNTowNyswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTgtMDYtMjJUMTU6MDU6MDcrMDE6MDAiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Y2JlMzA0YmQtMjliMi1iMTQ3LWEyNmYtYmQ0NDg1ZmM2OGJjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6ODk3MGY0MjktNTVkOC0wYzQwLWExYzgtYmI4MmZkOTg3MTEzIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZDIyM2VlZmMtYmZjNC02ZTQyLTgwYjctMDMxODc0ZjA5ZTczIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZDIyM2VlZmMtYmZjNC02ZTQyLTgwYjctMDMxODc0ZjA5ZTczIiBzdEV2dDp3aGVuPSIyMDE4LTA2LTIyVDE1OjA1OjA3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYmUzMDRiZC0yOWIyLWIxNDctYTI2Zi1iZDQ0ODVmYzY4YmMiIHN0RXZ0OndoZW49IjIwMTgtMDYtMjJUMTU6MDU6MDcrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDxyZGY6QmFnPiA8cmRmOmxpPjE5NkYwQTcyMjZFNjNFRTUzMTMxOTRGQkVDNzI2MzM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+q97n9wAAOMFJREFUeJzt3X18VOWd9/FfeJiZPEwehgSSCZghgQRjQCEg8qgRBdGuglVKRVyXIk3dV3ddu7Z3t7tqu269u20t3b5eNiprcyu0SKk8rBZQkYpBxIBIEpAEEhhIMgGSyYTJ0wwQ7j8unU0TEjAzyVwz+bxf/DE5c86Za67r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"/></p>
<a class="header-link" href="#register" id="register"><h3>Register</h3></a>
<p>The fastest memory type on NVIDIA GPUs is the register file. Registers are used for
allocating variables which are private to each threads. Registers are divided
among warps in an SM. However, there is a very limited number of registers
available per SM. Therefore, using fewer registers in the kernel
allows more thread blocks to be executed concurrently on an SM and therefore the
GPU occupancy and performance will improve. Kernel variables without a type
qualifier will be allocated in registers. Also, if the array indices are
constant and can be deduced at compile time, they will be allocated in a
register as well.</p>
<a class="header-link" href="#shared-memory" id="shared-memory"><h3>Shared memory</h3></a>
<p>Variables annotated with <code>__shared__</code> are stored in shared memory. 
Shared memory is on chip, and it has lower latency than global memory. 
Also, its memory bandwidth is higher
than that of global memory. As the name suggests, the shared memory is shared
among the threads in a thread-block. Each SM has a limited amount of shared
memory. Using too much shared memory per thread block will decrease the number
of active warps and can consequently cause a drop in performance.</p>
<a class="header-link" href="#global-memory" id="global-memory"><h3>Global memory</h3></a>
<p>The global memory is the device memory, visible by all SMs in the GPU
architecture. Global memory can be allocated in the host code through
<code>cudaMalloc</code> and freed from host code by <code>cudaFree</code>. The created memory will be
passed as a pointer to the CUDA device kernel function as a parameter.  Also a
variable can be declared as global inside the kernel by adding <code>__device__</code>
qualifier in front of it.</p>
<a class="header-link" href="#constant-memory" id="constant-memory"><h3>Constant memory</h3></a>
<p>The constant memory is a read-only device memory that stores variables
annotated with <code>__constant__</code> attribute.  Constant variables are declared
statically. Their scope is global and they must be defined outside of the
kernel as they will be visible to all kernels. For each SM, the constant
variables will be allocated in a separate cache area dedicated for the constant
variables. To get the best performance from the constant memory, all threads in
a warp should read the same memory address.</p>
<a class="header-link" href="#texture-memory" id="texture-memory"><h3>Texture memory</h3></a>
<p>The texture memory is a type of read-only device memory. For each SM, there is a
dedicated read only cache called a texture cache. The texture
cache is optimized for two-dimensional array access, and is optimized to be accessed 
by warps accessing two-dimensional data.</p>
<a class="header-link" href="#local-memory" id="local-memory"><h3>Local memory</h3></a>
<p>The local memory is a virtual concept where the actual location for it is in
the global memory.  Local memory is used for allocating register spills
(including large arrays); local structures; variables that cannot fit into
registers, or arrays whose indices cannot be deduced at compile-time. The
accesses to local memory are always cached in per-SM L1 caches and per-device L2
caches for compute capability 3.x.  For devices with compute capability of
5.x and 6.x, the data accesses are always cached in per-device L2 caches.</p>
<a class="header-link" href="#cuda-memory-management" id="cuda-memory-management"><h2>CUDA memory Management</h2></a>
<p>The CUDA programming model uses pointer annotations to indicate where the different
objects are allocated in memory. When allocating global memory, C-style
<code>malloc</code> functions can be used to create device-pointers.</p>
<a class="header-link" href="#cuda-memory-allocation" id="cuda-memory-allocation"><h3>CUDA memory allocation</h3></a>
<p>CUDA memory allocation is triggered by calling :</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">)</span><span class="w"></span>
</pre></div>
</code></pre>
<p>This function allocates a device pointer of size <code>num_bytes</code> bytes of global
memory on the device and returns the address of the allocated memory in <code>dev_ptr</code>.
The allocated pointer is aligned for any variable type.</p>
<p>Since the memory model is explicit, it is the user's responsibility to transfer
the data between host and device using the right memory transfer operations,
described in the next section.</p>
<p>A device pointer can be initialized by:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaMemset</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">);</span><span class="w"></span>
</pre></div>
</code></pre>
<p>This function will set the following <code>num_bytes</code> of the memory position starting in 
<code>dev_ptr</code> with the value of <code>val</code>.</p>
<p>It is also the user's responsibility to free the memory. Releasing the memory
can be triggered by calling:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaFree</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dev_ptr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</code></pre>
<p>The function will return an error if the memory is not created or has been
already freed.</p>
<a class="header-link" href="#cuda-memory-transfer" id="cuda-memory-transfer"><h3>CUDA memory transfer</h3></a>
<p>The following function is used to transfer data from <code>source</code> to <code>destination</code> in
CUDA:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaMemcpy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">destination</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"></span>
<span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="k">enum</span> <span class="nc">cudaMemcpykind</span><span class="w"> </span><span class="n">kind</span><span class="p">);</span><span class="w"></span>
</pre></div>
</code></pre>
<p><code>cudaMemcpyKind</code> can be one of the following types:</p>
<ul>
<li>
<p><code>cudaMemcpyHostToHost</code> : determines that the source and destination are host
  pointers.</p>
</li>
<li>
<p><code>cudaMemcpyHostToDevice</code> : determines that the source is a host pointer and
  the destination is a device pointer.</p>
</li>
<li>
<p><code>cudaMemcpyDeviceToHost</code> : determines that the source is a device pointer and
  the destination is a host pointer.</p>
</li>
<li>
<p><code>cudaMemcpyDeviceToDevice</code> : determines that the source and destination are
  device pointers.</p>
</li>
</ul>
<p>These API entries always block the user thread. 
If the source and destination does not match the directionality
determined by <code>kind</code> , the result is undefined. </p>
<p>The asynchronous version of data transfer can be called using the following
function:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaMemcpyAsync</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyKind</span><span class="w"> </span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</code></pre>
<p>The above function is non-blocking with respect to the host, so calling the
function may return before completing the copy. The default behaviour of
the above function is independent from the stream, however, it is possible to
associate the copy to a stream by passing a non-zero stream argument. When the
stream is specified using the <code>cudaMemcpyHostToDevice</code> or
<code>cudaMemcpyDeviceToHost</code> may result in overlapping copy with other operations
in other streams.</p>
<a class="header-link" href="#cuda-pinned-memory" id="cuda-pinned-memory"><h3>CUDA pinned memory</h3></a>
<p>By default, CUDA allocated memory is pageable virtual memory. However, CUDA allows programmers
to pin the host memory. When the host memory is not pinned, the GPU device has
no control over the host memory in the event of a page fault on the host
memory.</p>
<p>Therefore, whenever the data transfer function is called,  the CUDA driver
allocates a temporary pinned memory and copies the data to the pinned memory and
then transfers the data from the pinned memory to the device. Once the memory
has been pinned on the host side, it is not pageable from the host side
anymore.</p>
<p>If the user provides pinned host memory, CUDA will not
allocate temporary pageable memory, eliminating the extra intermediate copy
operation. To allocate pinned memory in CUDA, the following function can be used:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaMallocHost</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</code></pre>
<p><code>num_bytes</code> represents the number of allocated bytes and <code>dev_ptr</code> is the
actual non-pageable host pointer which is accessible from the device. Since
this memory is directly accessible from the device, the read/write bandwidth is
higher than that of pageable memory.</p>
<a class="header-link" href="#cuda-zero-copy-memory" id="cuda-zero-copy-memory"><h3>CUDA zero-copy memory</h3></a>
<p>CUDA zero-copy memory is pinned host memory mapped into the device address
space.  CUDA zero-copy will avoid the explicit data movement between host
and device. Although zero-copy improves the PCIe transfer rates, it is required
to be synchronized whenever data is shared between host and device. Otherwise, the
behavior is undefined. Zero-copy memory can also be useful when there is not
enough memory available on device. Zero-copy memory can be allocated by calling
the following function:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaHostAlloc</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="n">ptr_host</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"></span>
</pre></div>
</code></pre>
<p>The possible flags are :
* <code>cudaHostAllocDefault</code> : this is the equivalent of CUDA pinned memory.</p>
<ul>
<li>
<p><code>cudaHostAllocPortable</code> : allocates pinned memory that can be accessed by
  all CUDA contexts.</p>
</li>
<li>
<p><code>cudaHostAllocWriteCombined</code>: allocates a pinned memory useful to create a buffer
  to be written by the host and read by the device.</p>
</li>
<li>
<p><code>cudaHostAllocMapped</code> : allocates host memory mapped into the device address
  space.</p>
</li>
</ul>
<p>Calling the following function provides the device pointer for mapped, pinned memory:</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaHostGetDevicePointer</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">ptr_device</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr_host</span><span class="p">,</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
</pre></div>
</code></pre>
<p>If an NVIDIA GPU has the ability to access host registered memory at the same 
virtual address as the CPU, the <code>ptr_device</code> will match the <code>ptr_host</code>
pointer, meaning that the memory can be accessed on the device by using the
same host pointer <code>ptr_host</code>. Otherwise, the device pointer may or may not
match the original host pointer.</p>
<p>Although zero-copy memory avoids explicit memory transfers between host and
device by allocating pinned host memory, the kernel performance generally
suffers from high-latency accesses to zero-copy memory over the PCIe bus.</p>
<a class="header-link" href="#cuda-memory-access-patterns" id="cuda-memory-access-patterns"><h2>CUDA Memory Access Patterns</h2></a>
<p>Global Memory is a logical memory space residing in DRAM. Kernel code accesses
the data between DRAM and SM on-chip memory using L1 and L2 cache
as a shortcut whenever it is possible. The data transfer is either a 128-byte or
32-byte memory transaction. If only L2 cache is used, the access to data will be
32-byte memory transaction. However, if both L1 and L2 are used the access to
data would be a 128-byte memory transaction. The L1 cache can be enabled or
disabled manually, depending on the type of GPU architecture. The memory load
is considered as cached load if the L1 cache is enabled. The L1 cache can be explicitly enabled or disabled by passing the <code>-Xptxas -dlcm=FLAG</code>, where the
<code>FLAG</code> can either be <code>ca</code> to enable the L1 cache or <code>cg</code> to disable it.
However, on some NVIDIA GPU architectures such Kepler K10, K20, and K20x, the
L1 cache is disabled by default, in order to be used for caching register spills
to local memory. Knowing the data size in L1
and L2 cache in CUDA, in the following sub sections we explain the concept of
aligned memory access and coalesced memory access.</p>
<a class="header-link" href="#aligned-memory-access" id="aligned-memory-access"><h3>Aligned memory access</h3></a>
<p>Memory accesses are called <em>aligned</em> when the address referenced in device memory
is a multiple of 32 bytes for L2 cache or 128 bytes for L1 cache. If the
memory load is misaligned, the memory bandwidth usage is reduced.</p>
<a class="header-link" href="#coalesced-memory-access" id="coalesced-memory-access"><h3>Coalesced memory access</h3></a>
<p>Memory accesses are called <em>coalesced</em> if all 32 threads in a warp access a
contiguous chunk of memory. The following image shows coalesced memory access
by all threads of a warp.</p>
<p><img alt="Coalesced memory" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAzcAAAF9CAYAAAA5jZb5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGRmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxOC0wNi0yMlQxNTowMToyNiswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0wNi0yMlQxNTowMToyNiswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTgtMDYtMjJUMTU6MDE6MjYrMDE6MDAiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTE2ZjNjMmMtOGY4ZC05NzRjLTg1ZjMtOGE0M2UyYmE5NjBjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6MThlMGQ5OTktNmQ5OS1mMzQxLTlmN2UtYWQ3OWYyNTA3ZTViIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWJjYWM3MjItNTU3NS0yOTQ2LWE5ZDEtZWE5YTEzOTMxMmRiIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWJjYWM3MjItNTU3NS0yOTQ2LWE5ZDEtZWE5YTEzOTMxMmRiIiBzdEV2dDp3aGVuPSIyMDE4LTA2LTIyVDE1OjAxOjI2KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo5MTZmM2MyYy04ZjhkLTk3NGMtODVmMy04YTQzZTJiYTk2MGMiIHN0RXZ0OndoZW49IjIwMTgtMDYtMjJUMTU6MDE6MjYrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDxyZGY6QmFnPiA8cmRmOmxpPjE5NkYwQTcyMjZFNjNFRTUzMTMxOTRGQkVDNzI2MzM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+93ZZVQAAFPZJREFUeJzt3T9rHXt+x/GPNvcJyLBPQK5cbSFDCCGQQi5mQppcZEiVTqq3sooUdyGFVKW2qqRasLhpFuZX2MWFEJYFq9jKlfUILtZDUIqZuTo+V7JkWX+/er1A6M+Zc77H+Ajmrd/MnJWTk5NQz8rKSpKk67qNJFtJDltr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"/></p>
<a class="header-link" href="#cache-line" id="cache-line"><h3>Cache line</h3></a>
<p>The L1 cache line is 128 bytes mapped to a 128 byte aligned segment in 
device memory. Therefore, an aligned coalesced access of 4 bytes per thread in
a warp will perfectly map to the L1 cache line and will be loaded to
register/shared memory by only one single 128-byte memory transaction.</p>
<a class="header-link" href="#sycl-memory-model" id="sycl-memory-model"><h2>SYCL Memory Model</h2></a>
<p>The SYCL memory model is based on the OpenCL memory model, but operates at
a higher level of abstraction. 
The key difference of this
abstraction is the separation of storage from access to memory which is
expressed through the relationship between memory objects (buffers or images) and accessors.</p>
<p>From the device point of view, the SYCL 1.2.1 memory model is fundamentally the same as the OpenCL 1.2 memory model.</p>
<p>From a user's point of view, SYCL creates one memory object in the form of a buffer or image. 
This memory object can be accessed on the host via a host accessor. 
The same memory object can be accessed on the device side via a device accessor.</p>
<p>It is important to understand that the SYCL buffer/image is a host API managing the data allocation and data transfer across variable devices.  By creating an accessor, we create a requirement on the SYCL buffer/image. This requirement can be allocating memory, synchronization between two accessors, and data transfer between host and device.  An accessor is an object telling the SYCL buffer/image where the data needs to be.  If the host accessor is requested from a buffer/image, it implicitly implies that the data needs to be on the host. So the SYCL buffer/image allocates the data on the host.  If a device accessor is requested from a SYCL buffer/image, it implicitly implies that the data needs to be on the device. Therefore, the SYCL buffer/image allocates the memory on
the device. The SYCL buffer/image also handles the data transfer and
synchronization, based on the accessor mode. For further information about data transfer using access modes, please refer to the
SYCL <a href="#sycl-memory-transfer">memory transfer section</a>.</p>
<a class="header-link" href="#private-memory" id="private-memory"><h3>Private Memory</h3></a>
<p>In SYCL, private memory is a region of memory allocated per work item, 
visible only to that work item. Private memory is used for kernel parameters
and local stack variables. Private memory cannot be accessed from the host.</p>
<p>Private memory is typically mapped to hardware registers. 
There is no mechanism in SYCL to query
the number of registers available to a particular device.
Developers must refer to the documentation of the SYCL implementation and/or 
the hardware vendor to understand the limits of private memory.</p>
<a class="header-link" href="#local-memory-1" id="local-memory-1"><h3>Local Memory</h3></a>
<p>Local memory is a contiguous region of memory allocated per work group, and
visible to all work items within that work group. Local memory is allocated and
accessed using an accessor on submission. This memory cannot be accessed from
the host. From the device, local memory is
visible accessed as an array of contiguous elements of a particular type.
Multiple arrays of local memory can be allocated on the device. The maximum
available local memory depends on the hardware and the kernel configuration.</p>
<a class="header-link" href="#global-memory-1" id="global-memory-1"><h3>Global Memory</h3></a>
<p>In SYCL (and OpenCL), global memory represents allocations from a pool of memory
visible by all threads of the device. In addition, different devices in the
same SYCL context can see this memory.  Note that not all devices will be available in all contexts - this is an implementation specific detail that depends on the hardware architecture.</p>
<p>There are two ways of allocating global memory in SYCL: using Buffers or
Images.</p>
<a class="header-link" href="#buffer-memory" id="buffer-memory"><h4>Buffer Memory</h4></a>
<p>In SYCL, a buffer represents a contiguous region of memory which is managed by
the SYCL runtime, and can be accessed on the host and on device.  When accessed
on host, the runtime may copy it via temporary host storage.  When accessed from
the device, memory is stored in global address space (globally visible to all
work items) or the constant address space (globally visible to all work items,
but read-only) if the runtime works-out that the memory is read-only.</p>
<p>Accessing memory on the host requires construction of a host accessor, whereas
on the device it is accessed via command group accessors. </p>
<p>Once executing inside a device kernel or in a host accessor, the buffer is
represented as an array of contiguous elements of a particular type.</p>
<p>In the following code snippet, we access the buffer <code>buff_a</code> on the host side
by creating a host accessor <code>host_acc</code>, and access the same buffer <code>buff_a</code> on
the device side by using the device accessor <code>dev_acc</code> on the device.  </p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="c1">// creating a SYCL buffer which a data storage.</span>
<span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buff_a</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">100</span><span class="p">});</span><span class="w"></span>

<span class="c1">// geting a host access on the buff_a with write permission</span>
<span class="k">auto</span><span class="w"> </span><span class="n">host_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buff_a</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="c1">// using host accessor to fill the data in the buffer</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">host_acc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>

<span class="n">q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cgh</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="c1">// creating a device accessor on the buffer_a with write permission</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">dev_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buff_a</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">hello_world</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">100</span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="c1">// using device accessor inside the kernel to fill the data</span>
<span class="w">     </span><span class="n">device_acc</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="mf">1.0f</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="p">});</span><span class="w"> </span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</code></pre>
<a class="header-link" href="#image-memory" id="image-memory"><h4>Image Memory</h4></a>
<p>In SYCL, image objects represent a region of memory managed by the SYCL
runtime. The data layout of the image memory is deliberately unspecified so as to
allow implementations to provide a layout optimal to a given device. When
accessed on host, image memory may be stored on temporary host memory.  When
accessed on device, image data is stored in device image memory, which can often be
texture memory if the device supports it. Image memory can also be accessed as
an array of images representation.</p>
<p>Accessing image memory on the host is done by constructing an accessor with the
<code>host_image</code> access target. Accessing image memory on the device is done by
constructing an accessor with the <code>image</code> access target. Accessing image memory
on the device in an image array representation is done by constructing an
accessor with the <code>image_array</code> access target.</p>
<p>Image memory is accessed via member functions which perform read; sampled read,
and write functions on the memory on the device.</p>
<a class="header-link" href="#constant-memory-1" id="constant-memory-1"><h3>Constant Memory</h3></a>
<p>Constant memory is allocated using buffers that are read only or using constant
SYCL buffer objects.  See the Buffer Memory and Image Memory sections for more details on how to create a buffer or image memory.</p>
<a class="header-link" href="#sycl-memory-management" id="sycl-memory-management"><h2>SYCL memory Management</h2></a>
<p>In SYCL, memory is managed through buffer and image objects which maintain a
memory region across the host and one or more devices. Memory is accessed via
accessors: objects which represent a request to access the memory in a
particular region with particular properties.  Accessors are provided to a
command group as a way of describing data dependencies for a kernel function.
These data dependencies are used by the SYCL runtime to both satisfy data
requirements for kernel functions by making the memory available as requested
and to perform data movement optimizations.</p>
<p>Accessors are parameterized by an access target which specifies where the
memory is to be accessed and an access mode which specify how the memory is
to be accessed. The access target of an accessor can be <code>host_buffer</code>,
<code>global_buffer</code>, <code>constant_buffer</code>, <code>host_image</code>, <code>image</code> , <code>image_array</code> or
<code>local</code>. The access mode of an accessor can be <code>read</code>, <code>write</code>, <code>read_write</code>,
<code>discard_write</code>, <code>discard_read_write</code> and <code>atomic</code>.</p>
<a class="header-link" href="#sycl-memory-allocation" id="sycl-memory-allocation"><h3>SYCL memory allocation</h3></a>
<p>Memory allocation on the device is typically asynchronous in SYCL, and varies according to the implementation where this happens.</p>
<p>SYCL accessors are templated by the <code>cl::sycl::access::target</code> enum class which specify the memory space which memory is to be allocated in. When an accessor is passed to a SYCL kernel, it becomes a requirement for the kernel and is then allocated on the associated
memory space for the specified access target.</p>
<table>
<thead>
<tr>
<th>Access Target</th>
<th>Memory Space</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cl::sycl::access::target::host_buffer</code>, <code>cl::sycl::access::target::host_image</code></td>
<td>Host memory</td>
</tr>
<tr>
<td><code>cl::sycl::access::target::global_buffer</code></td>
<td>Global memory</td>
</tr>
<tr>
<td><code>cl::sycl::access::target::constant_buffer</code></td>
<td>Constant memory</td>
</tr>
<tr>
<td><code>cl::sycl::access::target::local</code></td>
<td>Local memory</td>
</tr>
<tr>
<td><code>cl::sycl::access::target::image</code>, <code>cl::sycl::access::target::image_array</code></td>
<td>Image memory</td>
</tr>
</tbody>
</table>
<a class="header-link" href="#sycl-memory-transfer" id="sycl-memory-transfer"><h3>SYCL memory transfer</h3></a>
<p>Memory transfers in SYCL are asynchronous, and performed implicitly by
the SYCL runtime when an accessor requires access to memory not available already on the device. 
SYCL accessors are templated by the <code>cl::sycl::access::mode</code> enum class which specifies the mode by which the
memory is to be accessed. When an accessor is passed to a SYCL kernel, it
becomes a requirement for the kernel, and the access mode effects the data
dependencies between SYCL kernels.
The implicit transfer, and the rule
determining whether or not the data should be transferred is defined by
the type of <code>cl::sycl::access::mode</code>. </p>
<p>The table below describes the different access modes available for SYCL accessors, and whether they can trigger a copy into the device memory from the host or not.</p>
<table>
<thead>
<tr>
<th>SYCL data access</th>
<th>Should the data be transferred to/from host/device</th>
<th>Is the accessed data modifyable on host/device</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cl::sycl::access::mode::read</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>cl::sycl::access::mode::write</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><code>cl::sycl::access::mode::read_write</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><code>cl::sycl::access::mode::discard_write</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>cl::sycl::access::mode::discard_read_write</code></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><code>cl::sycl::access::mode::atomic</code></td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<a class="header-link" href="#sycl-pinned-memory" id="sycl-pinned-memory"><h3>SYCL pinned memory</h3></a>
<p>There is no explicit mechanism to request pinned memory in SYCL. The SYCL
runtime will always aim to allocate memory in the most optimal way. However, the
specific requirements for this varies from one architecture to another and from
one OS to another, and there is no guarantee that SYCL devices support pinned
memory, so vendor documentation should be consulted for architecture specific
requirements. </p>
<p>There are generally two ways which host memory can be allocated:
* When <em>not using</em> the <code>cl::sycl::property::buffer::use_host_pointer</code> property,
the SYCL runtime will allocate host memory when required. This uses the implementation-specific mechanism, which can attempt to request pinned memory.</p>
<ul>
<li>If the <code>cl::sycl::property::buffer::use_host_pointer</code> property is used, then
the SYCL runtime will not allocate host memory and will use the pointer provided
when the <code>buffer</code> is constructed. In this case, it is the users responsibility
to ensure any requirements for memory allocation to allow pinned memory are
satisfied.</li>
</ul>
<p>Users can manually allocate pinned memory on the host, and hand it over to the SYCL implementation. This will often involve allocating host memory with a suitable
alignment and multiple, and sometimes can be managed manually using OS specific
operations such as <code>mmap</code> and <code>munmap</code>. </p>
<a class="header-link" href="#sycl-zero-copy-memory" id="sycl-zero-copy-memory"><h3>SYCL zero-copy memory</h3></a>
<p>In SYCL there is no explicit mechanism to request zero-copy. If a SYCL buffer is
allocated in pinned memory - according to the requirements above - then the SYCL
runtime will attempt to initialize with zero-copy if possible.</p>
<a class="header-link" href="#sycl-memory-access-patterns" id="sycl-memory-access-patterns"><h2>SYCL Memory Access Patterns</h2></a>
<p>A SYCL <code>nd_range</code> class describes the iteration space over which the SYCL kernel
is to be executed, which can be 1, 2 or 3 dimensional.</p>
<p>SYCL <code>buffer</code> and <code>image</code> memory objects, and the subsequent <code>accessor</code> objects
used to access the memory managed by them can also be 1, 2 or 3 dimensional. The
memory, however, is still allocated as a single contiguous array of elements,
regardless of the dimensionality. Therefore, when accessing an element of a
multi-dimensional <code>accessor</code> the position within that multi-dimensional space
must be translated to a linear position in memory.</p>
<p>For any given multi-dimensional range <code>R {r0, r1, 2}</code> and a point within that
range <code>I {i0, i1, i2}</code>:</p>
<ul>
<li>
<p>When a <code>buffer</code> or <code>local</code> <code>accessor</code> is accessed via a multi-dimensional <code>id</code>
or multiple subscript operators the linear position in memory is translated in
row-major order, i.e. <code>L = 12 + (i1 * r2) + (i0 * r2 * r1)</code>.</p>
</li>
<li>
<p>When an <code>image</code> <code>accessor</code> is accessed via a multi-dimensional <code>id</code> the linear
position in memory is translated in column-major order, i.e.
<code>L = 10 + (i1 * r0) + (i2 * r0 * r1)</code>.</p>
</li>
</ul>
<p>THe following diagram demonstrates accessing the <code>id</code> <code>{2, 1}</code> within the
<code>range</code> <code>{3, 4}</code> using both a <code>buffer</code> <code>accessor</code> (<code>buffer_acc</code>) linearizing in
row-major order and an <code>image</code> <code>accessor</code> (<code>image_cc</code>) linearizing in
column-major order .</p>
<p><img alt="Accessing the position of 2, 3) for a buffer accessor and image accessor. " src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtEAAAG5CAYAAABIhmitAAAIiXRFWHRteGZpbGUAJTNDbXhmaWxlJTIwaG9zdCUzRCUyMmFwcC5kaWFncmFtcy5uZXQlMjIlMjBtb2RpZmllZCUzRCUyMjIwMjAtMDUtMjFUMTIlM0E0OSUzQTQ5LjgxNFolMjIlMjBhZ2VudCUzRCUyMjUuMCUyMChXaW5kb3dzJTIwTlQlMjAxMC4wJTNCJTIwV2luNjQlM0IlMjB4NjQpJTIwQXBwbGVXZWJLaXQlMkY1MzcuMzYlMjAoS0hUTUwlMkMlMjBsaWtlJTIwR2Vja28pJTIwQ2hyb21lJTJGODMuMC40MTAzLjYxJTIwU2FmYXJpJTJGNTM3LjM2JTIyJTIwZXRhZyUzRCUyMkRNREwzX1ZvT0U0QVVxWklReko3JTIyJTIwdmVyc2lvbiUzRCUyMjEzLjEuMyUyMiUyMHR5cGUlM0QlMjJkZXZpY2UlMjIlM0UlM0NkaWFncmFtJTIwaWQlM0QlMjJIWkF5TDlyaWdqZHA2M1dJY0Z5QSUyMiUyMG5hbWUlM0QlMjJQYWdlLTElMjIlM0U3WnRkajVzNEZJWiUyRkRaY2Q4VTNtY3BLMFhhMjAzWlhtb3QycmxRc09zUW80QldkQzl0ZlhnQTJ4RFoxcDA0NlBSbE5WR255d0RYNThPTHdITzA2d0tkdjNOVHJzJTJGNklaTGh6ZnpWb24yRHElMkI3NFclMkI3M1QlMkYzZXc4V0pMYmNERGtOY2xFcGNsd1QlMkY3SHd1Z0s2NUZrdUZFcU1rb0xSZzZxTWFWVmhWT20yRkJkMDVOYWJVY0w5YW9IbEdQRGNKJTJCaXdyUiUyQkpCbmJEOVpWNUU3MlB6REo5JTJGTEtuaXZPbEVoV0ZvWm1qeko2dWpBRmI1MWdVMVBLaHFPeTNlQ2lneWU1RE8zZUxad2RiNnpHRlh0S0ElMkY4cnpqOFU1YW44TTMlMkY0bTI0JTJCNEJPSjM4UzNRemNQcURpS0VZdTdaV2VKb0tiSEtzTmRMNjRUckU5N3d2RDlBYVhkMlJPZmRHN2JzN0xnSlk4Zml1NXd6WEM3ZUtQZU9IenVONWlXbU5Wblh1VTBBVTRrdGYwRjNEQVVSaVFtTlIlMkZiVHVQbUIyTG9QNERCQ3d3TXZNajdjZ01EeHlNQVVITVklMkZIQkgyZzdhVlVSRWcxZ09YRHhFdml4ZkVBdm5nUDAyWHFIQnl4MTR1UkI0amJjQmhsZTB4TXNEd1F1Y2Y4Vkx2TXp3WklQWENocXZaSWtYaVBnViUyQk5CNHJReGVIcUQ0RmNUUWVKa3l3UU1VdjBKbzhWNzZ1OGtMUlB3S29jVjdPUVNURjRqNEZVS0w5MUtsbTNvVlJQeUtvTVY3ZjFIZlh4JTJCJTJGZHFRb05yU2dkZDg4aU1Na1hpWGMzckNhZnNFWFp3SXZES0t3YTBFcmRtSGY5ZjklMkJFWGxvYnc3ZnpCUjhRSkV3aHZibUNCYVZISWduVzFlJTJCMW5HWlFnNVNZcVVMWCUyQnU0Rm5VY1NPOWFXY1lsT3dZcWUzWHZzbzdMVkhHUXNuWTlxN0w5TUlhbWlJT1VKT2k0ckh2WG9vWURHYnM4M3pZdjg1c2pKT1dsdTVkOVh1WTNSeDlTRHVwQzQyVXFWVkE1dXdzc2ZDMHFWWkM0ckw4Y1RhVUtLZyUyRlNjSTNSekJZdnVTQU5WZG1IMEhpWldoV3ltckRQeXhTcmtCTnQlMkI3eE10UW9xZFl5aDhWcGNJUWVoVnZVVkUlMkZ1OFRMVUtLWG5VVjB6czh6TFZLcVJzU0Y4eHNjOEx0bHpWMXpuczgxcjhzZ3FDbDc3T1laMlh2RDdRYkZ2ZmNXZWZsNmxYSFQ4dSUyQkdYWG4lMkZsQnp2cHhENFp1ZlpGWDNRM0F1UFhyc2R0a3V0N1FZMDF3elUlMkZ4UGllekFsc2F1ejdlTlAxMjNMdE90SVNIOXJMRmNNSFB4OTBPMSUyRiUyQmhOSFdpdGU5RVclMkY3SDYlMkY2SUclMkJFakhlNUZ2VDl1dnJobmJiTDVuREYxZnRXRjFJcFdXRnQxRlNaVWtMeml4WlRQTVI5bHNPNDhnS1NvdUJNblNwSmwzV1ZtOTdDcXUxeCUyRnhTdFFXMW1NVEElMkZ5NWx6SSUyRjIwdVpFcDQlMkJ5NUVTcFRqVnclMkJhOTZCSWpVSEpqQWNGeiUyQnBCWmxKajBHJTJGMjZOQWQ3Z3JjM25VYjhEa0xYR1hpY0pzV3FHbElxczRQNTFHZlAzWGdidnhJbHY4VklQdkN0bFZLWndVeXpvdzklMkZEJTJCeTF6eWFRU2h0TlM0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gECbAoToNvU5NgIdEAg9xBCiZZMw9P6GXp9Mn9EIINCmACG6TX2OjUAHBEIPMYRo2SQMvb+h1yfTZzQCCLQpQIhuU59jI9ABgdBDDCFaNglD72/o9cn0GY0AAm0KEKLb1OfYCHRAIPQQQ4iWTcLQ+xt6fTJ9RiOAQJsChOg29Tk2Ah0QCD3EEKJlkzD0/oZen0yf0Qgg0KYAIbpNfY6NQAcE9E0m5K/3fXhZyOVltf3osSPB1xhygRMTEyGXR20IIBCpACE60sZRNgIIIIAAAggggEB7AoTo9uw5MgIIIIAAAggggECkAoToSBtH2QgggAACCCCAAALtCRCi27PnyAgggAACCCCAAAKRChCiI20cZSOAAAIIIIAAAgi0J0CIbs+eIyOAAAIIIIAAAghEKkCIjrRxlI0AAggggAACCCDQngAhuj17jowAAggggAACCCAQqQAhOtLGUTYCCCCAAAIIIIBAewKE6PbsOTICCCCAAAIIIIBApAKE6EgbR9kIIIAAAggggAAC7QkQotuz58gIIIAAAggggAACkQoQoiNtHGUjgAACCCCAAAIItCdAiG7PniMjgAACCCCAAAIIRCpAiI60cZSNAAIIIIAAAggg0J4AIbo9e46MAAIIIIAAAgggEKkAITrSxlE2AggggAACCCCAQHsChOj27DkyAggggAACCCCAQKQChOhIG0fZCCD8YuRBAAAgAElEQVSAAAIIIIAAAu0JEKLbs+fICCCAAAIIIIAAApEKEKIjbRxlI4AAAggggAACCLQnQIhuz54jI4AAAggggAACCEQqQIiOtHGUjQACCCCAAAIIINCeACG6PXuOjAACCCCAAAIIIBCpACE60sZRNgIIIIAAAggggEB7AoTo9uw5MgIIIIAAAggggECkAoToSBtH2QgggAACCCCAAALtCRCi27PnyAgggAACCCCAAAKRChCiI20cZSOAAAIIIIAAAgi0J0CIbs+eIyOAAAIIIIAAAghEKkCIjrRxlI0AAggggAACCCDQngAhuj17jowAAggggAACCCAQqQAhOtLGUTYCCCCAAAIIIIBAewKE6PbsOTICCCCAAAIIIIBApAKE6EgbR9kIIIAAAggggAAC7QkQotuz58gIIIAAAggggAACkQoQoiNtHGUjgAACCCCAAAIItCdAiG7PniMjgAACCCCAAAIIRCpAiI60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"/></p>
<p>Alternatively, the position w.r.t the origin for an <code>id</code> index can be calculated manually from the <code>id</code> and <code>range</code> objects.</p>
<a class="header-link" href="#aligned-memory-access-1" id="aligned-memory-access-1"><h3>Aligned memory access</h3></a>
<p>Memory access is said to be <em>aligned</em> when the first address of a memory allocation on the device 
is an even multiple of the global cache line size. 
In SYCL the global memory cache line size can be queried from a device, as shown below.</p>
<p>Aligned access typically increases performance.</p>
<pre><code class="c++"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">cacheLineSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">global_mem_cache_line_size</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</code></pre>
<a class="header-link" href="#coalesced-memory-access-1" id="coalesced-memory-access-1"><h3>Coalesced memory access</h3></a>
<p>Memory access is called <em>coalesced</em> in SYCL if contiguously executed work items
access a contiguous chunk of memory. This depends on the mapping between
the execution order of work items and the linearization of the <code>id</code> being used
to access memory. There is no guarantee as to the execution order of
work items: this may vary from one architecture to another.
Refer to the vendor documentation to find the right mapping between the hardware access pattern and the memory linearization.</p>
<a class="header-link" href="#similarities-and-differences" id="similarities-and-differences"><h2>Similarities and differences</h2></a>
<a class="header-link" href="#memory-model-comparison-for-cuda-and-sycl" id="memory-model-comparison-for-cuda-and-sycl"><h3>Memory model comparison for CUDA and SYCL</h3></a>
<p>The following table shows the equivalence between the different components
of the memory architecture in SYCL and CUDA.</p>
<table>
<thead>
<tr>
<th align="center">CUDA name</th>
<th align="center">SYCL name</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Per-thread local memory</td>
<td align="center">Private memory</td>
</tr>
<tr>
<td align="center">Per-block shared memory</td>
<td align="center">Local memory</td>
</tr>
<tr>
<td align="center">Global memory</td>
<td align="center">Global memory</td>
</tr>
<tr>
<td align="center">Constant memory</td>
<td align="center">Constant memory</td>
</tr>
<tr>
<td align="center">Texture memory</td>
<td align="center">Image memory</td>
</tr>
<tr>
<td align="center">Local-memory</td>
<td align="center"><em>N/A</em></td>
</tr>
</tbody>
</table>
<p>Note that developers cannot make assumptions as to where the different
memory is actually placed in the hardware when using SYCL. 
Implementation documentation shows where in the actual hardware the different
memories are mapped.
However, which architectural element can access the different memories 
remains the same across all architectures, e.g private-memory is only
visible by the work-item it belongs, whereas global memory is visible 
by all work-items in the ND-range.</p>
<a class="header-link" href="#using-c-style-pointers-on-cuda-and-sycl" id="using-c-style-pointers-on-cuda-and-sycl"><h3>Using C-style pointers on CUDA and SYCL</h3></a>
<p>It is important to note that CUDA memory allocations are handled using C-style
pointers that are not accessible directly on the host, and forces users to
handle the host and the device copy of the information independently - except
when using either CUDA unified memory or CUDA virtual addressing, see the sections
below.</p>
<p>The following example illustrates a trivial CUDA memory allocation.</p>
<pre><code class="c++"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">dev_a</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="c1">// allocate the memory on the GPU</span>
<span class="w"> </span><span class="n">HANDLE_ERROR</span><span class="p">(</span><span class="w"> </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev_a</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</code></pre>
<p>The calls to cudaMalloc will allocate <code>dev_a</code>, <code>dev_b</code> and <code>dev_c</code> pointers,
which will be accessible only from the device.  Pointer arithmetic is possible,
so <code>dev_a + 3</code> will point to the 3rd integer in the array on the device.  Also,
the pointer address is guaranteed to be the same across multiple kernel
executions, since allocations are performed directly by the hardware low-level
driver.</p>
<p>This is different from the approach to memory allocation exposed by SYCL. In
SYCL, memory allocation is handled via C++ objects that encapsulate the
implementation-specific behavior.  The developer must use accessors to specify when
using the data on the host or the device.  This enables the SYCL runtime to
schedule optimal memory synchronization operations (e.g, copy or DMA
operations).</p>
<pre><code><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">sycl</span><span class="o">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bufA</span><span class="p">(</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">));</span><span class="w"></span>
</pre></div>
</code></pre>
<p>The buffer above can be accessed on the host and the device using
a host or a device accessor.  The buffer objects are not pointers, hence pointer arithmetic is
not possible. The pointer that can be obtained when using the accessor is only
valid for the duration of the access, as there is no guarantee the underlying
memory is the same between multiple accesses.</p>
<p>This mechanism is typically more suited to C++ code-bases, as it is type-safe and
enables further runtime optimizations.  However, in order to port existing CUDA
code, it may not be possible to replace the existing code completely to use
this mechanism.  For this reason, we provide a number of utilities in 
the <a href="https://github.com/codeplaysoftware/computecpp-sdk/">computecpp-sdk</a>
that help to expose a CUDA-like pointer to the legacy application whilst keeping
SYCL objects underneath.  We focus on 
the <a href="https://github.com/codeplaysoftware/computecpp-sdk/tree/master/include/vptr">Software-managed virtual pointer</a>
since it is the one that has been used to port Eigen and Tensorflow to SYCL.
When using the <em>vptr</em> utility, users can create a <em>PointerMapper</em> structure
that holds the mapping of virtual addresses to SYCL buffers.  This enables
using C-style <em>malloc</em> and <em>free</em> functions that will return
non-dereferenciable pointers that can be used in pointer arithmetic.  The
example below, extracted from the computecpp-sdk, illustrates its usage:</p>
<p>The following code shows how to mimic the CUDA-like pointer in SYCL,
by creating a C-style pointer and applying arithmetic operations on the pointer
without dereferencing it on the host side.</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="c1">// Create the Pointer Mapper structure</span>
<span class="n">PointerMapper</span><span class="w"> </span><span class="n">pMap</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Create a SYCL buffer of 10 floats</span>
<span class="c1">// This pointer is a number that identifies the buffer</span>
<span class="c1">// in the pointer mapper structure</span>
<span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">SYCLmalloc</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">pMap</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Create a SYCL buffer of 25 integers</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">SYCLmalloc</span><span class="p">(</span><span class="mi">25</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">pMap</span><span class="p">));</span><span class="w"></span>
<span class="c1">// Create a pointer to the 5th element</span>
<span class="c1">// This simply adds 5 * sizeof(float *) to the base address.</span>
<span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Retrieve the buffer</span>
<span class="n">assert</span><span class="p">(</span><span class="n">pMap</span><span class="p">.</span><span class="n">get_buffer</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pMap</span><span class="p">.</span><span class="n">get_buffer</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w"></span>
<span class="c1">// Substracting the value of the offset from the base address of the</span>
<span class="c1">// buffer recovers the offset into it</span>
<span class="n">assert</span><span class="p">(</span><span class="n">pMap</span><span class="p">.</span><span class="n">get_offset</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">))</span><span class="w"></span>

<span class="c1">// Invalid usage: no-dereference on the host</span>
<span class="c1">// float myVal = *c;</span>
<span class="c1">// Valid access on host: Use host-accessor</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">syclAcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pMap</span><span class="p">.</span><span class="n">get_buffer</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">myVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclAcc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Free the pointers</span>
<span class="n">SYCLfree</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">pMap</span><span class="p">);</span><span class="w"></span>
<span class="n">SYCLfree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">pMap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</code></pre>
<a class="header-link" href="#cuda-unified-virtual-addressing" id="cuda-unified-virtual-addressing"><h4>CUDA Unified virtual addressing</h4></a>
<p>When a CUDA application is built on a 64-bit system, on hardware
supporting the compute capability 2.0 and higher, the host and multiple
devices share a common virtual address space.  This is possible due to the
interaction of the CUDA application with the NVIDIA system driver.  All host memory allocations made via
CUDA API calls and all device memory allocations on supported devices are
within this virtual address range.  This enables detecting the device that
contains a given pointer by using specific query functions, and using specific
host allocation functions. Once the device is found, it is possible to enable
automatic porting of data across host and device. 
This feature requires a specific system-level driver provided by the vendor,
and it is not available on SYCL 1.2.1 (or OpenCL 1.2).  Note, however, that
SYCL objects do automatically handle the transition between the host and the
device, and no explicit copy operation is required (as opposed to OpenCL).</p>
<p>In more recent versions of SYCL and OpenCL, new API features partially enable this
feature. However, hardware support is not widely available.</p>
<a class="header-link" href="#cuda-unified-memory" id="cuda-unified-memory"><h4>CUDA unified memory</h4></a>
<p>CUDA unified memory enables using the same pointer across host and device, and
provides memory management services to a wide range of programs (either CUDA
runtime API or directly from within the kernel). It enables, for example,
kernels to trigger page-faults to read memory from the host. It can also
automatically alter the memory allocation for cases where the requested size of
memory is larger than the available memory size.</p>
<p>Unified Memory offers a “single-pointer-to-data” model that is conceptually
similar to CUDA’s zero-copy memory. One key difference between the two is that
with zero-copy allocations, the physical location of memory is pinned in CPU
system memory such that a program may have fast or slow access to it depending
on where it is being accessed from. Unified Memory, on the other hand,
decouples memory and execution spaces so that all data accesses are fast.</p>
<p>CUDA unified memory is also called managed memory. There are two ways to create managed memory.</p>
<ul>
<li>By using <code>__managed__</code> attribute in front of memory declaration. This can only be done in global-scope or file-scope.</li>
</ul>
<p>The following code snippet shows how to define <code>__managed_memory__</code> in CUDA.</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="c1">//...</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">custom_kernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">y</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">  </span><span class="c1">//....</span>

<span class="w">  </span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">//...</span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</code></pre>
<ul>
<li>By using CUDA runtime functions.</li>
</ul>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaMallocManaged</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">devPtr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</code></pre>
<p>The following code shows how to define managed memory using CUDA runtime functions.</p>
<pre><code class="cpp"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">custom_kernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dev_a</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dev_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">dev_a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// allocate the memory on the GPU</span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev_a</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dev_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">//....</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</code></pre>
<p>All CUDA operations that are valid on device memory are also valid on managed
memory. The primary difference is that the host is also able to reference and
access managed memory.</p>
<p>Like in the case of CUDA unified virtual addressing, this feature requires a
specific system-level driver provided by the vendor, and it is not available on
SYCL 1.2.1 (or OpenCL 1.2). Note, however, that SYCL objects do automatically handle 
the transition between the host and the device, and no explicit
copy operation is required (as opposed to OpenCL).</p>
<p>In newer versions of SYCL and OpenCL, new API features will partially enable this
feature.  In particular, SVM (Shared Virtual Memory), enables equivalent
behavior.</p>
<div id="copyright">SYCL is a trademark of the Khronos Group Inc. NVIDIA is a registered trademark of NVIDIA Corporation. AMD is a registered trademark of Advanced Micro Devices, Inc. ARM is a registered trademark of ARM Limited (or its subsidiaries) in the EU and/or elsewhere. All rights reserved TensorFlow and the TensorFlow logo and any related marks are trademarks of Google Inc. OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission by Khronos.</div>
</main>
</body>
</html>
